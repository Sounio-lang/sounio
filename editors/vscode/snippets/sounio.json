{
  "Function Definition": {
    "prefix": "fn",
    "body": [
      "fn ${1:name}(${2:params}) -> ${3:ReturnType} {",
      "\t$0",
      "}"
    ],
    "description": "Define a function"
  },
  "Function with Effects": {
    "prefix": "fnw",
    "body": [
      "fn ${1:name}(${2:params}) -> ${3:ReturnType} with ${4:IO} {",
      "\t$0",
      "}"
    ],
    "description": "Define a function with effect annotation"
  },
  "Async Function": {
    "prefix": "afn",
    "body": [
      "async fn ${1:name}(${2:params}) -> ${3:ReturnType} with Async {",
      "\t$0",
      "}"
    ],
    "description": "Define an async function"
  },
  "Struct Definition": {
    "prefix": "struct",
    "body": [
      "struct ${1:Name} {",
      "\t${2:field}: ${3:Type},",
      "\t$0",
      "}"
    ],
    "description": "Define a struct"
  },
  "Linear Struct": {
    "prefix": "linearstruct",
    "body": [
      "linear struct ${1:Name} {",
      "\t${2:field}: ${3:Type},",
      "\t$0",
      "}"
    ],
    "description": "Define a linear struct (must be consumed exactly once)"
  },
  "Affine Struct": {
    "prefix": "affinestruct",
    "body": [
      "affine struct ${1:Name} {",
      "\t${2:field}: ${3:Type},",
      "\t$0",
      "}"
    ],
    "description": "Define an affine struct (can be consumed at most once)"
  },
  "Enum Definition": {
    "prefix": "enum",
    "body": [
      "enum ${1:Name} {",
      "\t${2:Variant1},",
      "\t${3:Variant2},",
      "\t$0",
      "}"
    ],
    "description": "Define an enum"
  },
  "Enum with Data": {
    "prefix": "enumdata",
    "body": [
      "enum ${1:Name} {",
      "\t${2:Variant1}(${3:Type}),",
      "\t${4:Variant2} { ${5:field}: ${6:Type} },",
      "\t$0",
      "}"
    ],
    "description": "Define an enum with data variants"
  },
  "Implementation Block": {
    "prefix": "impl",
    "body": [
      "impl ${1:Type} {",
      "\tfn ${2:method}(&self${3}) -> ${4:ReturnType} {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Define an implementation block"
  },
  "Trait Implementation": {
    "prefix": "implfor",
    "body": [
      "impl ${1:Trait} for ${2:Type} {",
      "\tfn ${3:method}(&self${4}) -> ${5:ReturnType} {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Implement a trait for a type"
  },
  "Trait Definition": {
    "prefix": "trait",
    "body": [
      "trait ${1:Name} {",
      "\tfn ${2:method}(&self${3}) -> ${4:ReturnType};",
      "\t$0",
      "}"
    ],
    "description": "Define a trait"
  },
  "Match Expression": {
    "prefix": "match",
    "body": [
      "match ${1:value} {",
      "\t${2:pattern1} => ${3:expr1},",
      "\t${4:pattern2} => ${5:expr2},",
      "\t_ => ${6:default},$0",
      "}"
    ],
    "description": "Match expression"
  },
  "If Expression": {
    "prefix": "if",
    "body": [
      "if ${1:condition} {",
      "\t$0",
      "}"
    ],
    "description": "If expression"
  },
  "If-Else Expression": {
    "prefix": "ife",
    "body": [
      "if ${1:condition} {",
      "\t$2",
      "} else {",
      "\t$0",
      "}"
    ],
    "description": "If-else expression"
  },
  "If-Else If-Else Expression": {
    "prefix": "ifeif",
    "body": [
      "if ${1:condition1} {",
      "\t$2",
      "} else if ${3:condition2} {",
      "\t$4",
      "} else {",
      "\t$0",
      "}"
    ],
    "description": "If-else if-else expression"
  },
  "For Loop": {
    "prefix": "for",
    "body": [
      "for ${1:item} in ${2:collection} {",
      "\t$0",
      "}"
    ],
    "description": "For loop"
  },
  "For Range Loop": {
    "prefix": "forr",
    "body": [
      "for ${1:i} in ${2:0}..${3:n} {",
      "\t$0",
      "}"
    ],
    "description": "For loop with range"
  },
  "While Loop": {
    "prefix": "while",
    "body": [
      "while ${1:condition} {",
      "\t$0",
      "}"
    ],
    "description": "While loop"
  },
  "Let Binding": {
    "prefix": "let",
    "body": [
      "let ${1:name} = ${2:value}"
    ],
    "description": "Immutable let binding"
  },
  "Let with Type": {
    "prefix": "lett",
    "body": [
      "let ${1:name}: ${2:Type} = ${3:value}"
    ],
    "description": "Immutable let binding with type annotation"
  },
  "Mutable Variable": {
    "prefix": "var",
    "body": [
      "var ${1:name} = ${2:value}"
    ],
    "description": "Mutable variable binding"
  },
  "Mutable Variable with Type": {
    "prefix": "vart",
    "body": [
      "var ${1:name}: ${2:Type} = ${3:value}"
    ],
    "description": "Mutable variable binding with type annotation"
  },
  "GPU Kernel": {
    "prefix": "kernel",
    "body": [
      "kernel fn ${1:name}(${2:a}: &[${3:f32}], ${4:b}: &[${5:f32}], ${6:out}: &![${7:f32}]) {",
      "\tlet ${8:i} = gpu.thread_id.x",
      "\t$0",
      "}"
    ],
    "description": "GPU kernel function"
  },
  "GPU Kernel Simple": {
    "prefix": "kernelsimple",
    "body": [
      "kernel fn ${1:name}(${2:input}: &[${3:f32}], ${4:output}: &![${5:f32}]) {",
      "\tlet i = gpu.thread_id.x",
      "\t${4}[i] = ${2}[i]$0",
      "}"
    ],
    "description": "Simple GPU kernel with single input/output"
  },
  "Effect Handler": {
    "prefix": "effect",
    "body": [
      "effect ${1:EffectName} {",
      "\tfn ${2:operation}(${3:params}) -> ${4:ReturnType};",
      "\t$0",
      "}"
    ],
    "description": "Define an effect"
  },
  "Handle Effect": {
    "prefix": "handle",
    "body": [
      "handle ${1:expr} with {",
      "\t${2:effect_op}(${3:args}) => ${4:handler_body},",
      "\treturn(${5:x}) => ${6:x},$0",
      "}"
    ],
    "description": "Handle an effect"
  },
  "Knowledge Type": {
    "prefix": "knowledge",
    "body": [
      "let ${1:name}: Knowledge<${2:Type}> = ${3:value} @ ${4:0.95} from ${5:\"source\"}"
    ],
    "description": "Knowledge type with confidence and provenance"
  },
  "Uncertain Value": {
    "prefix": "uncertain",
    "body": [
      "let ${1:name}: Uncertain<${2:f64}> = uncertain(${3:mean}, ${4:stddev})"
    ],
    "description": "Uncertain value with mean and standard deviation"
  },
  "Confidence Annotation": {
    "prefix": "conf",
    "body": [
      "${1:value} @ ${2:0.95}"
    ],
    "description": "Confidence annotation"
  },
  "Provenance Annotation": {
    "prefix": "prov",
    "body": [
      "${1:value} from ${2:\"source\"}"
    ],
    "description": "Provenance annotation"
  },
  "Quantity with Units": {
    "prefix": "quantity",
    "body": [
      "let ${1:name}: ${2:mg} = ${3:500.0}"
    ],
    "description": "Quantity with unit of measure"
  },
  "Quantity Division": {
    "prefix": "quantitydiv",
    "body": [
      "let ${1:concentration}: ${2:mg}/${3:L} = ${4:dose} / ${5:volume}"
    ],
    "description": "Quantity from division (e.g., concentration)"
  },
  "Common Units - Mass": {
    "prefix": "unitmass",
    "body": [
      "let ${1:mass}: ${2|kg,g,mg,ug,ng|} = ${3:value}"
    ],
    "description": "Mass quantity with common units"
  },
  "Common Units - Volume": {
    "prefix": "unitvolume",
    "body": [
      "let ${1:volume}: ${2|L,mL,uL|} = ${3:value}"
    ],
    "description": "Volume quantity with common units"
  },
  "Common Units - Time": {
    "prefix": "unittime",
    "body": [
      "let ${1:time}: ${2|s,ms,min,h,d|} = ${3:value}"
    ],
    "description": "Time quantity with common units"
  },
  "Test Function": {
    "prefix": "test",
    "body": [
      "//@ run-pass",
      "fn test_${1:name}() {",
      "\t$0",
      "}"
    ],
    "description": "Test function with run-pass annotation"
  },
  "Compile-Fail Test": {
    "prefix": "testfail",
    "body": [
      "//@ compile-fail",
      "//@ error-pattern: ${1:expected error}",
      "fn test_${2:name}() {",
      "\t$0",
      "}"
    ],
    "description": "Test function expected to fail compilation"
  },
  "Module Declaration": {
    "prefix": "mod",
    "body": [
      "mod ${1:name} {",
      "\t$0",
      "}"
    ],
    "description": "Module declaration"
  },
  "Use Import": {
    "prefix": "use",
    "body": [
      "use ${1:module}::${2:item}"
    ],
    "description": "Import from module"
  },
  "Use Import Multiple": {
    "prefix": "usemulti",
    "body": [
      "use ${1:module}::{${2:item1}, ${3:item2}}"
    ],
    "description": "Import multiple items from module"
  },
  "Refinement Type": {
    "prefix": "refine",
    "body": [
      "type ${1:Name} = { ${2:x}: ${3:i32} | ${4:x > 0} }"
    ],
    "description": "Refinement type with predicate"
  },
  "Type Alias": {
    "prefix": "type",
    "body": [
      "type ${1:Name} = ${2:Type}"
    ],
    "description": "Type alias"
  },
  "Closure": {
    "prefix": "closure",
    "body": [
      "|${1:params}| ${2:expr}"
    ],
    "description": "Closure expression"
  },
  "Closure Block": {
    "prefix": "closureblock",
    "body": [
      "|${1:params}| {",
      "\t$0",
      "}"
    ],
    "description": "Closure with block body"
  },
  "Mutable Reference": {
    "prefix": "refmut",
    "body": [
      "&!${1:value}"
    ],
    "description": "Mutable/exclusive reference (NOT &mut)"
  },
  "Shared Reference": {
    "prefix": "ref",
    "body": [
      "&${1:value}"
    ],
    "description": "Shared reference"
  },
  "Array Literal": {
    "prefix": "arr",
    "body": [
      "[${1:elem1}, ${2:elem2}, ${3:elem3}]"
    ],
    "description": "Array literal"
  },
  "Array Slice Head": {
    "prefix": "slicehead",
    "body": [
      "${1:arr}[..${2:k}]"
    ],
    "description": "First k elements of array"
  },
  "Array Slice Tail": {
    "prefix": "slicetail",
    "body": [
      "${1:arr}[${2:k}..]"
    ],
    "description": "Elements from k to end"
  },
  "Array Concatenation": {
    "prefix": "concat",
    "body": [
      "${1:a} ++ ${2:b}"
    ],
    "description": "Array concatenation"
  },
  "Main Function": {
    "prefix": "main",
    "body": [
      "fn main() with IO {",
      "\t$0",
      "}"
    ],
    "description": "Main function with IO effect"
  },
  "Print": {
    "prefix": "print",
    "body": [
      "print(${1:\"message\"})"
    ],
    "description": "Print to stdout"
  },
  "Println": {
    "prefix": "println",
    "body": [
      "println(${1:\"message\"})"
    ],
    "description": "Print line to stdout"
  },
  "Ontology Type": {
    "prefix": "ontology",
    "body": [
      "type ${1:Name} = @ontology(\"${2:SNOMED_CT}\", \"${3:12345}\")"
    ],
    "description": "Type backed by ontology term"
  },
  "Epistemic Assertion": {
    "prefix": "assert_confidence",
    "body": [
      "assert_confidence(${1:value}, >= ${2:0.95})"
    ],
    "description": "Assert minimum confidence level"
  },
  "GPU Block": {
    "prefix": "gpublock",
    "body": [
      "gpu {",
      "\tlet block_size = ${1:256}",
      "\tlet grid_size = (${2:n} + block_size - 1) / block_size",
      "\t${3:kernel_name}<<<grid_size, block_size>>>(${4:args})",
      "\t$0",
      "}"
    ],
    "description": "GPU execution block"
  }
}
