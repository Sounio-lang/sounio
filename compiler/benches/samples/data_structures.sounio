// Data Structure Benchmark - Struct and Enum Operations

struct Point {
    x: f64,
    y: f64
}

struct Rect {
    origin: Point,
    width: f64,
    height: f64
}

struct Circle {
    center: Point,
    radius: f64
}

enum Shape {
    Rectangle(Rect),
    Circle(Circle),
    Point(Point)
}

fn distance(a: Point, b: Point) -> f64 {
    let dx = a.x - b.x;
    let dy = a.y - b.y;
    // sqrt not available, return squared distance
    return dx * dx + dy * dy;
}

fn rect_area(r: Rect) -> f64 {
    return r.width * r.height;
}

fn circle_area(c: Circle) -> f64 {
    let pi = 3.14159265359;
    return pi * c.radius * c.radius;
}

fn rect_perimeter(r: Rect) -> f64 {
    return 2.0 * (r.width + r.height);
}

fn circle_perimeter(c: Circle) -> f64 {
    let pi = 3.14159265359;
    return 2.0 * pi * c.radius;
}

fn rect_contains(r: Rect, p: Point) -> bool {
    let in_x = p.x >= r.origin.x && p.x <= r.origin.x + r.width;
    let in_y = p.y >= r.origin.y && p.y <= r.origin.y + r.height;
    return in_x && in_y;
}

fn circle_contains(c: Circle, p: Point) -> bool {
    let dist_sq = distance(c.center, p);
    return dist_sq <= c.radius * c.radius;
}

fn create_grid(rows: i32, cols: i32) -> f64 {
    var total_area = 0.0;
    var r = 0;

    while r < rows {
        var c = 0;
        while c < cols {
            let rect = Rect {
                origin: Point { x: (c * 10), y: (r * 10) },
                width: 9.0,
                height: 9.0
            };
            total_area = total_area + rect_area(rect);
            c = c + 1;
        }
        r = r + 1;
    }

    return total_area;
}

fn main() -> f64 {
    let p1 = Point { x: 0.0, y: 0.0 };
    let p2 = Point { x: 3.0, y: 4.0 };

    let rect = Rect {
        origin: p1,
        width: 10.0,
        height: 5.0
    };

    let circle = Circle {
        center: p2,
        radius: 3.0
    };

    let grid_area = create_grid(10, 10);
    let r_area = rect_area(rect);
    let c_area = circle_area(circle);

    return grid_area + r_area + c_area;
}
