// Linear Types Benchmark
// Tests linear and affine type checking performance

// Linear struct - must be used exactly once
linear struct FileHandle {
    fd: i32,
    path: i32  // Would be string
}

linear struct SocketHandle {
    fd: i32,
    port: i32
}

linear struct DatabaseConnection {
    id: i32,
    host: i32  // Would be string
}

// Affine struct - can be used at most once
affine struct TempBuffer {
    data: i32,
    size: i32
}

affine struct CacheEntry {
    key: i32,
    value: i32
}

// Functions consuming linear types
fn close_file(handle: FileHandle) -> i32 {
    return handle.fd;
}

fn close_socket(handle: SocketHandle) -> i32 {
    return handle.fd;
}

fn close_db(conn: DatabaseConnection) -> i32 {
    return conn.id;
}

// Functions borrowing
fn read_file(handle: &FileHandle) -> i32 {
    return 0;
}

fn write_file(handle: &!FileHandle, data: i32) -> i32 {
    return data;
}

// Transfer of ownership
fn transfer_file(handle: FileHandle) -> FileHandle {
    return handle;
}

// Multiple linear resources
fn pipeline(file: FileHandle, socket: SocketHandle) -> i32 {
    let a = close_file(file);
    let b = close_socket(socket);
    return a + b;
}

// Complex ownership flow
fn complex_ownership() -> i32 {
    let file1 = FileHandle { fd: 1, path: 0 };
    let file2 = FileHandle { fd: 2, path: 1 };
    let socket = SocketHandle { fd: 3, port: 8080 };

    let transferred = transfer_file(file1);
    let result1 = close_file(transferred);
    let result2 = close_file(file2);
    let result3 = close_socket(socket);

    return result1 + result2 + result3;
}

// Affine type usage
fn use_buffer(buf: TempBuffer) -> i32 {
    return buf.size;
}

fn maybe_use_cache(entry: CacheEntry, use_it: bool) -> i32 {
    if use_it {
        return entry.value;
    } else {
        // entry is dropped here (affine allows this)
        return 0;
    }
}

// Nested linear types
linear struct Transaction {
    file: i32,  // Would be FileHandle
    db: i32     // Would be DatabaseConnection
}

fn commit_transaction(tx: Transaction) -> i32 {
    return tx.file + tx.db;
}

fn main() -> i32 {
    let result = complex_ownership();

    let buf = TempBuffer { data: 100, size: 1024 };
    let buf_result = use_buffer(buf);

    let cache = CacheEntry { key: 1, value: 42 };
    let cache_result = maybe_use_cache(cache, true);

    return result + buf_result + cache_result;
}
