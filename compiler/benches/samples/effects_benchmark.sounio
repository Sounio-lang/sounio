// Effects System Benchmark
// Tests various effect combinations and handler patterns

// Pure computation (no effects)
fn pure_add(a: i32, b: i32) -> i32 {
    return a + b;
}

fn pure_multiply(a: i32, b: i32) -> i32 {
    return a * b;
}

// IO effect
fn log_value(msg: i32) with IO {
    // Would print in real implementation
}

fn read_input() -> i32 with IO {
    return 42;
}

// Mut effect (mutation)
fn increment_counter(counter: i32) -> i32 with Mut {
    return counter + 1;
}

// Combined effects
fn process_with_io_mut(value: i32) -> i32 with IO, Mut {
    log_value(value);
    return increment_counter(value);
}

// Alloc effect (allocation)
fn allocate_buffer(size: i32) -> i32 with Alloc {
    // Would allocate in real implementation
    return size;
}

// Panic effect (may fail)
fn checked_divide(a: i32, b: i32) -> i32 with Panic {
    if b == 0 {
        return 0;  // Would panic in real implementation
    } else {
        return a / b;
    }
}

// Multiple functions with same effects
fn compute1() -> i32 with IO, Mut {
    return 1;
}

fn compute2() -> i32 with IO, Mut {
    return 2;
}

fn compute3() -> i32 with IO, Mut {
    return 3;
}

// Effect polymorphism simulation
fn apply_twice(x: i32) -> i32 {
    let first = pure_add(x, x);
    let second = pure_multiply(first, 2);
    return second;
}

// Complex effect chain
fn complex_workflow(input: i32) -> i32 with IO, Mut, Alloc, Panic {
    let step1 = read_input();
    let step2 = allocate_buffer(step1);
    let step3 = checked_divide(step2, 2);
    let step4 = process_with_io_mut(step3);
    return step4;
}

// Benchmark function that exercises effects
fn effects_benchmark() -> i32 with IO, Mut {
    var total = 0;
    var i = 0;

    while i < 100 {
        total = total + compute1();
        total = total + compute2();
        total = total + compute3();
        i = i + 1;
    }

    return total;
}

fn main() -> i32 {
    // Pure computations
    let pure_result = apply_twice(10);

    // Would need effect handling in real implementation
    // For now, just return pure result
    return pure_result;
}
