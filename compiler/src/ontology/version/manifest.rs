//! Manifest (Lock File) for Ontology Versions
//!
//! This module implements the `ontology.lock` file format for pinning
//! exact ontology versions to ensure reproducible builds.
//!
//! # Format
//!
//! The lock file uses TOML format:
//!
//! ```toml
//! # ontology.lock - DO NOT EDIT MANUALLY
//! # Generated by Sounio compiler
//!
//! [metadata]
//! generated = "2025-01-15T10:30:00Z"
//! sounio_version = "0.1.0"
//! schema_version = 1
//!
//! [[ontology]]
//! name = "chebi"
//! version = "2024-01-01"
//! checksum = "sha256:abc123..."
//! source = "https://purl.obolibrary.org/obo/chebi.owl"
//! layer = "domain"
//!
//! [[ontology]]
//! name = "go"
//! version = "2024-01-15"
//! checksum = "sha256:def456..."
//! source = "semantic-sql"
//! terms_used = 142
//! ```

use std::collections::HashMap;
use std::fs;
use std::io::{self};
use std::path::Path;

use super::{Checksum, OntologyVersion};
use crate::ontology::OntologyLayer;

/// Current schema version for the lock file
pub const SCHEMA_VERSION: u32 = 1;

/// Manifest (lock file) containing pinned ontology versions
#[derive(Debug, Clone)]
pub struct Manifest {
    /// Metadata about the manifest
    pub metadata: ManifestMetadata,
    /// Pinned ontology entries
    pub ontologies: Vec<OntologyEntry>,
    /// Index by name for fast lookup
    index: HashMap<String, usize>,
}

/// Metadata section of the manifest
#[derive(Debug, Clone)]
pub struct ManifestMetadata {
    /// When this manifest was generated
    pub generated: String,
    /// Sounio compiler version
    pub sounio_version: String,
    /// Schema version for forward compatibility
    pub schema_version: u32,
    /// Optional comment
    pub comment: Option<String>,
}

impl Default for ManifestMetadata {
    fn default() -> Self {
        Self {
            generated: chrono_lite_now(),
            sounio_version: env!("CARGO_PKG_VERSION").to_string(),
            schema_version: SCHEMA_VERSION,
            comment: None,
        }
    }
}

/// A pinned ontology entry in the manifest
#[derive(Debug, Clone)]
pub struct OntologyEntry {
    /// Ontology name/prefix (e.g., "chebi", "go")
    pub name: String,
    /// Exact version pinned
    pub version: OntologyVersion,
    /// Integrity checksum
    pub checksum: Option<Checksum>,
    /// Where this ontology was obtained
    pub source: OntologySource,
    /// Which layer this ontology belongs to
    pub layer: OntologyLayer,
    /// Number of terms used from this ontology (for partial deps)
    pub terms_used: Option<usize>,
    /// Specific terms used (optional, for audit)
    pub term_ids: Option<Vec<String>>,
    /// Dependencies on other ontologies
    pub dependencies: Vec<String>,
}

/// Source of an ontology
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum OntologySource {
    /// URL to OWL/OBO file
    Url(String),
    /// Semantic-SQL database
    SemanticSql,
    /// Local file path
    LocalFile(String),
    /// BioPortal API
    BioPortal,
    /// OLS4 API
    Ols4,
    /// Built into compiler
    Builtin,
}

impl OntologySource {
    /// Parse from string representation
    pub fn parse(s: &str) -> Self {
        match s {
            "semantic-sql" => OntologySource::SemanticSql,
            "bioportal" => OntologySource::BioPortal,
            "ols4" => OntologySource::Ols4,
            "builtin" => OntologySource::Builtin,
            s if s.starts_with("http://") || s.starts_with("https://") => {
                OntologySource::Url(s.to_string())
            }
            s if s.starts_with("file://") => {
                OntologySource::LocalFile(s.strip_prefix("file://").unwrap().to_string())
            }
            s => OntologySource::LocalFile(s.to_string()),
        }
    }

    /// Convert to string representation
    pub fn to_string_repr(&self) -> String {
        match self {
            OntologySource::Url(url) => url.clone(),
            OntologySource::SemanticSql => "semantic-sql".to_string(),
            OntologySource::LocalFile(path) => format!("file://{}", path),
            OntologySource::BioPortal => "bioportal".to_string(),
            OntologySource::Ols4 => "ols4".to_string(),
            OntologySource::Builtin => "builtin".to_string(),
        }
    }
}

/// Errors that can occur with manifests
#[derive(Debug, thiserror::Error)]
pub enum ManifestError {
    #[error("IO error: {0}")]
    Io(#[from] io::Error),

    #[error("Parse error at line {line}: {message}")]
    Parse { line: usize, message: String },

    #[error("Missing required field: {0}")]
    MissingField(String),

    #[error("Invalid version: {0}")]
    InvalidVersion(String),

    #[error("Schema version {found} is newer than supported {supported}")]
    UnsupportedSchema { found: u32, supported: u32 },

    #[error("Checksum mismatch for {ontology}: expected {expected}, got {actual}")]
    ChecksumMismatch {
        ontology: String,
        expected: String,
        actual: String,
    },

    #[error("Duplicate ontology entry: {0}")]
    DuplicateEntry(String),
}

impl Manifest {
    /// Create a new empty manifest
    pub fn new() -> Self {
        Self {
            metadata: ManifestMetadata::default(),
            ontologies: Vec::new(),
            index: HashMap::new(),
        }
    }

    /// Load a manifest from a file
    pub fn load(path: impl AsRef<Path>) -> Result<Self, ManifestError> {
        let content = fs::read_to_string(path)?;
        Self::parse(&content)
    }

    /// Parse manifest from TOML-like content
    pub fn parse(content: &str) -> Result<Self, ManifestError> {
        let mut manifest = Manifest::new();
        let mut current_section: Option<&str> = None;
        let mut current_entry: Option<OntologyEntryBuilder> = None;

        for (line_num, line) in content.lines().enumerate() {
            let line = line.trim();

            // Skip empty lines and comments
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // Section headers
            if line == "[metadata]" {
                // Flush any pending entry
                if let Some(builder) = current_entry.take() {
                    manifest.add_entry(builder.build()?)?;
                }
                current_section = Some("metadata");
                continue;
            }

            if line == "[[ontology]]" {
                // Flush previous entry
                if let Some(builder) = current_entry.take() {
                    manifest.add_entry(builder.build()?)?;
                }
                current_section = Some("ontology");
                current_entry = Some(OntologyEntryBuilder::new());
                continue;
            }

            // Key-value pairs
            if let Some((key, value)) = parse_key_value(line) {
                match current_section {
                    Some("metadata") => {
                        manifest.parse_metadata_field(key, value, line_num + 1)?;
                    }
                    Some("ontology") => {
                        if let Some(ref mut builder) = current_entry {
                            builder.set_field(key, value, line_num + 1)?;
                        }
                    }
                    _ => {
                        return Err(ManifestError::Parse {
                            line: line_num + 1,
                            message: "Key-value outside of section".to_string(),
                        });
                    }
                }
            } else {
                return Err(ManifestError::Parse {
                    line: line_num + 1,
                    message: format!("Invalid line: {}", line),
                });
            }
        }

        // Flush final entry
        if let Some(builder) = current_entry {
            manifest.add_entry(builder.build()?)?;
        }

        Ok(manifest)
    }

    fn parse_metadata_field(
        &mut self,
        key: &str,
        value: &str,
        _line: usize,
    ) -> Result<(), ManifestError> {
        match key {
            "generated" => self.metadata.generated = value.to_string(),
            "sounio_version" => self.metadata.sounio_version = value.to_string(),
            "schema_version" => {
                let version: u32 = value
                    .parse()
                    .map_err(|_| ManifestError::InvalidVersion(value.to_string()))?;
                if version > SCHEMA_VERSION {
                    return Err(ManifestError::UnsupportedSchema {
                        found: version,
                        supported: SCHEMA_VERSION,
                    });
                }
                self.metadata.schema_version = version;
            }
            "comment" => self.metadata.comment = Some(value.to_string()),
            _ => {} // Ignore unknown fields for forward compatibility
        }
        Ok(())
    }

    fn add_entry(&mut self, entry: OntologyEntry) -> Result<(), ManifestError> {
        if self.index.contains_key(&entry.name) {
            return Err(ManifestError::DuplicateEntry(entry.name.clone()));
        }
        let idx = self.ontologies.len();
        self.index.insert(entry.name.clone(), idx);
        self.ontologies.push(entry);
        Ok(())
    }

    /// Save manifest to a file
    pub fn save(&self, path: impl AsRef<Path>) -> Result<(), ManifestError> {
        let content = self.to_toml();
        fs::write(path, content)?;
        Ok(())
    }

    /// Convert to TOML string
    pub fn to_toml(&self) -> String {
        let mut output = String::new();

        // Header comment
        output.push_str("# ontology.lock - DO NOT EDIT MANUALLY\n");
        output.push_str("# Generated by Sounio compiler\n\n");

        // Metadata section
        output.push_str("[metadata]\n");
        output.push_str(&format!("generated = \"{}\"\n", self.metadata.generated));
        output.push_str(&format!(
            "sounio_version = \"{}\"\n",
            self.metadata.sounio_version
        ));
        output.push_str(&format!(
            "schema_version = {}\n",
            self.metadata.schema_version
        ));
        if let Some(comment) = &self.metadata.comment {
            output.push_str(&format!("comment = \"{}\"\n", escape_string(comment)));
        }
        output.push('\n');

        // Ontology entries
        for entry in &self.ontologies {
            output.push_str("[[ontology]]\n");
            output.push_str(&format!("name = \"{}\"\n", entry.name));
            output.push_str(&format!("version = \"{}\"\n", entry.version));
            if let Some(checksum) = &entry.checksum {
                output.push_str(&format!("checksum = \"{}\"\n", checksum));
            }
            output.push_str(&format!("source = \"{}\"\n", entry.source.to_string_repr()));
            output.push_str(&format!("layer = \"{}\"\n", layer_to_string(entry.layer)));
            if let Some(terms) = entry.terms_used {
                output.push_str(&format!("terms_used = {}\n", terms));
            }
            if let Some(ref deps) = entry.dependencies.is_empty().then_some(()).or(None) {
                let _ = deps; // Unused
            }
            if !entry.dependencies.is_empty() {
                output.push_str(&format!(
                    "dependencies = [{}]\n",
                    entry
                        .dependencies
                        .iter()
                        .map(|d| format!("\"{}\"", d))
                        .collect::<Vec<_>>()
                        .join(", ")
                ));
            }
            output.push('\n');
        }

        output
    }

    /// Get an ontology entry by name
    pub fn get(&self, name: &str) -> Option<&OntologyEntry> {
        self.index.get(name).map(|&idx| &self.ontologies[idx])
    }

    /// Check if an ontology is present
    pub fn contains(&self, name: &str) -> bool {
        self.index.contains_key(name)
    }

    /// Get all ontology names
    pub fn names(&self) -> impl Iterator<Item = &str> {
        self.ontologies.iter().map(|e| e.name.as_str())
    }

    /// Get number of ontologies
    pub fn len(&self) -> usize {
        self.ontologies.len()
    }

    /// Check if manifest is empty
    pub fn is_empty(&self) -> bool {
        self.ontologies.is_empty()
    }

    /// Add or update an ontology entry
    pub fn upsert(&mut self, entry: OntologyEntry) {
        if let Some(&idx) = self.index.get(&entry.name) {
            self.ontologies[idx] = entry;
        } else {
            let idx = self.ontologies.len();
            self.index.insert(entry.name.clone(), idx);
            self.ontologies.push(entry);
        }
    }

    /// Remove an ontology entry
    pub fn remove(&mut self, name: &str) -> Option<OntologyEntry> {
        if let Some(idx) = self.index.remove(name) {
            let entry = self.ontologies.remove(idx);
            // Rebuild index
            self.index.clear();
            for (i, e) in self.ontologies.iter().enumerate() {
                self.index.insert(e.name.clone(), i);
            }
            Some(entry)
        } else {
            None
        }
    }

    /// Update the generation timestamp
    pub fn touch(&mut self) {
        self.metadata.generated = chrono_lite_now();
    }

    /// Verify all checksums against provided data
    pub fn verify_checksums(
        &self,
        get_data: impl Fn(&str) -> Option<Vec<u8>>,
    ) -> Result<(), ManifestError> {
        for entry in &self.ontologies {
            if let Some(checksum) = &entry.checksum
                && let Some(data) = get_data(&entry.name)
                && !checksum.verify(&data)
            {
                return Err(ManifestError::ChecksumMismatch {
                    ontology: entry.name.clone(),
                    expected: checksum.hash.clone(),
                    actual: "computed_hash".to_string(), // Would compute actual hash
                });
            }
        }
        Ok(())
    }

    /// Get ontologies that need updates based on available versions
    pub fn check_updates<'a>(
        &'a self,
        available: &'a HashMap<String, OntologyVersion>,
    ) -> Vec<(&'a OntologyEntry, &'a OntologyVersion)> {
        let mut updates = Vec::new();

        for entry in &self.ontologies {
            if let Some(available_version) = available.get(&entry.name)
                && let Some(std::cmp::Ordering::Less) = entry.version.compare(available_version)
            {
                updates.push((entry, available_version));
            }
        }

        updates
    }
}

impl Default for Manifest {
    fn default() -> Self {
        Self::new()
    }
}

/// Builder for OntologyEntry during parsing
#[derive(Debug, Default)]
struct OntologyEntryBuilder {
    name: Option<String>,
    version: Option<String>,
    checksum: Option<String>,
    source: Option<String>,
    layer: Option<String>,
    terms_used: Option<usize>,
    term_ids: Option<Vec<String>>,
    dependencies: Vec<String>,
}

impl OntologyEntryBuilder {
    fn new() -> Self {
        Self::default()
    }

    fn set_field(&mut self, key: &str, value: &str, line: usize) -> Result<(), ManifestError> {
        match key {
            "name" => self.name = Some(value.to_string()),
            "version" => self.version = Some(value.to_string()),
            "checksum" => self.checksum = Some(value.to_string()),
            "source" => self.source = Some(value.to_string()),
            "layer" => self.layer = Some(value.to_string()),
            "terms_used" => {
                self.terms_used = Some(value.parse().map_err(|_| ManifestError::Parse {
                    line,
                    message: format!("Invalid terms_used: {}", value),
                })?);
            }
            "dependencies" => {
                // Parse array: ["a", "b", "c"]
                self.dependencies = parse_string_array(value);
            }
            "term_ids" => {
                self.term_ids = Some(parse_string_array(value));
            }
            _ => {} // Ignore unknown for forward compatibility
        }
        Ok(())
    }

    fn build(self) -> Result<OntologyEntry, ManifestError> {
        let name = self
            .name
            .ok_or_else(|| ManifestError::MissingField("name".to_string()))?;
        let version_str = self
            .version
            .ok_or_else(|| ManifestError::MissingField("version".to_string()))?;
        let version = OntologyVersion::parse(&version_str)
            .map_err(|_| ManifestError::InvalidVersion(version_str))?;

        let source = self
            .source
            .map(|s| OntologySource::parse(&s))
            .unwrap_or(OntologySource::Builtin);

        let layer = self
            .layer
            .as_deref()
            .map(parse_layer)
            .unwrap_or(OntologyLayer::Domain);

        let checksum = self.checksum.and_then(|s| Checksum::parse(&s));

        Ok(OntologyEntry {
            name,
            version,
            checksum,
            source,
            layer,
            terms_used: self.terms_used,
            term_ids: self.term_ids,
            dependencies: self.dependencies,
        })
    }
}

// Helper functions

fn parse_key_value(line: &str) -> Option<(&str, &str)> {
    let (key, rest) = line.split_once('=')?;
    let key = key.trim();
    let value = rest.trim();

    // Remove quotes if present
    let value = if value.starts_with('"') && value.ends_with('"') {
        &value[1..value.len() - 1]
    } else {
        value
    };

    Some((key, value))
}

fn parse_string_array(value: &str) -> Vec<String> {
    let value = value.trim();
    if !value.starts_with('[') || !value.ends_with(']') {
        return Vec::new();
    }

    let inner = &value[1..value.len() - 1];
    inner
        .split(',')
        .map(|s| {
            let s = s.trim();
            if s.starts_with('"') && s.ends_with('"') {
                s[1..s.len() - 1].to_string()
            } else {
                s.to_string()
            }
        })
        .filter(|s| !s.is_empty())
        .collect()
}

fn layer_to_string(layer: OntologyLayer) -> &'static str {
    match layer {
        OntologyLayer::Primitive => "primitive",
        OntologyLayer::Foundation => "foundation",
        OntologyLayer::Domain => "domain",
        OntologyLayer::Federated => "federated",
    }
}

fn parse_layer(s: &str) -> OntologyLayer {
    match s.to_lowercase().as_str() {
        "primitive" => OntologyLayer::Primitive,
        "foundation" => OntologyLayer::Foundation,
        "domain" => OntologyLayer::Domain,
        "federated" => OntologyLayer::Federated,
        _ => OntologyLayer::Domain,
    }
}

fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
}

/// Simple timestamp without chrono dependency
fn chrono_lite_now() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};

    let duration = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default();

    // Convert to ISO 8601 format (approximate)
    let secs = duration.as_secs();
    let days_since_epoch = secs / 86400;
    let remaining_secs = secs % 86400;

    // Calculate date (simplified, doesn't account for all leap years perfectly)
    let mut year = 1970;
    let mut days = days_since_epoch;

    loop {
        let days_in_year = if is_leap_year(year) { 366 } else { 365 };
        if days < days_in_year {
            break;
        }
        days -= days_in_year;
        year += 1;
    }

    let month_days: [u64; 12] = if is_leap_year(year) {
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    } else {
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    };

    let mut month = 1;
    for &md in &month_days {
        if days < md {
            break;
        }
        days -= md;
        month += 1;
    }
    let day = days + 1;

    let hours = remaining_secs / 3600;
    let minutes = (remaining_secs % 3600) / 60;
    let seconds = remaining_secs % 60;

    format!(
        "{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z",
        year, month, day, hours, minutes, seconds
    )
}

fn is_leap_year(year: u64) -> bool {
    (year.is_multiple_of(4) && !year.is_multiple_of(100)) || year.is_multiple_of(400)
}

#[cfg(test)]
mod tests {
    use super::*;

    const SAMPLE_LOCK: &str = r#"
# ontology.lock - DO NOT EDIT MANUALLY
# Generated by Sounio compiler

[metadata]
generated = "2025-01-15T10:30:00Z"
sounio_version = "0.1.0"
schema_version = 1

[[ontology]]
name = "chebi"
version = "2024-01-01"
checksum = "sha256:abc123def456"
source = "https://purl.obolibrary.org/obo/chebi.owl"
layer = "domain"
terms_used = 142

[[ontology]]
name = "go"
version = "2024-01-15"
source = "semantic-sql"
layer = "domain"
dependencies = ["chebi", "bfo"]
"#;

    #[test]
    fn test_parse_manifest() {
        let manifest = Manifest::parse(SAMPLE_LOCK).unwrap();

        assert_eq!(manifest.metadata.schema_version, 1);
        assert_eq!(manifest.len(), 2);

        let chebi = manifest.get("chebi").unwrap();
        assert!(matches!(
            chebi.version,
            OntologyVersion::Date {
                year: 2024,
                month: 1,
                day: 1
            }
        ));
        assert_eq!(chebi.terms_used, Some(142));
        assert!(chebi.checksum.is_some());

        let go = manifest.get("go").unwrap();
        assert_eq!(go.dependencies, vec!["chebi", "bfo"]);
        assert_eq!(go.source, OntologySource::SemanticSql);
    }

    #[test]
    fn test_roundtrip() {
        let manifest = Manifest::parse(SAMPLE_LOCK).unwrap();
        let toml = manifest.to_toml();
        let reparsed = Manifest::parse(&toml).unwrap();

        assert_eq!(manifest.len(), reparsed.len());
        assert_eq!(
            manifest.get("chebi").unwrap().name,
            reparsed.get("chebi").unwrap().name
        );
    }

    #[test]
    fn test_new_manifest() {
        let mut manifest = Manifest::new();
        assert!(manifest.is_empty());

        manifest.upsert(OntologyEntry {
            name: "test".to_string(),
            version: OntologyVersion::parse("1.0.0").unwrap(),
            checksum: None,
            source: OntologySource::Builtin,
            layer: OntologyLayer::Foundation,
            terms_used: None,
            term_ids: None,
            dependencies: vec![],
        });

        assert_eq!(manifest.len(), 1);
        assert!(manifest.contains("test"));
    }

    #[test]
    fn test_remove_entry() {
        let mut manifest = Manifest::parse(SAMPLE_LOCK).unwrap();
        assert!(manifest.contains("chebi"));

        let removed = manifest.remove("chebi");
        assert!(removed.is_some());
        assert!(!manifest.contains("chebi"));
        assert_eq!(manifest.len(), 1);
    }

    #[test]
    fn test_check_updates() {
        let manifest = Manifest::parse(SAMPLE_LOCK).unwrap();

        let mut available = HashMap::new();
        available.insert(
            "chebi".to_string(),
            OntologyVersion::parse("2024-06-01").unwrap(),
        );
        available.insert(
            "go".to_string(),
            OntologyVersion::parse("2024-01-15").unwrap(), // Same version
        );

        let updates = manifest.check_updates(&available);
        assert_eq!(updates.len(), 1);
        assert_eq!(updates[0].0.name, "chebi");
    }

    #[test]
    fn test_ontology_source_parse() {
        assert_eq!(
            OntologySource::parse("semantic-sql"),
            OntologySource::SemanticSql
        );
        assert_eq!(
            OntologySource::parse("https://example.com/onto.owl"),
            OntologySource::Url("https://example.com/onto.owl".to_string())
        );
        assert_eq!(
            OntologySource::parse("bioportal"),
            OntologySource::BioPortal
        );
    }

    #[test]
    fn test_duplicate_entry_error() {
        let bad_lock = r#"
[metadata]
generated = "2025-01-15T10:30:00Z"
schema_version = 1

[[ontology]]
name = "chebi"
version = "1.0.0"

[[ontology]]
name = "chebi"
version = "2.0.0"
"#;
        let result = Manifest::parse(bad_lock);
        assert!(matches!(result, Err(ManifestError::DuplicateEntry(_))));
    }
}
