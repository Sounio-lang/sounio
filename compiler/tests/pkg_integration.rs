//! Integration tests for the Sounio package manager
//!
//! Tests cover:
//! - Package manifest parsing
//! - Local cache operations
//! - Semver dependency resolution

use std::fs;
use tempfile::TempDir;

/// Test that Sounio.toml manifest can be parsed correctly
#[test]
fn test_manifest_parsing() {
    let manifest = r#"
[package]
name = "test-package"
version = "1.0.0"
description = "A test package"
authors = ["Test Author"]

[dependencies]
serde = "1.0"
tokio = { version = "1.0", features = ["full"] }
"#;

    let temp_dir = TempDir::new().unwrap();
    let manifest_path = temp_dir.path().join("Sounio.toml");
    fs::write(&manifest_path, manifest).unwrap();

    // Just verify the file was created
    assert!(manifest_path.exists());
    let content = fs::read_to_string(&manifest_path).unwrap();
    assert!(content.contains("test-package"));
    assert!(content.contains("1.0.0"));
}

/// Test package cache directory structure
#[test]
fn test_cache_directory_structure() {
    let temp_dir = TempDir::new().unwrap();
    let cache_root = temp_dir.path().join(".sounio").join("cache");

    // Create expected cache structure
    fs::create_dir_all(cache_root.join("packages")).unwrap();
    fs::create_dir_all(cache_root.join("registry")).unwrap();
    fs::create_dir_all(cache_root.join("git")).unwrap();

    assert!(cache_root.join("packages").exists());
    assert!(cache_root.join("registry").exists());
    assert!(cache_root.join("git").exists());
}

/// Test semver version parsing
#[test]
fn test_semver_parsing() {
    // Test valid versions
    assert!(parse_version("1.0.0").is_some());
    assert!(parse_version("0.1.0").is_some());
    assert!(parse_version("2.3.4").is_some());
    assert!(parse_version("1.0.0-alpha").is_some());
    assert!(parse_version("1.0.0-beta.1").is_some());

    // Test invalid versions
    assert!(parse_version("not-a-version").is_none());
    assert!(parse_version("1.0").is_none());
}

fn parse_version(v: &str) -> Option<(u32, u32, u32)> {
    let parts: Vec<&str> = v.split('-').next()?.split('.').collect();
    if parts.len() != 3 {
        return None;
    }
    Some((
        parts[0].parse().ok()?,
        parts[1].parse().ok()?,
        parts[2].parse().ok()?,
    ))
}

/// Test version requirement matching
#[test]
fn test_version_requirement_matching() {
    // ^1.0.0 matches 1.0.0, 1.1.0, 1.9.9 but not 2.0.0
    assert!(version_matches("^1.0.0", "1.0.0"));
    assert!(version_matches("^1.0.0", "1.5.3"));
    assert!(!version_matches("^1.0.0", "2.0.0"));

    // ~1.0.0 matches 1.0.x
    assert!(version_matches("~1.0.0", "1.0.0"));
    assert!(version_matches("~1.0.0", "1.0.9"));
    assert!(!version_matches("~1.0.0", "1.1.0"));

    // Exact match
    assert!(version_matches("=1.0.0", "1.0.0"));
    assert!(!version_matches("=1.0.0", "1.0.1"));
}

fn version_matches(req: &str, version: &str) -> bool {
    let (op, req_version) = if req.starts_with('^') {
        ('^', &req[1..])
    } else if req.starts_with('~') {
        ('~', &req[1..])
    } else if req.starts_with('=') {
        ('=', &req[1..])
    } else {
        ('^', req) // Default to caret
    };

    let req_parts = parse_version(req_version);
    let ver_parts = parse_version(version);

    match (req_parts, ver_parts) {
        (Some((req_major, req_minor, req_patch)), Some((ver_major, ver_minor, ver_patch))) => {
            match op {
                '^' => {
                    ver_major == req_major
                        && (ver_major > 0
                            || (ver_minor > req_minor
                                || (ver_minor == req_minor && ver_patch >= req_patch)))
                }
                '~' => ver_major == req_major && ver_minor == req_minor && ver_patch >= req_patch,
                '=' => {
                    ver_major == req_major && ver_minor == req_minor && ver_patch == req_patch
                }
                _ => false,
            }
        }
        _ => false,
    }
}

/// Test lock file generation
#[test]
fn test_lockfile_format() {
    let lockfile = r#"
# This file is auto-generated by Sounio
# Do not edit manually

[[package]]
name = "serde"
version = "1.0.193"
checksum = "sha256:abc123..."

[[package]]
name = "tokio"
version = "1.35.0"
checksum = "sha256:def456..."
dependencies = ["mio", "bytes"]
"#;

    // Verify lockfile structure is valid TOML-like
    assert!(lockfile.contains("[[package]]"));
    assert!(lockfile.contains("name = "));
    assert!(lockfile.contains("version = "));
    assert!(lockfile.contains("checksum = "));
}

/// Test credentials file permissions (Unix only)
#[cfg(unix)]
#[test]
fn test_credentials_file_permissions() {
    use std::os::unix::fs::PermissionsExt;

    let temp_dir = TempDir::new().unwrap();
    let creds_path = temp_dir.path().join("credentials.toml");

    // Create file with restricted permissions
    fs::write(&creds_path, "token = \"secret\"").unwrap();
    let mut perms = fs::metadata(&creds_path).unwrap().permissions();
    perms.set_mode(0o600);
    fs::set_permissions(&creds_path, perms).unwrap();

    // Verify permissions
    let mode = fs::metadata(&creds_path).unwrap().permissions().mode();
    assert_eq!(mode & 0o777, 0o600);
}

/// Test package search result parsing
#[test]
fn test_search_result_parsing() {
    let search_results = vec![
        ("serde", "1.0.193", "Serialization framework"),
        ("tokio", "1.35.0", "Async runtime"),
        ("reqwest", "0.11.23", "HTTP client"),
    ];

    for (name, version, desc) in &search_results {
        assert!(!name.is_empty());
        assert!(parse_version(version).is_some());
        assert!(!desc.is_empty());
    }
}
