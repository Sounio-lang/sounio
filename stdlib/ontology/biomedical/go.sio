// stdlib/ontology/biomedical/go.sio
//
// Gene Ontology (GO) Helpers
//
// Provides utilities for working with Gene Ontology terms,
// including the three main branches: biological process, molecular function,
// and cellular component.

// ============================================================================
// GO CONSTANTS
// ============================================================================

// Namespace ID
pub const NS_GO: i64 = 102

// GO namespaces (branches)
pub const GO_BIOLOGICAL_PROCESS: i64 = 1
pub const GO_MOLECULAR_FUNCTION: i64 = 2
pub const GO_CELLULAR_COMPONENT: i64 = 3

// GO relationship types
pub const GO_REL_IS_A: i64 = 10
pub const GO_REL_PART_OF: i64 = 11
pub const GO_REL_REGULATES: i64 = 12
pub const GO_REL_POSITIVELY_REGULATES: i64 = 13
pub const GO_REL_NEGATIVELY_REGULATES: i64 = 14
pub const GO_REL_HAS_PART: i64 = 15
pub const GO_REL_OCCURS_IN: i64 = 16

// Evidence codes
pub const EV_EXP: i64 = 100    // Inferred from Experiment
pub const EV_IDA: i64 = 101    // Inferred from Direct Assay
pub const EV_IPI: i64 = 102    // Inferred from Physical Interaction
pub const EV_IMP: i64 = 103    // Inferred from Mutant Phenotype
pub const EV_IGI: i64 = 104    // Inferred from Genetic Interaction
pub const EV_IEP: i64 = 105    // Inferred from Expression Pattern
pub const EV_ISS: i64 = 106    // Inferred from Sequence Similarity
pub const EV_ISO: i64 = 107    // Inferred from Sequence Orthology
pub const EV_IEA: i64 = 108    // Inferred from Electronic Annotation
pub const EV_TAS: i64 = 109    // Traceable Author Statement
pub const EV_NAS: i64 = 110    // Non-traceable Author Statement
pub const EV_ND: i64 = 111     // No biological Data available

// ============================================================================
// GO TERM
// ============================================================================

// GO term structure
pub struct GOTerm {
    pub go_id: i64,
    pub namespace: i64,
    pub name_id: i64,
    pub definition_id: i64,
    pub is_obsolete: bool,
    pub replaced_by: i64,
}

pub fn go_term_new(id: i64, namespace: i64) -> GOTerm {
    GOTerm {
        go_id: id,
        namespace: namespace,
        name_id: 0,
        definition_id: 0,
        is_obsolete: false,
        replaced_by: 0,
    }
}

pub fn go_term_is_bp(term: &GOTerm) -> bool {
    term.namespace == GO_BIOLOGICAL_PROCESS
}

pub fn go_term_is_mf(term: &GOTerm) -> bool {
    term.namespace == GO_MOLECULAR_FUNCTION
}

pub fn go_term_is_cc(term: &GOTerm) -> bool {
    term.namespace == GO_CELLULAR_COMPONENT
}

// ============================================================================
// GO ANNOTATION
// ============================================================================

// GO annotation linking gene to term
pub struct GOAnnotation {
    pub gene_id: i64,
    pub go_term_id: i64,
    pub evidence_code: i64,
    pub qualifier: i64,
    pub with_from_id: i64,
}

pub const QUAL_NONE: i64 = 0
pub const QUAL_NOT: i64 = 1
pub const QUAL_CONTRIBUTES_TO: i64 = 2
pub const QUAL_COLOCALIZES_WITH: i64 = 3

pub fn go_annotation_new(gene: i64, term: i64, evidence: i64) -> GOAnnotation {
    GOAnnotation {
        gene_id: gene,
        go_term_id: term,
        evidence_code: evidence,
        qualifier: QUAL_NONE,
        with_from_id: 0,
    }
}

pub fn go_annotation_is_experimental(ann: &GOAnnotation) -> bool {
    ann.evidence_code >= EV_EXP && ann.evidence_code <= EV_IEP
}

pub fn go_annotation_is_electronic(ann: &GOAnnotation) -> bool {
    ann.evidence_code == EV_IEA
}

// ============================================================================
// GO HIERARCHY
// ============================================================================

// GO term in hierarchy
pub struct GOHierarchyEntry {
    pub term_id: i64,
    pub parents: Vec<i64>,
    pub children: Vec<i64>,
    pub depth: i64,
}

pub fn go_hierarchy_entry_new(id: i64) -> GOHierarchyEntry {
    GOHierarchyEntry {
        term_id: id,
        parents: vec![],
        children: vec![],
        depth: 0,
    }
}

// GO hierarchy graph
pub struct GOGraph {
    pub entries: Vec<GOHierarchyEntry>,
}

pub fn go_graph_new() -> GOGraph {
    GOGraph {
        entries: vec![],
    }
}

pub fn go_graph_add(g: &GOGraph, entry: GOHierarchyEntry) {
    g.entries.push(entry)
}

pub fn go_graph_find(g: &GOGraph, term_id: i64) -> i64 {
    let n = g.entries.len()
    for i in 0..n {
        if g.entries[i].term_id == term_id {
            return i as i64
        }
    }
    0 - 1
}

// Check if term1 is ancestor of term2
pub fn go_is_ancestor(g: &GOGraph, ancestor_id: i64, term_id: i64) -> bool {
    let term_idx = go_graph_find(g, term_id)
    if term_idx < 0 {
        return false
    }

    var to_check: Vec<i64> = vec![]
    let n_parents = g.entries[term_idx as usize].parents.len()
    for i in 0..n_parents {
        to_check.push(g.entries[term_idx as usize].parents[i])
    }

    var checked = 0
    while checked < to_check.len() && checked < 1000 {
        let current = to_check[checked]
        if current == ancestor_id {
            return true
        }

        let current_idx = go_graph_find(g, current)
        if current_idx >= 0 {
            let n_p = g.entries[current_idx as usize].parents.len()
            for i in 0..n_p {
                to_check.push(g.entries[current_idx as usize].parents[i])
            }
        }
        checked = checked + 1
    }

    false
}

// ============================================================================
// GO ENRICHMENT
// ============================================================================

// Simple enrichment result
pub struct GOEnrichmentResult {
    pub term_id: i64,
    pub gene_count: i64,
    pub expected_count: f64,
    pub fold_enrichment: f64,
}

pub fn go_enrichment_result_new(term: i64, count: i64, expected: f64) -> GOEnrichmentResult {
    var fold = 0.0
    if expected > 0.0 {
        fold = (count as f64) / expected
    }

    GOEnrichmentResult {
        term_id: term,
        gene_count: count,
        expected_count: expected,
        fold_enrichment: fold,
    }
}

pub fn go_enrichment_is_significant(result: &GOEnrichmentResult, threshold: f64) -> bool {
    result.fold_enrichment >= threshold
}

// ============================================================================
// TESTS
// ============================================================================

fn test_go_term() -> bool {
    let term = go_term_new(6915, GO_BIOLOGICAL_PROCESS)  // apoptotic process
    go_term_is_bp(&term) && !go_term_is_mf(&term)
}

fn test_go_annotation() -> bool {
    let ann = go_annotation_new(1000, 6915, EV_IDA)
    go_annotation_is_experimental(&ann) && !go_annotation_is_electronic(&ann)
}

fn test_go_hierarchy() -> bool {
    var g = go_graph_new()

    // Simple hierarchy: biological_process -> cellular process -> apoptotic process
    var bp = go_hierarchy_entry_new(8150)
    bp.depth = 0
    go_graph_add(&g, bp)

    var cp = go_hierarchy_entry_new(9987)
    cp.parents.push(8150)
    cp.depth = 1
    go_graph_add(&g, cp)

    var ap = go_hierarchy_entry_new(6915)
    ap.parents.push(9987)
    ap.depth = 2
    go_graph_add(&g, ap)

    go_is_ancestor(&g, 8150, 6915)
}

fn test_enrichment() -> bool {
    let result = go_enrichment_result_new(6915, 50, 10.0)
    result.fold_enrichment > 4.0 && go_enrichment_is_significant(&result, 2.0)
}

fn main() -> i32 {
    print("Testing ontology::biomedical::go...\n")

    if !test_go_term() {
        print("FAIL: go_term\n")
        return 1
    }
    print("PASS: go_term\n")

    if !test_go_annotation() {
        print("FAIL: go_annotation\n")
        return 2
    }
    print("PASS: go_annotation\n")

    if !test_go_hierarchy() {
        print("FAIL: go_hierarchy\n")
        return 3
    }
    print("PASS: go_hierarchy\n")

    if !test_enrichment() {
        print("FAIL: enrichment\n")
        return 4
    }
    print("PASS: enrichment\n")

    print("All ontology::biomedical::go tests PASSED\n")
    0
}
