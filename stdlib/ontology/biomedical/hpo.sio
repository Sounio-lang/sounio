// stdlib/ontology/biomedical/hpo.sio
//
// Human Phenotype Ontology (HPO) Helpers
//
// Provides utilities for working with HPO terms for
// phenotype-based disease analysis.

// ============================================================================
// HPO CONSTANTS
// ============================================================================

// Namespace ID
pub const NS_HPO: i64 = 103

// HPO top-level categories
pub const HPO_PHENOTYPIC_ABNORMALITY: i64 = 118
pub const HPO_CLINICAL_MODIFIER: i64 = 12823
pub const HPO_MODE_OF_INHERITANCE: i64 = 34
pub const HPO_MORTALITY_AGING: i64 = 40006
pub const HPO_FREQUENCY: i64 = 40279

// Inheritance modes
pub const INH_AUTOSOMAL_DOMINANT: i64 = 6
pub const INH_AUTOSOMAL_RECESSIVE: i64 = 7
pub const INH_X_LINKED: i64 = 10
pub const INH_X_LINKED_RECESSIVE: i64 = 11
pub const INH_X_LINKED_DOMINANT: i64 = 15
pub const INH_MITOCHONDRIAL: i64 = 17

// Frequency categories
pub const FREQ_VERY_RARE: i64 = 50   // < 1%
pub const FREQ_RARE: i64 = 51        // 1-5%
pub const FREQ_OCCASIONAL: i64 = 52  // 5-29%
pub const FREQ_FREQUENT: i64 = 53    // 30-79%
pub const FREQ_VERY_FREQUENT: i64 = 54  // 80-99%
pub const FREQ_OBLIGATE: i64 = 55    // 100%

// ============================================================================
// HPO TERM
// ============================================================================

// HPO term structure
pub struct HPOTerm {
    pub hpo_id: i64,
    pub name_id: i64,
    pub definition_id: i64,
    pub category: i64,
    pub is_obsolete: bool,
    pub replaced_by: i64,
}

pub fn hpo_term_new(id: i64) -> HPOTerm {
    HPOTerm {
        hpo_id: id,
        name_id: 0,
        definition_id: 0,
        category: HPO_PHENOTYPIC_ABNORMALITY,
        is_obsolete: false,
        replaced_by: 0,
    }
}

pub fn hpo_term_with_category(id: i64, category: i64) -> HPOTerm {
    HPOTerm {
        hpo_id: id,
        name_id: 0,
        definition_id: 0,
        category: category,
        is_obsolete: false,
        replaced_by: 0,
    }
}

pub fn hpo_is_phenotype(term: &HPOTerm) -> bool {
    term.category == HPO_PHENOTYPIC_ABNORMALITY
}

pub fn hpo_is_inheritance(term: &HPOTerm) -> bool {
    term.category == HPO_MODE_OF_INHERITANCE
}

// ============================================================================
// HPO ANNOTATION
// ============================================================================

// HPO annotation linking disease to phenotype
pub struct HPOAnnotation {
    pub disease_id: i64,
    pub hpo_term_id: i64,
    pub frequency: i64,
    pub onset_id: i64,
    pub is_negated: bool,
}

pub fn hpo_annotation_new(disease: i64, term: i64) -> HPOAnnotation {
    HPOAnnotation {
        disease_id: disease,
        hpo_term_id: term,
        frequency: FREQ_FREQUENT,
        onset_id: 0,
        is_negated: false,
    }
}

pub fn hpo_annotation_with_freq(disease: i64, term: i64, freq: i64) -> HPOAnnotation {
    HPOAnnotation {
        disease_id: disease,
        hpo_term_id: term,
        frequency: freq,
        onset_id: 0,
        is_negated: false,
    }
}

pub fn hpo_annotation_is_rare(ann: &HPOAnnotation) -> bool {
    ann.frequency <= FREQ_RARE
}

pub fn hpo_annotation_is_common(ann: &HPOAnnotation) -> bool {
    ann.frequency >= FREQ_FREQUENT
}

// ============================================================================
// HPO HIERARCHY
// ============================================================================

// HPO term in hierarchy
pub struct HPOHierarchyEntry {
    pub term_id: i64,
    pub parents: Vec<i64>,
    pub children: Vec<i64>,
    pub depth: i64,
}

pub fn hpo_hierarchy_entry_new(id: i64) -> HPOHierarchyEntry {
    HPOHierarchyEntry {
        term_id: id,
        parents: vec![],
        children: vec![],
        depth: 0,
    }
}

// HPO hierarchy graph
pub struct HPOGraph {
    pub entries: Vec<HPOHierarchyEntry>,
}

pub fn hpo_graph_new() -> HPOGraph {
    HPOGraph {
        entries: vec![],
    }
}

pub fn hpo_graph_add(g: &HPOGraph, entry: HPOHierarchyEntry) {
    g.entries.push(entry)
}

pub fn hpo_graph_find(g: &HPOGraph, term_id: i64) -> i64 {
    let n = g.entries.len()
    for i in 0..n {
        if g.entries[i].term_id == term_id {
            return i as i64
        }
    }
    0 - 1
}

// Check if term1 is ancestor of term2
pub fn hpo_is_ancestor(g: &HPOGraph, ancestor_id: i64, term_id: i64) -> bool {
    let term_idx = hpo_graph_find(g, term_id)
    if term_idx < 0 {
        return false
    }

    var to_check: Vec<i64> = vec![]
    let n_parents = g.entries[term_idx as usize].parents.len()
    for i in 0..n_parents {
        to_check.push(g.entries[term_idx as usize].parents[i])
    }

    var checked = 0
    while checked < to_check.len() && checked < 1000 {
        let current = to_check[checked]
        if current == ancestor_id {
            return true
        }

        let current_idx = hpo_graph_find(g, current)
        if current_idx >= 0 {
            let n_p = g.entries[current_idx as usize].parents.len()
            for i in 0..n_p {
                to_check.push(g.entries[current_idx as usize].parents[i])
            }
        }
        checked = checked + 1
    }

    false
}

// ============================================================================
// PHENOTYPE SIMILARITY
// ============================================================================

// Compute information content (simplified)
fn term_ic(term_count: i64, total_terms: i64) -> f64 {
    if term_count <= 0 || total_terms <= 0 {
        return 0.0
    }
    let p = (term_count as f64) / (total_terms as f64)
    if p <= 0.0 {
        return 0.0
    }
    0.0 - (p * 2.302585)  // -log(p) approximation using ln(10)
}

// Simple phenotype similarity based on common terms
pub fn hpo_phenotype_similarity(terms1: &Vec<i64>, terms2: &Vec<i64>) -> f64 {
    if terms1.len() == 0 || terms2.len() == 0 {
        return 0.0
    }

    var common = 0
    let n1 = terms1.len()
    let n2 = terms2.len()

    for i in 0..n1 {
        for j in 0..n2 {
            if terms1[i] == terms2[j] {
                common = common + 1
            }
        }
    }

    // Jaccard similarity
    let union_size = n1 + n2 - common
    if union_size == 0 {
        return 0.0
    }
    (common as f64) / (union_size as f64)
}

// ============================================================================
// DISEASE MATCHING
// ============================================================================

// Disease match result
pub struct DiseaseMatch {
    pub disease_id: i64,
    pub score: f64,
    pub matching_terms: i64,
    pub total_terms: i64,
}

pub fn disease_match_new(disease: i64, score: f64, matching: i64, total: i64) -> DiseaseMatch {
    DiseaseMatch {
        disease_id: disease,
        score: score,
        matching_terms: matching,
        total_terms: total,
    }
}

// ============================================================================
// TESTS
// ============================================================================

fn test_hpo_term() -> bool {
    let term = hpo_term_new(1250)  // Arachnodactyly
    hpo_is_phenotype(&term)
}

fn test_hpo_annotation() -> bool {
    let ann = hpo_annotation_with_freq(154700, 1250, FREQ_VERY_FREQUENT)
    hpo_annotation_is_common(&ann) && !hpo_annotation_is_rare(&ann)
}

fn test_hpo_hierarchy() -> bool {
    var g = hpo_graph_new()

    // Simple hierarchy: Phenotypic abnormality -> Limb abnormality -> Long fingers
    var root = hpo_hierarchy_entry_new(118)
    root.depth = 0
    hpo_graph_add(&g, root)

    var limb = hpo_hierarchy_entry_new(40000)
    limb.parents.push(118)
    limb.depth = 1
    hpo_graph_add(&g, limb)

    var finger = hpo_hierarchy_entry_new(1250)
    finger.parents.push(40000)
    finger.depth = 2
    hpo_graph_add(&g, finger)

    hpo_is_ancestor(&g, 118, 1250)
}

fn test_phenotype_similarity() -> bool {
    var terms1: Vec<i64> = vec![]
    terms1.push(1250)
    terms1.push(1166)
    terms1.push(1382)

    var terms2: Vec<i64> = vec![]
    terms2.push(1250)
    terms2.push(1166)
    terms2.push(200)

    let sim = hpo_phenotype_similarity(&terms1, &terms2)
    sim > 0.3 && sim < 0.7  // Should be around 0.5
}

fn main() -> i32 {
    print("Testing ontology::biomedical::hpo...\n")

    if !test_hpo_term() {
        print("FAIL: hpo_term\n")
        return 1
    }
    print("PASS: hpo_term\n")

    if !test_hpo_annotation() {
        print("FAIL: hpo_annotation\n")
        return 2
    }
    print("PASS: hpo_annotation\n")

    if !test_hpo_hierarchy() {
        print("FAIL: hpo_hierarchy\n")
        return 3
    }
    print("PASS: hpo_hierarchy\n")

    if !test_phenotype_similarity() {
        print("FAIL: phenotype_similarity\n")
        return 4
    }
    print("PASS: phenotype_similarity\n")

    print("All ontology::biomedical::hpo tests PASSED\n")
    0
}
