// stdlib/ontology/biomedical/snomed.sio
//
// SNOMED-CT Ontology Helpers
//
// Provides utilities for working with SNOMED Clinical Terms,
// including concept lookup, hierarchy navigation, and semantic similarity.

// ============================================================================
// SNOMED-CT CONSTANTS
// ============================================================================

// SNOMED namespace ID
pub const NS_SNOMED: i64 = 100

// Common relationship type SCTIDs
pub const REL_IS_A: i64 = 116680003
pub const REL_FINDING_SITE: i64 = 363698007
pub const REL_ASSOCIATED_MORPHOLOGY: i64 = 116676008
pub const REL_CAUSATIVE_AGENT: i64 = 246075003
pub const REL_HAS_ACTIVE_INGREDIENT: i64 = 127489000
pub const REL_HAS_DOSE_FORM: i64 = 411116001
pub const REL_METHOD: i64 = 260686004
pub const REL_PROCEDURE_SITE: i64 = 363704007
pub const REL_OCCURRENCE: i64 = 246454002

// Root concepts
pub const CONCEPT_ROOT: i64 = 138875005
pub const CONCEPT_CLINICAL_FINDING: i64 = 404684003
pub const CONCEPT_PROCEDURE: i64 = 71388002
pub const CONCEPT_BODY_STRUCTURE: i64 = 123037004
pub const CONCEPT_ORGANISM: i64 = 410607006
pub const CONCEPT_SUBSTANCE: i64 = 105590001
pub const CONCEPT_PHARMACEUTICAL_PRODUCT: i64 = 373873005
pub const CONCEPT_OBSERVABLE_ENTITY: i64 = 363787002
pub const CONCEPT_EVENT: i64 = 272379006
pub const CONCEPT_QUALIFIER_VALUE: i64 = 362981000

// Semantic tags
pub const TAG_DISORDER: i64 = 1
pub const TAG_FINDING: i64 = 2
pub const TAG_PROCEDURE: i64 = 3
pub const TAG_BODY_STRUCTURE: i64 = 4
pub const TAG_SUBSTANCE: i64 = 5
pub const TAG_PRODUCT: i64 = 6
pub const TAG_ORGANISM: i64 = 7
pub const TAG_OBSERVABLE: i64 = 8

// ============================================================================
// SNOMED CONCEPT ID
// ============================================================================

// SNOMED CT Identifier
pub struct SCTID {
    pub id: i64,
    pub namespace_id: i64,
}

pub fn sctid_new(id: i64) -> SCTID {
    SCTID {
        id: id,
        namespace_id: NS_SNOMED,
    }
}

pub fn sctid_equals(a: &SCTID, b: &SCTID) -> bool {
    a.id == b.id
}

pub fn sctid_clone(s: &SCTID) -> SCTID {
    SCTID {
        id: s.id,
        namespace_id: s.namespace_id,
    }
}

// Check if valid SNOMED CT ID (basic validation)
pub fn sctid_is_valid(id: i64) -> bool {
    // SCTID must be positive and have appropriate length
    id > 0 && id < 10000000000000000
}

// ============================================================================
// SNOMED CONCEPT
// ============================================================================

// SNOMED concept wrapper
pub struct SNOMEDConcept {
    pub sctid: SCTID,
    pub fsn_id: i64,  // Fully Specified Name string ID
    pub preferred_term_id: i64,
    pub semantic_tag: i64,
    pub is_primitive: bool,
    pub is_active: bool,
}

pub fn snomed_concept_new(id: i64) -> SNOMEDConcept {
    SNOMEDConcept {
        sctid: sctid_new(id),
        fsn_id: 0,
        preferred_term_id: 0,
        semantic_tag: 0,
        is_primitive: true,
        is_active: true,
    }
}

pub fn snomed_concept_with_tag(id: i64, tag: i64) -> SNOMEDConcept {
    SNOMEDConcept {
        sctid: sctid_new(id),
        fsn_id: 0,
        preferred_term_id: 0,
        semantic_tag: tag,
        is_primitive: true,
        is_active: true,
    }
}

// ============================================================================
// SNOMED RELATIONSHIP
// ============================================================================

// SNOMED relationship between concepts
pub struct SNOMEDRelationship {
    pub source_id: i64,
    pub type_id: i64,
    pub destination_id: i64,
    pub group: i64,
    pub is_active: bool,
}

pub fn snomed_relationship_new(source: i64, rel_type: i64, dest: i64) -> SNOMEDRelationship {
    SNOMEDRelationship {
        source_id: source,
        type_id: rel_type,
        destination_id: dest,
        group: 0,
        is_active: true,
    }
}

pub fn snomed_relationship_isa(source: i64, dest: i64) -> SNOMEDRelationship {
    snomed_relationship_new(source, REL_IS_A, dest)
}

// Check if this is an IS-A relationship
pub fn is_isa_relationship(rel: &SNOMEDRelationship) -> bool {
    rel.type_id == REL_IS_A
}

// ============================================================================
// SNOMED HIERARCHY
// ============================================================================

// Entry in SNOMED hierarchy
pub struct SNOMEDHierarchyEntry {
    pub concept_id: i64,
    pub parent_ids: Vec<i64>,
    pub child_ids: Vec<i64>,
    pub depth: i64,
}

pub fn snomed_hierarchy_entry_new(id: i64) -> SNOMEDHierarchyEntry {
    SNOMEDHierarchyEntry {
        concept_id: id,
        parent_ids: vec![],
        child_ids: vec![],
        depth: 0,
    }
}

// Simple SNOMED subsumption checker
pub struct SNOMEDHierarchy {
    pub entries: Vec<SNOMEDHierarchyEntry>,
}

pub fn snomed_hierarchy_new() -> SNOMEDHierarchy {
    SNOMEDHierarchy {
        entries: vec![],
    }
}

pub fn snomed_hierarchy_add(h: &SNOMEDHierarchy, entry: SNOMEDHierarchyEntry) {
    h.entries.push(entry)
}

pub fn snomed_hierarchy_find(h: &SNOMEDHierarchy, concept_id: i64) -> i64 {
    let n = h.entries.len()
    for i in 0..n {
        if h.entries[i].concept_id == concept_id {
            return i as i64
        }
    }
    0 - 1
}

// Check if concept A is ancestor of concept B
pub fn snomed_is_ancestor(h: &SNOMEDHierarchy, ancestor_id: i64, descendant_id: i64) -> bool {
    let desc_idx = snomed_hierarchy_find(h, descendant_id)
    if desc_idx < 0 {
        return false
    }

    // Check parents recursively (BFS-style with limited depth)
    var to_check: Vec<i64> = vec![]
    let n_parents = h.entries[desc_idx as usize].parent_ids.len()
    for i in 0..n_parents {
        to_check.push(h.entries[desc_idx as usize].parent_ids[i])
    }

    var checked = 0
    while checked < to_check.len() && checked < 1000 {
        let current = to_check[checked]
        if current == ancestor_id {
            return true
        }

        let current_idx = snomed_hierarchy_find(h, current)
        if current_idx >= 0 {
            let n_p = h.entries[current_idx as usize].parent_ids.len()
            for i in 0..n_p {
                to_check.push(h.entries[current_idx as usize].parent_ids[i])
            }
        }

        checked = checked + 1
    }

    false
}

// ============================================================================
// CLINICAL UTILITIES
// ============================================================================

// Check if concept is a disorder (disease/condition)
pub fn is_disorder(concept: &SNOMEDConcept) -> bool {
    concept.semantic_tag == TAG_DISORDER
}

// Check if concept is a finding
pub fn is_finding(concept: &SNOMEDConcept) -> bool {
    concept.semantic_tag == TAG_FINDING || concept.semantic_tag == TAG_DISORDER
}

// Check if concept is a procedure
pub fn is_procedure(concept: &SNOMEDConcept) -> bool {
    concept.semantic_tag == TAG_PROCEDURE
}

// Check if concept is a body structure
pub fn is_body_structure(concept: &SNOMEDConcept) -> bool {
    concept.semantic_tag == TAG_BODY_STRUCTURE
}

// Check if concept is a substance
pub fn is_substance(concept: &SNOMEDConcept) -> bool {
    concept.semantic_tag == TAG_SUBSTANCE
}

// Check if concept is a product
pub fn is_product(concept: &SNOMEDConcept) -> bool {
    concept.semantic_tag == TAG_PRODUCT
}

// ============================================================================
// SEMANTIC SIMILARITY
// ============================================================================

// Find lowest common ancestor depth
fn find_lca_depth(h: &SNOMEDHierarchy, id1: i64, id2: i64) -> i64 {
    // Get ancestors of both
    var ancestors1: Vec<i64> = vec![]
    var ancestors2: Vec<i64> = vec![]

    // Collect ancestors of id1
    let idx1 = snomed_hierarchy_find(h, id1)
    if idx1 >= 0 {
        var queue: Vec<i64> = vec![]
        queue.push(id1)
        var processed = 0
        while processed < queue.len() && processed < 100 {
            ancestors1.push(queue[processed])
            let curr_idx = snomed_hierarchy_find(h, queue[processed])
            if curr_idx >= 0 {
                let n_p = h.entries[curr_idx as usize].parent_ids.len()
                for i in 0..n_p {
                    queue.push(h.entries[curr_idx as usize].parent_ids[i])
                }
            }
            processed = processed + 1
        }
    }

    // Collect ancestors of id2
    let idx2 = snomed_hierarchy_find(h, id2)
    if idx2 >= 0 {
        var queue: Vec<i64> = vec![]
        queue.push(id2)
        var processed = 0
        while processed < queue.len() && processed < 100 {
            ancestors2.push(queue[processed])
            let curr_idx = snomed_hierarchy_find(h, queue[processed])
            if curr_idx >= 0 {
                let n_p = h.entries[curr_idx as usize].parent_ids.len()
                for i in 0..n_p {
                    queue.push(h.entries[curr_idx as usize].parent_ids[i])
                }
            }
            processed = processed + 1
        }
    }

    // Find common ancestor with maximum depth
    var max_depth: i64 = 0
    let n1 = ancestors1.len()
    let n2 = ancestors2.len()
    for i in 0..n1 {
        for j in 0..n2 {
            if ancestors1[i] == ancestors2[j] {
                let anc_idx = snomed_hierarchy_find(h, ancestors1[i])
                if anc_idx >= 0 {
                    let depth = h.entries[anc_idx as usize].depth
                    if depth > max_depth {
                        max_depth = depth
                    }
                }
            }
        }
    }

    max_depth
}

// Wu-Palmer similarity between two SNOMED concepts
pub fn snomed_similarity(h: &SNOMEDHierarchy, id1: i64, id2: i64) -> f64 {
    if id1 == id2 {
        return 1.0
    }

    let idx1 = snomed_hierarchy_find(h, id1)
    let idx2 = snomed_hierarchy_find(h, id2)

    if idx1 < 0 || idx2 < 0 {
        return 0.0
    }

    let depth1 = h.entries[idx1 as usize].depth as f64
    let depth2 = h.entries[idx2 as usize].depth as f64
    let lca_depth = find_lca_depth(h, id1, id2) as f64

    if depth1 + depth2 <= 0.0 {
        return 0.0
    }

    (2.0 * lca_depth) / (depth1 + depth2)
}

// ============================================================================
// TESTS
// ============================================================================

fn test_sctid() -> bool {
    let id = sctid_new(44054006)  // Type 2 diabetes mellitus
    sctid_is_valid(id.id) && id.namespace_id == NS_SNOMED
}

fn test_snomed_concept() -> bool {
    let concept = snomed_concept_with_tag(44054006, TAG_DISORDER)
    is_disorder(&concept) && concept.is_active
}

fn test_relationship() -> bool {
    let rel = snomed_relationship_isa(44054006, 73211009)  // T2DM is-a Diabetes
    is_isa_relationship(&rel) && rel.destination_id == 73211009
}

fn test_hierarchy() -> bool {
    var h = snomed_hierarchy_new()

    // Create simple hierarchy: DM (73211009) <- T2DM (44054006)
    var dm_entry = snomed_hierarchy_entry_new(73211009)
    dm_entry.depth = 1
    snomed_hierarchy_add(&h, dm_entry)

    var t2dm_entry = snomed_hierarchy_entry_new(44054006)
    t2dm_entry.parent_ids.push(73211009)
    t2dm_entry.depth = 2
    snomed_hierarchy_add(&h, t2dm_entry)

    // Check ancestry
    snomed_is_ancestor(&h, 73211009, 44054006)
}

fn test_similarity() -> bool {
    var h = snomed_hierarchy_new()

    // Create hierarchy
    var root = snomed_hierarchy_entry_new(138875005)
    root.depth = 0
    snomed_hierarchy_add(&h, root)

    var dm = snomed_hierarchy_entry_new(73211009)
    dm.parent_ids.push(138875005)
    dm.depth = 1
    snomed_hierarchy_add(&h, dm)

    var t1dm = snomed_hierarchy_entry_new(46635009)
    t1dm.parent_ids.push(73211009)
    t1dm.depth = 2
    snomed_hierarchy_add(&h, t1dm)

    var t2dm = snomed_hierarchy_entry_new(44054006)
    t2dm.parent_ids.push(73211009)
    t2dm.depth = 2
    snomed_hierarchy_add(&h, t2dm)

    // T1DM and T2DM should have high similarity (both under DM)
    let sim = snomed_similarity(&h, 46635009, 44054006)
    sim > 0.5
}

fn main() -> i32 {
    print("Testing ontology::biomedical::snomed...\n")

    if !test_sctid() {
        print("FAIL: sctid\n")
        return 1
    }
    print("PASS: sctid\n")

    if !test_snomed_concept() {
        print("FAIL: snomed_concept\n")
        return 2
    }
    print("PASS: snomed_concept\n")

    if !test_relationship() {
        print("FAIL: relationship\n")
        return 3
    }
    print("PASS: relationship\n")

    if !test_hierarchy() {
        print("FAIL: hierarchy\n")
        return 4
    }
    print("PASS: hierarchy\n")

    if !test_similarity() {
        print("FAIL: similarity\n")
        return 5
    }
    print("PASS: similarity\n")

    print("All ontology::biomedical::snomed tests PASSED\n")
    0
}
