// stdlib/ontology/model.sio
//
// Ontology Core Data Model
//
// Implements OWL 2 constructs for semantic reasoning, including:
// - IRI (Internationalized Resource Identifier)
// - Ontology container with classes, properties, individuals
// - OWL Class, ObjectProperty, DataProperty
// - Individual instances
// - Axioms (SubClassOf, EquivalentClasses, etc.)

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn abs_f64(x: f64) -> f64 {
    if x < 0.0 { 0.0 - x } else { x }
}

// ============================================================================
// IRI - INTERNATIONALIZED RESOURCE IDENTIFIER
// ============================================================================

// IRI represented as integer ID for efficient storage and comparison
// In a full implementation, this would map to actual IRI strings via a string table
pub struct IRI {
    // Unique identifier for this IRI
    pub id: i64,
    // Namespace ID (index into namespace table)
    pub namespace_id: i64,
    // Local name ID (index into local name table)
    pub local_id: i64,
}

pub fn iri_new(id: i64) -> IRI {
    IRI {
        id: id,
        namespace_id: 0,
        local_id: id,
    }
}

pub fn iri_from_parts(namespace_id: i64, local_id: i64) -> IRI {
    // Combine namespace and local into unique ID
    let combined = namespace_id * 1000000 + local_id
    IRI {
        id: combined,
        namespace_id: namespace_id,
        local_id: local_id,
    }
}

pub fn iri_equals(a: &IRI, b: &IRI) -> bool {
    a.id == b.id
}

pub fn iri_clone(iri: &IRI) -> IRI {
    IRI {
        id: iri.id,
        namespace_id: iri.namespace_id,
        local_id: iri.local_id,
    }
}

// ============================================================================
// LITERAL VALUES
// ============================================================================

// Datatype constants
pub const DT_STRING: i64 = 0
pub const DT_INTEGER: i64 = 1
pub const DT_DOUBLE: i64 = 2
pub const DT_BOOLEAN: i64 = 3
pub const DT_DATETIME: i64 = 4
pub const DT_LANG_STRING: i64 = 5

// Literal value with datatype
pub struct Literal {
    // Value ID (index into literal table)
    pub value_id: i64,
    // Numeric value for numeric types
    pub numeric_value: f64,
    // Datatype (one of DT_* constants)
    pub datatype: i64,
    // Language tag ID (0 if none)
    pub language_id: i64,
}

pub fn literal_string(value_id: i64) -> Literal {
    Literal {
        value_id: value_id,
        numeric_value: 0.0,
        datatype: DT_STRING,
        language_id: 0,
    }
}

pub fn literal_integer(value: i64) -> Literal {
    Literal {
        value_id: value,
        numeric_value: value as f64,
        datatype: DT_INTEGER,
        language_id: 0,
    }
}

pub fn literal_double(value: f64) -> Literal {
    Literal {
        value_id: 0,
        numeric_value: value,
        datatype: DT_DOUBLE,
        language_id: 0,
    }
}

pub fn literal_boolean(value: bool) -> Literal {
    Literal {
        value_id: if value { 1 } else { 0 },
        numeric_value: if value { 1.0 } else { 0.0 },
        datatype: DT_BOOLEAN,
        language_id: 0,
    }
}

pub fn literal_with_lang(value_id: i64, lang_id: i64) -> Literal {
    Literal {
        value_id: value_id,
        numeric_value: 0.0,
        datatype: DT_LANG_STRING,
        language_id: lang_id,
    }
}

// ============================================================================
// ANNOTATION
// ============================================================================

// Annotation on ontology elements
pub struct Annotation {
    // Property IRI
    pub property: IRI,
    // Is the value a literal (true) or IRI (false)?
    pub is_literal: bool,
    // Literal value (if is_literal)
    pub literal_value: Literal,
    // IRI value (if not is_literal)
    pub iri_value: IRI,
}

pub fn annotation_literal(property: IRI, value: Literal) -> Annotation {
    Annotation {
        property: property,
        is_literal: true,
        literal_value: value,
        iri_value: iri_new(0),
    }
}

pub fn annotation_iri(property: IRI, value: IRI) -> Annotation {
    Annotation {
        property: property,
        is_literal: false,
        literal_value: literal_string(0),
        iri_value: value,
    }
}

// ============================================================================
// OWL CLASS
// ============================================================================

// OWL Class (concept)
pub struct OWLClass {
    // Class IRI
    pub iri: IRI,
    // Label ID (index into string table)
    pub label_id: i64,
    // Comment ID (index into string table)
    pub comment_id: i64,
    // Direct superclass IRIs
    pub superclasses: Vec<IRI>,
    // Equivalent class IRIs
    pub equivalent_to: Vec<IRI>,
    // Disjoint class IRIs
    pub disjoint_with: Vec<IRI>,
    // Annotations
    pub annotations: Vec<Annotation>,
    // Deprecated flag
    pub deprecated: bool,
}

pub fn owl_class_new(iri: IRI) -> OWLClass {
    OWLClass {
        iri: iri,
        label_id: 0,
        comment_id: 0,
        superclasses: vec![],
        equivalent_to: vec![],
        disjoint_with: vec![],
        annotations: vec![],
        deprecated: false,
    }
}

pub fn owl_class_with_label(iri: IRI, label_id: i64) -> OWLClass {
    OWLClass {
        iri: iri,
        label_id: label_id,
        comment_id: 0,
        superclasses: vec![],
        equivalent_to: vec![],
        disjoint_with: vec![],
        annotations: vec![],
        deprecated: false,
    }
}

pub fn owl_class_add_superclass(class: &OWLClass, superclass: IRI) {
    class.superclasses.push(superclass)
}

pub fn owl_class_has_superclass(class: &OWLClass, superclass: &IRI) -> bool {
    let n = class.superclasses.len()
    for i in 0..n {
        if iri_equals(&class.superclasses[i], superclass) {
            return true
        }
    }
    false
}

// ============================================================================
// PROPERTY CHARACTERISTICS
// ============================================================================

// OWL 2 property characteristics
pub struct PropertyCharacteristics {
    pub functional: bool,
    pub inverse_functional: bool,
    pub transitive: bool,
    pub symmetric: bool,
    pub asymmetric: bool,
    pub reflexive: bool,
    pub irreflexive: bool,
}

pub fn property_characteristics_default() -> PropertyCharacteristics {
    PropertyCharacteristics {
        functional: false,
        inverse_functional: false,
        transitive: false,
        symmetric: false,
        asymmetric: false,
        reflexive: false,
        irreflexive: false,
    }
}

// ============================================================================
// OBJECT PROPERTY
// ============================================================================

// Object Property (relation between individuals)
pub struct ObjectProperty {
    // Property IRI
    pub iri: IRI,
    // Label ID
    pub label_id: i64,
    // Domain class IRIs
    pub domain: Vec<IRI>,
    // Range class IRIs
    pub range: Vec<IRI>,
    // Super property IRIs
    pub super_properties: Vec<IRI>,
    // Inverse property IRI (id = 0 if none)
    pub inverse_of: IRI,
    pub has_inverse: bool,
    // Property characteristics
    pub characteristics: PropertyCharacteristics,
}

pub fn object_property_new(iri: IRI) -> ObjectProperty {
    ObjectProperty {
        iri: iri,
        label_id: 0,
        domain: vec![],
        range: vec![],
        super_properties: vec![],
        inverse_of: iri_new(0),
        has_inverse: false,
        characteristics: property_characteristics_default(),
    }
}

// ============================================================================
// DATA PROPERTY
// ============================================================================

// Data Property (attribute with literal value)
pub struct DataProperty {
    // Property IRI
    pub iri: IRI,
    // Label ID
    pub label_id: i64,
    // Domain class IRIs
    pub domain: Vec<IRI>,
    // Range datatype (one of DT_* constants)
    pub range_datatype: i64,
    // Super property IRIs
    pub super_properties: Vec<IRI>,
    // Functional property
    pub functional: bool,
}

pub fn data_property_new(iri: IRI) -> DataProperty {
    DataProperty {
        iri: iri,
        label_id: 0,
        domain: vec![],
        range_datatype: DT_STRING,
        super_properties: vec![],
        functional: false,
    }
}

// ============================================================================
// INDIVIDUAL
// ============================================================================

// Object property assertion on individual
pub struct ObjectPropertyAssertion {
    pub property: IRI,
    pub value: IRI,
}

// Data property assertion on individual
pub struct DataPropertyAssertion {
    pub property: IRI,
    pub value: Literal,
}

// Named Individual (instance)
pub struct Individual {
    // Individual IRI
    pub iri: IRI,
    // Label ID
    pub label_id: i64,
    // Type class IRIs
    pub types: Vec<IRI>,
    // Object property assertions
    pub object_props: Vec<ObjectPropertyAssertion>,
    // Data property assertions
    pub data_props: Vec<DataPropertyAssertion>,
    // Same as IRIs
    pub same_as: Vec<IRI>,
    // Different from IRIs
    pub different_from: Vec<IRI>,
}

pub fn individual_new(iri: IRI) -> Individual {
    Individual {
        iri: iri,
        label_id: 0,
        types: vec![],
        object_props: vec![],
        data_props: vec![],
        same_as: vec![],
        different_from: vec![],
    }
}

pub fn individual_add_type(ind: &Individual, type_iri: IRI) {
    ind.types.push(type_iri)
}

pub fn individual_has_type(ind: &Individual, type_iri: &IRI) -> bool {
    let n = ind.types.len()
    for i in 0..n {
        if iri_equals(&ind.types[i], type_iri) {
            return true
        }
    }
    false
}

pub fn individual_add_object_prop(ind: &Individual, prop: IRI, value: IRI) {
    ind.object_props.push(ObjectPropertyAssertion {
        property: prop,
        value: value,
    })
}

pub fn individual_add_data_prop(ind: &Individual, prop: IRI, value: Literal) {
    ind.data_props.push(DataPropertyAssertion {
        property: prop,
        value: value,
    })
}

// ============================================================================
// AXIOM TYPES
// ============================================================================

// Axiom type identifier constants
pub const AXIOM_SUBCLASS_OF: i64 = 0
pub const AXIOM_EQUIVALENT_CLASSES: i64 = 1
pub const AXIOM_DISJOINT_CLASSES: i64 = 2
pub const AXIOM_CLASS_ASSERTION: i64 = 3
pub const AXIOM_OBJECT_PROPERTY_ASSERTION: i64 = 4
pub const AXIOM_DATA_PROPERTY_ASSERTION: i64 = 5
pub const AXIOM_SUB_OBJECT_PROPERTY_OF: i64 = 6
pub const AXIOM_OBJECT_PROPERTY_DOMAIN: i64 = 7
pub const AXIOM_OBJECT_PROPERTY_RANGE: i64 = 8
pub const AXIOM_TRANSITIVE_PROPERTY: i64 = 9
pub const AXIOM_SYMMETRIC_PROPERTY: i64 = 10
pub const AXIOM_FUNCTIONAL_PROPERTY: i64 = 11
pub const AXIOM_SAME_INDIVIDUAL: i64 = 12
pub const AXIOM_DIFFERENT_INDIVIDUALS: i64 = 13
pub const AXIOM_ANNOTATION_ASSERTION: i64 = 14

// Generic axiom structure
pub struct Axiom {
    // Axiom type (one of AXIOM_* constants)
    pub axiom_type: i64,
    // First IRI argument (subject/sub/class)
    pub iri1: IRI,
    // Second IRI argument (object/sup/property)
    pub iri2: IRI,
    pub has_iri2: bool,
    // Third IRI argument
    pub iri3: IRI,
    pub has_iri3: bool,
    // Literal value
    pub literal: Literal,
    pub has_literal: bool,
    // Additional IRI list (for multi-arity axioms)
    pub iri_list: Vec<IRI>,
}

pub fn axiom_subclass_of(sub: IRI, sup: IRI) -> Axiom {
    Axiom {
        axiom_type: AXIOM_SUBCLASS_OF,
        iri1: sub,
        iri2: sup,
        has_iri2: true,
        iri3: iri_new(0),
        has_iri3: false,
        literal: literal_string(0),
        has_literal: false,
        iri_list: vec![],
    }
}

pub fn axiom_equivalent_classes(class1: IRI, class2: IRI) -> Axiom {
    var list: Vec<IRI> = vec![]
    list.push(iri_clone(&class1))
    list.push(iri_clone(&class2))
    Axiom {
        axiom_type: AXIOM_EQUIVALENT_CLASSES,
        iri1: class1,
        iri2: class2,
        has_iri2: true,
        iri3: iri_new(0),
        has_iri3: false,
        literal: literal_string(0),
        has_literal: false,
        iri_list: list,
    }
}

pub fn axiom_disjoint_classes(class1: IRI, class2: IRI) -> Axiom {
    Axiom {
        axiom_type: AXIOM_DISJOINT_CLASSES,
        iri1: class1,
        iri2: class2,
        has_iri2: true,
        iri3: iri_new(0),
        has_iri3: false,
        literal: literal_string(0),
        has_literal: false,
        iri_list: vec![],
    }
}

pub fn axiom_class_assertion(individual: IRI, class: IRI) -> Axiom {
    Axiom {
        axiom_type: AXIOM_CLASS_ASSERTION,
        iri1: individual,
        iri2: class,
        has_iri2: true,
        iri3: iri_new(0),
        has_iri3: false,
        literal: literal_string(0),
        has_literal: false,
        iri_list: vec![],
    }
}

pub fn axiom_object_property_assertion(subject: IRI, property: IRI, object: IRI) -> Axiom {
    Axiom {
        axiom_type: AXIOM_OBJECT_PROPERTY_ASSERTION,
        iri1: subject,
        iri2: property,
        has_iri2: true,
        iri3: object,
        has_iri3: true,
        literal: literal_string(0),
        has_literal: false,
        iri_list: vec![],
    }
}

pub fn axiom_data_property_assertion(subject: IRI, property: IRI, value: Literal) -> Axiom {
    Axiom {
        axiom_type: AXIOM_DATA_PROPERTY_ASSERTION,
        iri1: subject,
        iri2: property,
        has_iri2: true,
        iri3: iri_new(0),
        has_iri3: false,
        literal: value,
        has_literal: true,
        iri_list: vec![],
    }
}

pub fn axiom_transitive_property(property: IRI) -> Axiom {
    Axiom {
        axiom_type: AXIOM_TRANSITIVE_PROPERTY,
        iri1: property,
        iri2: iri_new(0),
        has_iri2: false,
        iri3: iri_new(0),
        has_iri3: false,
        literal: literal_string(0),
        has_literal: false,
        iri_list: vec![],
    }
}

// ============================================================================
// ONTOLOGY CONTAINER
// ============================================================================

// Ontology container with all elements
pub struct Ontology {
    // Ontology IRI
    pub iri: IRI,
    // Version IRI
    pub version_iri: IRI,
    pub has_version: bool,
    // Imported ontology IRIs
    pub imports: Vec<IRI>,
    // Classes (concepts)
    pub classes: Vec<OWLClass>,
    // Object properties
    pub object_properties: Vec<ObjectProperty>,
    // Data properties
    pub data_properties: Vec<DataProperty>,
    // Named individuals
    pub individuals: Vec<Individual>,
    // All axioms
    pub axioms: Vec<Axiom>,
}

pub fn ontology_new(iri: IRI) -> Ontology {
    Ontology {
        iri: iri,
        version_iri: iri_new(0),
        has_version: false,
        imports: vec![],
        classes: vec![],
        object_properties: vec![],
        data_properties: vec![],
        individuals: vec![],
        axioms: vec![],
    }
}

// Get class by IRI
pub fn ontology_get_class_index(ont: &Ontology, iri: &IRI) -> i64 {
    let n = ont.classes.len()
    for i in 0..n {
        if iri_equals(&ont.classes[i].iri, iri) {
            return i as i64
        }
    }
    0 - 1
}

// Add class to ontology
pub fn ontology_add_class(ont: &Ontology, class: OWLClass) {
    ont.classes.push(class)
}

// Get individual index by IRI
pub fn ontology_get_individual_index(ont: &Ontology, iri: &IRI) -> i64 {
    let n = ont.individuals.len()
    for i in 0..n {
        if iri_equals(&ont.individuals[i].iri, iri) {
            return i as i64
        }
    }
    0 - 1
}

// Add individual to ontology
pub fn ontology_add_individual(ont: &Ontology, ind: Individual) {
    ont.individuals.push(ind)
}

// Add axiom to ontology and update affected structures
pub fn ontology_add_axiom(ont: &Ontology, axiom: Axiom) {
    // Process axiom to update related structures
    if axiom.axiom_type == AXIOM_SUBCLASS_OF {
        if axiom.has_iri2 {
            let sub_idx = ontology_get_class_index(ont, &axiom.iri1)
            if sub_idx >= 0 {
                ont.classes[sub_idx as usize].superclasses.push(iri_clone(&axiom.iri2))
            }
        }
    } else if axiom.axiom_type == AXIOM_CLASS_ASSERTION {
        if axiom.has_iri2 {
            let ind_idx = ontology_get_individual_index(ont, &axiom.iri1)
            if ind_idx >= 0 {
                ont.individuals[ind_idx as usize].types.push(iri_clone(&axiom.iri2))
            }
        }
    }

    ont.axioms.push(axiom)
}

// Get direct subclasses of a class
pub fn ontology_direct_subclasses(ont: &Ontology, class_iri: &IRI) -> Vec<i64> {
    var result: Vec<i64> = vec![]
    let n_classes = ont.classes.len()
    for i in 0..n_classes {
        let n_sups = ont.classes[i].superclasses.len()
        for j in 0..n_sups {
            if iri_equals(&ont.classes[i].superclasses[j], class_iri) {
                result.push(i as i64)
                break
            }
        }
    }
    result
}

// Get instances of a class (returns indices)
pub fn ontology_instances_of(ont: &Ontology, class_iri: &IRI) -> Vec<i64> {
    var result: Vec<i64> = vec![]
    let n_inds = ont.individuals.len()
    for i in 0..n_inds {
        let n_types = ont.individuals[i].types.len()
        for j in 0..n_types {
            if iri_equals(&ont.individuals[i].types[j], class_iri) {
                result.push(i as i64)
                break
            }
        }
    }
    result
}

// Count total axioms
pub fn ontology_axiom_count(ont: &Ontology) -> usize {
    ont.axioms.len()
}

// Count classes
pub fn ontology_class_count(ont: &Ontology) -> usize {
    ont.classes.len()
}

// Count individuals
pub fn ontology_individual_count(ont: &Ontology) -> usize {
    ont.individuals.len()
}

// ============================================================================
// ONTOLOGY STATISTICS
// ============================================================================

// Statistics about an ontology
pub struct OntologyStats {
    pub class_count: usize,
    pub object_property_count: usize,
    pub data_property_count: usize,
    pub individual_count: usize,
    pub axiom_count: usize,
}

pub fn ontology_compute_stats(ont: &Ontology) -> OntologyStats {
    OntologyStats {
        class_count: ont.classes.len(),
        object_property_count: ont.object_properties.len(),
        data_property_count: ont.data_properties.len(),
        individual_count: ont.individuals.len(),
        axiom_count: ont.axioms.len(),
    }
}

// ============================================================================
// TESTS
// ============================================================================

fn test_iri_creation() -> bool {
    let iri = iri_new(123)
    iri.id == 123
}

fn test_iri_equals() -> bool {
    let iri1 = iri_new(100)
    let iri2 = iri_new(100)
    let iri3 = iri_new(200)
    iri_equals(&iri1, &iri2) && !iri_equals(&iri1, &iri3)
}

fn test_owl_class_creation() -> bool {
    let iri = iri_new(1)
    let class = owl_class_with_label(iri, 10)
    class.label_id == 10 && class.superclasses.len() == 0
}

fn test_individual_types() -> bool {
    let person_iri = iri_new(1)
    let john_iri = iri_new(100)

    var john = individual_new(john_iri)
    individual_add_type(&john, person_iri)

    let person_check = iri_new(1)
    individual_has_type(&john, &person_check)
}

fn test_ontology_creation() -> bool {
    let ont_iri = iri_new(0)
    var ont = ontology_new(ont_iri)

    // Add a class
    let person_iri = iri_new(1)
    let person_class = owl_class_with_label(person_iri, 10)
    ontology_add_class(&ont, person_class)

    // Add a subclass
    let student_iri = iri_new(2)
    var student_class = owl_class_with_label(student_iri, 20)
    let parent_iri = iri_new(1)
    student_class.superclasses.push(parent_iri)
    ontology_add_class(&ont, student_class)

    ontology_class_count(&ont) == 2
}

fn test_axiom_subclass() -> bool {
    let sub_iri = iri_new(2)
    let sup_iri = iri_new(1)

    let axiom = axiom_subclass_of(sub_iri, sup_iri)
    axiom.axiom_type == AXIOM_SUBCLASS_OF && axiom.has_iri2
}

fn test_literal_types() -> bool {
    let lit_int = literal_integer(42)
    let lit_dbl = literal_double(3.14)
    let lit_bool = literal_boolean(true)

    lit_int.datatype == DT_INTEGER &&
        lit_dbl.datatype == DT_DOUBLE &&
        lit_bool.datatype == DT_BOOLEAN
}

fn main() -> i32 {
    print("Testing ontology::model...\n")

    if !test_iri_creation() {
        print("FAIL: iri_creation\n")
        return 1
    }
    print("PASS: iri_creation\n")

    if !test_iri_equals() {
        print("FAIL: iri_equals\n")
        return 2
    }
    print("PASS: iri_equals\n")

    if !test_owl_class_creation() {
        print("FAIL: owl_class_creation\n")
        return 3
    }
    print("PASS: owl_class_creation\n")

    if !test_individual_types() {
        print("FAIL: individual_types\n")
        return 4
    }
    print("PASS: individual_types\n")

    if !test_ontology_creation() {
        print("FAIL: ontology_creation\n")
        return 5
    }
    print("PASS: ontology_creation\n")

    if !test_axiom_subclass() {
        print("FAIL: axiom_subclass\n")
        return 6
    }
    print("PASS: axiom_subclass\n")

    if !test_literal_types() {
        print("FAIL: literal_types\n")
        return 7
    }
    print("PASS: literal_types\n")

    print("All ontology::model tests PASSED\n")
    0
}
