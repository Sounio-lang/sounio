//! Mocking Framework for Sounio Testing
//!
//! Provides infrastructure for creating mock objects and verifying interactions.
//!
//! # Basic Usage
//!
//! ```d
//! use test::mock::*
//!
//! trait Database {
//!     fn get(key: string) -> Option<string>
//!     fn set(key: string, value: string) -> bool
//! }
//!
//! #[test]
//! fn test_with_mock() {
//!     let mock = Mock::<Database>::new()
//!
//!     mock.expect("get")
//!         .with_args("key1")
//!         .returns(Some("value1"))
//!
//!     let result = mock.get("key1")
//!     assert_eq(result, Some("value1"))
//!
//!     mock.verify()
//! }
//! ```

module test::mock

use test::assert::*

// ==================== Core Mock Types ====================

/// Represents a single expected call
pub struct Expectation {
    /// Method name
    method: string,
    /// Expected arguments (as debug strings for comparison)
    expected_args: Vec<string>,
    /// Return value (stored as Any)
    return_value: Option<Any>,
    /// Number of times this should be called (None = any number)
    call_count: Option<usize>,
    /// Actual call count
    actual_calls: usize,
    /// Whether argument matching is exact or partial
    match_mode: ArgMatchMode,
    /// Callback to execute when called
    callback: Option<Fn(Vec<Any>) -> Any>,
    /// Whether this expectation was used
    was_called: bool,
}

/// How to match arguments
pub enum ArgMatchMode {
    /// Exact match required
    Exact,
    /// Any arguments accepted
    Any,
    /// Custom matcher
    Custom(Fn(&[Any]) -> bool),
}

impl Expectation {
    /// Create a new expectation for a method
    pub fn new(method: string) -> Self {
        Expectation {
            method,
            expected_args: Vec::new(),
            return_value: None,
            call_count: None,
            actual_calls: 0,
            match_mode: ArgMatchMode::Any,
            callback: None,
            was_called: false,
        }
    }

    /// Set expected arguments
    pub fn with_args<A: Debug>(mut self, args: A...) -> Self {
        self.expected_args = args.map(|a| debug(a)).collect()
        self.match_mode = ArgMatchMode::Exact
        self
    }

    /// Accept any arguments
    pub fn with_any_args(mut self) -> Self {
        self.match_mode = ArgMatchMode::Any
        self
    }

    /// Set return value
    pub fn returns<R>(mut self, value: R) -> Self {
        self.return_value = Some(Any::new(value))
        self
    }

    /// Set callback to execute
    pub fn calls<F: Fn(Vec<Any>) -> Any>(mut self, callback: F) -> Self {
        self.callback = Some(callback)
        self
    }

    /// Expect to be called exactly n times
    pub fn times(mut self, n: usize) -> Self {
        self.call_count = Some(n)
        self
    }

    /// Expect to be called at least once
    pub fn at_least_once(mut self) -> Self {
        self.call_count = None  // Will check was_called
        self
    }

    /// Expect never to be called
    pub fn never(mut self) -> Self {
        self.call_count = Some(0)
        self
    }

    /// Record a call and return the configured value
    fn call(&mut self, args: &[Any]) -> Option<Any> {
        self.actual_calls += 1
        self.was_called = true

        if let Some(cb) = &self.callback {
            return Some(cb(args.to_vec()))
        }

        self.return_value.clone()
    }

    /// Check if arguments match
    fn args_match(&self, args: &[Any]) -> bool {
        match &self.match_mode {
            ArgMatchMode::Any => true,
            ArgMatchMode::Exact => {
                if args.len() != self.expected_args.len() {
                    return false
                }
                args.iter()
                    .zip(self.expected_args.iter())
                    .all(|(a, e)| a.debug_string() == *e)
            }
            ArgMatchMode::Custom(matcher) => matcher(args),
        }
    }

    /// Verify this expectation was satisfied
    fn verify(&self) -> Result<(), string> {
        if let Some(expected_count) = self.call_count {
            if self.actual_calls != expected_count {
                return Err(format!(
                    "Method '{}' expected {} calls, got {}",
                    self.method, expected_count, self.actual_calls
                ))
            }
        }
        Ok(())
    }
}

// ==================== Mock Object ====================

/// A mock object that records calls and returns configured values
pub struct Mock<T> {
    /// Type being mocked (for error messages)
    type_name: string,
    /// Configured expectations
    expectations: Vec<Expectation>,
    /// Recorded calls
    calls: Vec<CallRecord>,
    /// Whether to fail on unexpected calls
    strict: bool,
    /// Default return values by method
    defaults: Map<string, Any>,
}

/// Record of a method call
pub struct CallRecord {
    pub method: string,
    pub args: Vec<string>,
    pub timestamp: u64,
}

impl<T> Mock<T> {
    /// Create a new mock
    pub fn new() -> Self {
        Mock {
            type_name: type_name::<T>(),
            expectations: Vec::new(),
            calls: Vec::new(),
            strict: false,
            defaults: Map::new(),
        }
    }

    /// Create a strict mock (fails on unexpected calls)
    pub fn strict() -> Self {
        Mock {
            type_name: type_name::<T>(),
            expectations: Vec::new(),
            calls: Vec::new(),
            strict: true,
            defaults: Map::new(),
        }
    }

    /// Set up an expectation for a method
    pub fn expect(&mut self, method: &str) -> &mut Expectation {
        let expectation = Expectation::new(method.to_string())
        self.expectations.push(expectation)
        self.expectations.last_mut().unwrap()
    }

    /// Set a default return value for a method
    pub fn set_default<R>(&mut self, method: &str, value: R) {
        self.defaults.insert(method.to_string(), Any::new(value))
    }

    /// Call a method on the mock
    pub fn call<R>(&mut self, method: &str, args: &[Any]) -> Option<R> {
        // Record the call
        self.calls.push(CallRecord {
            method: method.to_string(),
            args: args.iter().map(|a| a.debug_string()).collect(),
            timestamp: current_time_millis(),
        })

        // Find matching expectation
        for exp in &mut self.expectations {
            if exp.method == method && exp.args_match(args) {
                if let Some(result) = exp.call(args) {
                    return result.downcast::<R>()
                }
            }
        }

        // Check for default
        if let Some(default) = self.defaults.get(method) {
            return default.clone().downcast::<R>()
        }

        // Strict mode fails on unexpected calls
        if self.strict {
            panic("Unexpected call to method '" + method + "' on mock " + self.type_name)
        }

        None
    }

    /// Verify all expectations were satisfied
    pub fn verify(&self) with Panic {
        let mut errors: Vec<string> = Vec::new()

        for exp in &self.expectations {
            if let Err(e) = exp.verify() {
                errors.push(e)
            }
        }

        if !errors.is_empty() {
            panic("Mock verification failed for " + self.type_name + ":\n  " + errors.join("\n  "))
        }
    }

    /// Get all recorded calls
    pub fn get_calls(&self) -> &[CallRecord] {
        &self.calls
    }

    /// Get calls to a specific method
    pub fn get_calls_to(&self, method: &str) -> Vec<&CallRecord> {
        self.calls.iter().filter(|c| c.method == method).collect()
    }

    /// Check if a method was called
    pub fn was_called(&self, method: &str) -> bool {
        self.calls.iter().any(|c| c.method == method)
    }

    /// Check how many times a method was called
    pub fn call_count(&self, method: &str) -> usize {
        self.calls.iter().filter(|c| c.method == method).count()
    }

    /// Clear all recorded calls (keep expectations)
    pub fn clear_calls(&mut self) {
        self.calls.clear()
    }

    /// Reset the mock (clear calls and expectations)
    pub fn reset(&mut self) {
        self.calls.clear()
        self.expectations.clear()
        self.defaults.clear()
    }
}

// ==================== Spy ====================

/// A spy wraps a real object and records calls while delegating to it
pub struct Spy<T> {
    /// The wrapped object
    inner: T,
    /// Recorded calls
    calls: Vec<CallRecord>,
    /// Method overrides
    overrides: Map<string, Fn(Vec<Any>) -> Any>,
}

impl<T> Spy<T> {
    /// Create a spy wrapping an object
    pub fn new(inner: T) -> Self {
        Spy {
            inner,
            calls: Vec::new(),
            overrides: Map::new(),
        }
    }

    /// Get reference to the wrapped object
    pub fn inner(&self) -> &T {
        &self.inner
    }

    /// Get mutable reference to the wrapped object
    pub fn inner_mut(&mut self) -> &mut T {
        &mut self.inner
    }

    /// Override a method with a custom implementation
    pub fn when<F: Fn(Vec<Any>) -> Any>(&mut self, method: &str, implementation: F) {
        self.overrides.insert(method.to_string(), implementation)
    }

    /// Record a call
    pub fn record_call(&mut self, method: &str, args: &[Any]) {
        self.calls.push(CallRecord {
            method: method.to_string(),
            args: args.iter().map(|a| a.debug_string()).collect(),
            timestamp: current_time_millis(),
        })
    }

    /// Check if method is overridden
    pub fn is_overridden(&self, method: &str) -> bool {
        self.overrides.contains_key(method)
    }

    /// Call an override if it exists
    pub fn call_override<R>(&self, method: &str, args: &[Any]) -> Option<R> {
        self.overrides.get(method).map(|f| {
            let result = f(args.to_vec())
            result.downcast::<R>().unwrap()
        })
    }

    /// Get all recorded calls
    pub fn get_calls(&self) -> &[CallRecord] {
        &self.calls
    }

    /// Verify a method was called with specific arguments
    pub fn verify_called(&self, method: &str, args: &[Any]) with Panic {
        let matching = self.calls.iter().any(|c| {
            c.method == method &&
            c.args.len() == args.len() &&
            c.args.iter().zip(args.iter()).all(|(a, b)| a == &b.debug_string())
        })

        if !matching {
            panic("Expected call to '" + method + "' with args " + debug(args) + " not found")
        }
    }
}

// ==================== Argument Matchers ====================

/// Matches any value of a type
pub fn any<T>() -> ArgMatcher<T> {
    ArgMatcher::Any
}

/// Matches a specific value
pub fn eq<T: Eq>(value: T) -> ArgMatcher<T> {
    ArgMatcher::Eq(value)
}

/// Matches values satisfying a predicate
pub fn matching<T, F: Fn(&T) -> bool>(predicate: F) -> ArgMatcher<T> {
    ArgMatcher::Predicate(predicate)
}

/// Matches null/none
pub fn is_none<T>() -> ArgMatcher<Option<T>> {
    ArgMatcher::IsNone
}

/// Matches some value
pub fn is_some<T>() -> ArgMatcher<Option<T>> {
    ArgMatcher::IsSome
}

/// Argument matcher enum
pub enum ArgMatcher<T> {
    Any,
    Eq(T),
    Predicate(Fn(&T) -> bool),
    IsNone,
    IsSome,
}

impl<T: Eq> ArgMatcher<T> {
    pub fn matches(&self, value: &T) -> bool {
        match self {
            ArgMatcher::Any => true,
            ArgMatcher::Eq(expected) => value == expected,
            ArgMatcher::Predicate(f) => f(value),
            _ => false,
        }
    }
}

impl<T> ArgMatcher<Option<T>> {
    pub fn matches(&self, value: &Option<T>) -> bool {
        match self {
            ArgMatcher::Any => true,
            ArgMatcher::IsNone => value.is_none(),
            ArgMatcher::IsSome => value.is_some(),
            ArgMatcher::Predicate(f) => f(value),
            _ => false,
        }
    }
}

// ==================== Verification Helpers ====================

/// Verify that calls happened in a specific order
pub fn verify_order(mock: &Mock<impl Sized>, methods: &[&str]) with Panic {
    let actual_methods: Vec<&str> = mock.calls.iter().map(|c| c.method.as_str()).collect()

    let mut expected_idx = 0
    for actual in actual_methods {
        if expected_idx < methods.len() && actual == methods[expected_idx] {
            expected_idx += 1
        }
    }

    if expected_idx != methods.len() {
        panic("Methods not called in expected order.\n  Expected: " + debug(methods) + "\n  Actual:   " + debug(actual_methods))
    }
}

/// Verify no more interactions after verification
pub fn verify_no_more_interactions(mock: &Mock<impl Sized>) with Panic {
    let unverified: Vec<_> = mock.expectations.iter()
        .filter(|e| !e.was_called && e.call_count != Some(0))
        .collect()

    if !unverified.is_empty() {
        let methods: Vec<_> = unverified.iter().map(|e| &e.method).collect()
        panic("Unverified interactions: " + debug(methods))
    }
}

// ==================== Helper Functions ====================

fn debug<T: Debug>(value: T) -> string {
    value.debug_string()
}

fn format(template: &str, args: &[&str]) -> string {
    let mut result = template.to_string()
    for (i, arg) in args.iter().enumerate() {
        result = result.replace(&("{" + to_string(i) + "}"), arg)
    }
    result
}

fn to_string<T: ToString>(value: T) -> string {
    value.to_string()
}

fn type_name<T>() -> string {
    // Would return actual type name in real implementation
    "Mock"
}

fn current_time_millis() -> u64 {
    // Would return actual timestamp
    0
}
