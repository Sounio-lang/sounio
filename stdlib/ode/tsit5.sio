// tsit5.d - Tsitouras 5(4) Adaptive ODE Solver for Sounio
//
// Native implementation matching Julia's DifferentialEquations.jl Tsit5 algorithm.
// 5th-order embedded Runge-Kutta method with 4th-order error estimation.
//
// Reference: Ch. Tsitouras (2011), "Runge-Kutta pairs of order 5(4)"
//            Computers & Mathematics with Applications 62(2): 770-775

// ============================================================================
// BUTCHER TABLEAU COEFFICIENTS (Tsitouras 5(4))
// ============================================================================

// Stage times (c_i)
fn c2() -> f64 { return 0.161 }
fn c3() -> f64 { return 0.327 }
fn c4() -> f64 { return 0.9 }
fn c5() -> f64 { return 0.9800255409045097 }
fn c6() -> f64 { return 1.0 }
fn c7() -> f64 { return 1.0 }

// Row 2 coefficients
fn a21() -> f64 { return 0.161 }

// Row 3 coefficients
fn a31() -> f64 { return 0.0 - 0.008480655492356989 }
fn a32() -> f64 { return 0.335480655492357 }

// Row 4 coefficients
fn a41() -> f64 { return 2.8971530571054935 }
fn a42() -> f64 { return 0.0 - 6.359448489975075 }
fn a43() -> f64 { return 4.3622954328695815 }

// Row 5 coefficients
fn a51() -> f64 { return 5.325864828439257 }
fn a52() -> f64 { return 0.0 - 11.748883564062828 }
fn a53() -> f64 { return 7.4955393428898365 }
fn a54() -> f64 { return 0.0 - 0.09249506636175525 }

// Row 6 coefficients
fn a61() -> f64 { return 5.86145544294642 }
fn a62() -> f64 { return 0.0 - 12.92096931784711 }
fn a63() -> f64 { return 8.159367898576159 }
fn a64() -> f64 { return 0.0 - 0.071584973281401 }
fn a65() -> f64 { return 0.0 - 0.028269050394068383 }

// Row 7 coefficients (same as b weights for FSAL)
fn a71() -> f64 { return 0.09646076681806523 }
fn a72() -> f64 { return 0.01 }
fn a73() -> f64 { return 0.4798896504144996 }
fn a74() -> f64 { return 1.379008574103742 }
fn a75() -> f64 { return 0.0 - 3.290069515436081 }
fn a76() -> f64 { return 2.324710524099774 }

// 5th order weights (b_i)
fn b1() -> f64 { return 0.09646076681806523 }
fn b2() -> f64 { return 0.01 }
fn b3() -> f64 { return 0.4798896504144996 }
fn b4() -> f64 { return 1.379008574103742 }
fn b5() -> f64 { return 0.0 - 3.290069515436081 }
fn b6() -> f64 { return 2.324710524099774 }
fn b7() -> f64 { return 0.0 }

// Error coefficients (negative of Julia's btilde)
// These should sum to approximately 0
fn e1() -> f64 { return 0.00178001105222577714 }
fn e2() -> f64 { return 0.0008164344596567469 }
fn e3() -> f64 { return 0.0 - 0.007880878010261995 }
fn e4() -> f64 { return 0.1447110071732629 }
fn e5() -> f64 { return 0.0 - 0.5823571654525552 }
fn e6() -> f64 { return 0.45808210592918697 }
fn e7() -> f64 { return 0.0 - 0.01515151515151515 }

// ============================================================================
// SOLVER CONFIGURATION
// ============================================================================

struct ODEConfig {
    rtol: f64,
    atol: f64,
    dt_init: f64,
    dt_min: f64,
    dt_max: f64,
    max_steps: i64,
    safety: f64,
    max_growth: f64,
    min_shrink: f64
}

fn default_config() -> ODEConfig {
    return ODEConfig {
        rtol: 0.0001,
        atol: 0.0000001,
        dt_init: 0.1,
        dt_min: 0.000000000001,
        dt_max: 1000000.0,
        max_steps: 1000000,
        safety: 0.9,
        max_growth: 10.0,
        min_shrink: 0.2
    }
}

fn high_accuracy_config() -> ODEConfig {
    return ODEConfig {
        rtol: 0.0000000001,
        atol: 0.000000000001,
        dt_init: 0.0,
        dt_min: 0.000000000000001,
        dt_max: 1.0,
        max_steps: 10000000,
        safety: 0.9,
        max_growth: 5.0,
        min_shrink: 0.1
    }
}

// ============================================================================
// SOLUTION STRUCTURE
// ============================================================================

struct ODESolution {
    success: bool,
    nsteps: i64,
    nfeval: i64,
    nreject: i64,
    t_final: f64,
    u_final: f64
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn abs_f64(x: f64) -> f64 {
    if x < 0.0 {
        return 0.0 - x
    }
    return x
}

fn max_f64(a: f64, b: f64) -> f64 {
    if a > b { return a }
    return b
}

fn min_f64(a: f64, b: f64) -> f64 {
    if a < b { return a }
    return b
}

// Compute 5th root using Newton's method
fn fifth_root(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    let y = 1.0
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    let y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    return y
}

// ============================================================================
// TSIT5 STEP FOR EXPONENTIAL DECAY ODE: du/dt = -k*u
// ============================================================================

// ODE function: du/dt = -k*u where k=0.1
fn exp_decay_ode(u: f64, t: f64) -> f64 {
    let k = 0.1
    return 0.0 - k * u
}

// Single Tsit5 step returning new u and error
struct StepResult {
    u_new: f64,
    err: f64
}

// Single Tsit5 step for exponential decay ODE
// Note: Use u_in and stageN_u naming to avoid Sounio compiler scoping issues
fn tsit5_step_exp(u_in: f64, t: f64, dt: f64) -> StepResult {
    // Stage 1
    let k1 = exp_decay_ode(u_in, t)

    // Stage 2
    let stage2_u = u_in + dt * a21() * k1
    let k2 = exp_decay_ode(stage2_u, t + c2() * dt)

    // Stage 3
    let stage3_u = u_in + dt * (a31() * k1 + a32() * k2)
    let k3 = exp_decay_ode(stage3_u, t + c3() * dt)

    // Stage 4
    let stage4_u = u_in + dt * (a41() * k1 + a42() * k2 + a43() * k3)
    let k4 = exp_decay_ode(stage4_u, t + c4() * dt)

    // Stage 5
    let stage5_u = u_in + dt * (a51() * k1 + a52() * k2 + a53() * k3 + a54() * k4)
    let k5 = exp_decay_ode(stage5_u, t + c5() * dt)

    // Stage 6
    let stage6_u = u_in + dt * (a61() * k1 + a62() * k2 + a63() * k3 + a64() * k4 + a65() * k5)
    let k6 = exp_decay_ode(stage6_u, t + c6() * dt)

    // Stage 7 (for error estimation)
    let stage7_u = u_in + dt * (a71() * k1 + a72() * k2 + a73() * k3 + a74() * k4 + a75() * k5 + a76() * k6)
    let k7 = exp_decay_ode(stage7_u, t + c7() * dt)

    // 5th order solution
    let u_new = u_in + dt * (b1() * k1 + b2() * k2 + b3() * k3 + b4() * k4 + b5() * k5 + b6() * k6 + b7() * k7)

    // Error estimate
    let err = dt * (e1() * k1 + e2() * k2 + e3() * k3 + e4() * k4 + e5() * k5 + e6() * k6 + e7() * k7)

    return StepResult {
        u_new: u_new,
        err: abs_f64(err)
    }
}

// ============================================================================
// ERROR AND STEP SIZE CONTROL
// ============================================================================

fn error_norm(err: f64, u: f64, u_new: f64, rtol: f64, atol: f64) -> f64 {
    let scale = atol + rtol * max_f64(abs_f64(u), abs_f64(u_new))
    return abs_f64(err) / scale
}

fn optimal_step(dt: f64, err_norm: f64, safety: f64, max_growth: f64, min_shrink: f64) -> f64 {
    if err_norm <= 0.0 {
        return dt * max_growth
    }
    let factor = safety * fifth_root(1.0 / err_norm)
    let factor_limited = max_f64(min_shrink, min_f64(max_growth, factor))
    return dt * factor_limited
}

// ============================================================================
// MAIN SOLVER
// ============================================================================

fn solve_exp_decay(u0: f64, t0: f64, t_end: f64, config: ODEConfig) -> ODESolution {
    let u = u0
    let t = t0

    // Initialize step size
    let dt = config.dt_init
    let dt = if dt <= 0.0 {
        let f0 = exp_decay_ode(u0, t0)
        let scale = config.atol + config.rtol * abs_f64(u0)
        let est = scale / max_f64(abs_f64(f0), 0.0000000001)
        min_f64(0.01 * abs_f64(t_end - t0), est)
    } else {
        dt
    }
    let dt = max_f64(config.dt_min, min_f64(config.dt_max, dt))

    let nsteps = 0
    let nfeval = 1
    let nreject = 0

    // Integration loop (unrolled for simplicity)
    let result = integrate_loop(u, t, dt, t_end, config, nsteps, nfeval, nreject)

    return result
}

// Helper for integration loop
fn integrate_loop(u: f64, t: f64, dt: f64, t_end: f64, config: ODEConfig, nsteps: i64, nfeval: i64, nreject: i64) -> ODESolution {
    // Simple iterative approach - run until t >= t_end or max_steps
    // Use let mut for variables that change across iterations
    let mut u_curr = u
    let mut t_curr = t
    let mut dt_curr = dt
    let mut steps = nsteps
    let mut evals = nfeval
    let mut rejects = nreject
    let mut step_count = 0

    // Limit iterations (use config.max_steps in production)
    let max_iter = config.max_steps

    while t_curr < t_end && step_count < max_iter {
        // Don't overshoot
        let dt_use = if t_curr + dt_curr > t_end { t_end - t_curr } else { dt_curr }

        // Take a step
        let result = tsit5_step_exp(u_curr, t_curr, dt_use)
        evals = evals + 7

        // Compute error norm
        let err_n = error_norm(result.err, u_curr, result.u_new, config.rtol, config.atol)

        if err_n <= 1.0 {
            // Accept step
            t_curr = t_curr + dt_use
            u_curr = result.u_new
            steps = steps + 1
            dt_curr = optimal_step(dt_use, err_n, config.safety, config.max_growth, config.min_shrink)
        } else {
            // Reject step
            rejects = rejects + 1
            dt_curr = optimal_step(dt_use, err_n, config.safety, config.max_growth, config.min_shrink)
        }

        // Enforce limits
        dt_curr = max_f64(config.dt_min, min_f64(config.dt_max, dt_curr))
        step_count = step_count + 1
    }

    let success = t_curr >= t_end - config.dt_min

    return ODESolution {
        success: success,
        nsteps: steps,
        nfeval: evals,
        nreject: rejects,
        t_final: t_curr,
        u_final: u_curr
    }
}

// ============================================================================
// ANALYTICAL SOLUTION FOR VALIDATION
// ============================================================================

fn exp_approx(x: f64) -> f64 {
    let x2 = x * x
    let x3 = x2 * x
    let x4 = x3 * x
    let x5 = x4 * x
    let x6 = x5 * x
    let x7 = x6 * x
    let x8 = x7 * x
    return 1.0 + x + x2/2.0 + x3/6.0 + x4/24.0 + x5/120.0 + x6/720.0 + x7/5040.0 + x8/40320.0
}

fn exp_decay_analytical(u0: f64, k: f64, t: f64) -> f64 {
    return u0 * exp_approx(0.0 - k * t)
}

// ============================================================================
// TEST / MAIN
// ============================================================================

fn main() -> i32 {
    println("=== Sounio Native Tsit5 ODE Solver ===")
    println("")
    println("Test: Exponential Decay du/dt = -0.1*u")
    println("Initial: u0 = 100.0, t: 0 -> 10")
    println("")

    let u0 = 100.0
    let t0 = 0.0
    let t_end = 10.0

    let config = default_config()
    let sol = solve_exp_decay(u0, t0, t_end, config)

    // Analytical at t=10: u = 100 * exp(-1) â‰ˆ 36.79
    let analytical = exp_decay_analytical(u0, 0.1, t_end)

    let error = abs_f64(sol.u_final - analytical)
    let rel_error = error / analytical

    println("Results:")
    println("  Numerical solution:")
    println(sol.u_final)
    println("  Analytical solution:")
    println(analytical)
    println("  Absolute error:")
    println(error)
    println("  Relative error:")
    println(rel_error)
    println("  Steps taken:")
    println(sol.nsteps)
    println("  Function evals:")
    println(sol.nfeval)
    println("  Rejected steps:")
    println(sol.nreject)
    println("  Success:")
    println(sol.success)
    println("")

    if rel_error < 0.0001 {
        println("TEST PASSED: Relative error < 1e-4")
        return 0
    } else {
        println("TEST FAILED: Relative error >= 1e-4")
        return 1
    }
}
