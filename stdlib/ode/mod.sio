//! Ordinary Differential Equation (ODE) Solvers for Sounio
//!
//! A comprehensive suite of numerical integrators for solving initial value problems:
//!
//!   dy/dt = f(t, y),  y(t0) = y0
//!
//! # Solver Selection Guide
//!
//! | Problem Type          | Recommended Solver | Why                              |
//! |-----------------------|-------------------|----------------------------------|
//! | Non-stiff, smooth     | Tsit5             | Fast, accurate, adaptive         |
//! | Non-stiff, general    | DOPRI5            | Robust, widely used              |
//! | Real-time/embedded    | RK4               | Fixed step, predictable timing   |
//! | Stiff systems         | BDF/Radau         | Implicit, L-stable               |
//!
//! # Quick Start
//!
//! ```d
//! use ode::*
//!
//! // Simple exponential decay: du/dt = -k*u
//! let sol = solve_exp_decay(100.0, 0.0, 10.0, default_config())
//! println("Final value: {}", sol.u_final)
//!
//! // 3-compartment PK model
//! let s0 = PKState3 { gut: 500.0, central: 0.0, periph: 0.0, t: 0.0 }
//! let sol = solve_rk4_pk3(s0, default_pk3_params(), 24.0, 1000)
//! ```
//!
//! # Available Solvers
//!
//! ## Explicit Methods (non-stiff)
//! - **Tsit5**: Tsitouras 5(4) - Recommended for most problems
//! - **RK4**: Classic 4th-order Runge-Kutta - Fixed step
//! - **DOPRI5**: Dormand-Prince 5(4) - Robust adaptive method
//!
//! ## Implicit Methods (stiff)
//! - **BDF**: Backward Differentiation Formulas (variable order 1-5)
//! - **Radau5**: Radau IIA 5th order (L-stable)
//!
//! # Features
//!
//! - Adaptive step size control with error estimation
//! - Dense output for continuous interpolation
//! - Event detection and handling
//! - PBPK-specific optimized solvers

module ode

// ============================================================================
// RE-EXPORTS: Existing Solvers
// ============================================================================

// Tsitouras 5(4) adaptive solver - recommended for non-stiff
pub use tsit5::*

// Classic fixed-step RK4
pub use rk4::*

// ============================================================================
// COMMON TYPES
// ============================================================================

/// Solver method enumeration
pub enum SolverMethod {
    /// Fixed-step 4th order Runge-Kutta
    RK4,
    /// Tsitouras 5(4) adaptive (default)
    Tsit5,
    /// Dormand-Prince 5(4) adaptive
    DOPRI5,
    /// Backward Differentiation Formulas (stiff)
    BDF,
    /// Radau IIA implicit (stiff)
    Radau5,
    /// Automatic selection
    Auto,
}

/// Generic ODE system trait for user-defined systems
pub trait ODESystem {
    /// Dimension of the state vector
    fn dim(&self) -> usize

    /// Evaluate the right-hand side: dydt = f(t, y)
    fn eval(&self, t: f64, y: &[f64], dydt: &![f64])

    /// Optional: Analytical Jacobian df/dy (for implicit methods)
    fn jacobian(&self, t: f64, y: &[f64]) -> Option<Vec<f64>> {
        None
    }
}

/// Extended solver options
pub struct SolverOptions {
    /// Relative tolerance (default: 1e-4)
    pub rtol: f64,
    /// Absolute tolerance (default: 1e-7)
    pub atol: f64,
    /// Initial step size (0 = auto)
    pub dt_init: f64,
    /// Minimum step size
    pub dt_min: f64,
    /// Maximum step size
    pub dt_max: f64,
    /// Maximum number of steps
    pub max_steps: i64,
    /// Safety factor for step control
    pub safety: f64,
    /// Enable dense output
    pub dense_output: bool,
}

impl SolverOptions {
    /// Default options matching tsit5
    pub fn default() -> SolverOptions {
        SolverOptions {
            rtol: 0.0001,
            atol: 0.0000001,
            dt_init: 0.1,
            dt_min: 0.000000000001,
            dt_max: 1000000.0,
            max_steps: 1000000,
            safety: 0.9,
            dense_output: false,
        }
    }

    /// High accuracy options
    pub fn high_accuracy() -> SolverOptions {
        SolverOptions {
            rtol: 0.0000000001,
            atol: 0.000000000001,
            dt_init: 0.0,
            dt_min: 0.000000000000001,
            dt_max: 1.0,
            max_steps: 10000000,
            safety: 0.9,
            dense_output: false,
        }
    }

    /// Fast, lower accuracy options
    pub fn fast() -> SolverOptions {
        SolverOptions {
            rtol: 0.001,
            atol: 0.00001,
            dt_init: 0.1,
            dt_min: 0.0000001,
            dt_max: 10000.0,
            max_steps: 100000,
            safety: 0.9,
            dense_output: false,
        }
    }
}

/// Generic solution structure
pub struct GenericSolution {
    /// Whether integration succeeded
    pub success: bool,
    /// Time points
    pub t: Vec<f64>,
    /// Solution values (t.len() x dim)
    pub y: Vec<Vec<f64>>,
    /// Number of steps taken
    pub nsteps: i64,
    /// Number of function evaluations
    pub nfeval: i64,
    /// Number of rejected steps
    pub nreject: i64,
    /// Final time reached
    pub t_final: f64,
    /// Termination message
    pub message: string,
}

impl GenericSolution {
    /// Get final state vector
    pub fn final_state(&self) -> &[f64] {
        &self.y[self.y.len() - 1]
    }

    /// Get state at index i
    pub fn state_at(&self, i: usize) -> &[f64] {
        &self.y[i]
    }
}

// ============================================================================
// DORMAND-PRINCE 5(4) COEFFICIENTS
// ============================================================================

// DOPRI5 Butcher tableau
fn dopri5_c2() -> f64 { 1.0/5.0 }
fn dopri5_c3() -> f64 { 3.0/10.0 }
fn dopri5_c4() -> f64 { 4.0/5.0 }
fn dopri5_c5() -> f64 { 8.0/9.0 }
fn dopri5_c6() -> f64 { 1.0 }
fn dopri5_c7() -> f64 { 1.0 }

fn dopri5_a21() -> f64 { 1.0/5.0 }
fn dopri5_a31() -> f64 { 3.0/40.0 }
fn dopri5_a32() -> f64 { 9.0/40.0 }
fn dopri5_a41() -> f64 { 44.0/45.0 }
fn dopri5_a42() -> f64 { 0.0 - 56.0/15.0 }
fn dopri5_a43() -> f64 { 32.0/9.0 }
fn dopri5_a51() -> f64 { 19372.0/6561.0 }
fn dopri5_a52() -> f64 { 0.0 - 25360.0/2187.0 }
fn dopri5_a53() -> f64 { 64448.0/6561.0 }
fn dopri5_a54() -> f64 { 0.0 - 212.0/729.0 }
fn dopri5_a61() -> f64 { 9017.0/3168.0 }
fn dopri5_a62() -> f64 { 0.0 - 355.0/33.0 }
fn dopri5_a63() -> f64 { 46732.0/5247.0 }
fn dopri5_a64() -> f64 { 49.0/176.0 }
fn dopri5_a65() -> f64 { 0.0 - 5103.0/18656.0 }
fn dopri5_a71() -> f64 { 35.0/384.0 }
fn dopri5_a73() -> f64 { 500.0/1113.0 }
fn dopri5_a74() -> f64 { 125.0/192.0 }
fn dopri5_a75() -> f64 { 0.0 - 2187.0/6784.0 }
fn dopri5_a76() -> f64 { 11.0/84.0 }

// 5th order weights
fn dopri5_b1() -> f64 { 35.0/384.0 }
fn dopri5_b3() -> f64 { 500.0/1113.0 }
fn dopri5_b4() -> f64 { 125.0/192.0 }
fn dopri5_b5() -> f64 { 0.0 - 2187.0/6784.0 }
fn dopri5_b6() -> f64 { 11.0/84.0 }

// Error coefficients
fn dopri5_e1() -> f64 { 71.0/57600.0 }
fn dopri5_e3() -> f64 { 0.0 - 71.0/16695.0 }
fn dopri5_e4() -> f64 { 71.0/1920.0 }
fn dopri5_e5() -> f64 { 0.0 - 17253.0/339200.0 }
fn dopri5_e6() -> f64 { 22.0/525.0 }
fn dopri5_e7() -> f64 { 0.0 - 1.0/40.0 }

// ============================================================================
// DOPRI5 SOLVER FOR SCALAR ODE
// ============================================================================

/// Single DOPRI5 step for scalar ODE du/dt = f(u, t)
struct DOPRI5StepResult {
    u_new: f64,
    err: f64
}

/// DOPRI5 step for exponential decay ODE (du/dt = -k*u)
fn dopri5_step_exp(u_in: f64, t: f64, dt: f64) -> DOPRI5StepResult {
    let k = 0.1  // decay constant

    // k1
    let k1 = 0.0 - k * u_in

    // k2
    let u2 = u_in + dt * dopri5_a21() * k1
    let k2 = 0.0 - k * u2

    // k3
    let u3 = u_in + dt * (dopri5_a31() * k1 + dopri5_a32() * k2)
    let k3 = 0.0 - k * u3

    // k4
    let u4 = u_in + dt * (dopri5_a41() * k1 + dopri5_a42() * k2 + dopri5_a43() * k3)
    let k4 = 0.0 - k * u4

    // k5
    let u5 = u_in + dt * (dopri5_a51() * k1 + dopri5_a52() * k2 + dopri5_a53() * k3 + dopri5_a54() * k4)
    let k5 = 0.0 - k * u5

    // k6
    let u6 = u_in + dt * (dopri5_a61() * k1 + dopri5_a62() * k2 + dopri5_a63() * k3 + dopri5_a64() * k4 + dopri5_a65() * k5)
    let k6 = 0.0 - k * u6

    // 5th order solution
    let u_new = u_in + dt * (dopri5_b1() * k1 + dopri5_b3() * k3 + dopri5_b4() * k4 + dopri5_b5() * k5 + dopri5_b6() * k6)

    // k7 for error
    let k7 = 0.0 - k * u_new

    // Error estimate
    let err_abs = dt * (dopri5_e1() * k1 + dopri5_e3() * k3 + dopri5_e4() * k4 + dopri5_e5() * k5 + dopri5_e6() * k6 + dopri5_e7() * k7)

    let err = if err_abs < 0.0 { 0.0 - err_abs } else { err_abs }

    return DOPRI5StepResult { u_new: u_new, err: err }
}

/// Solve exponential decay using DOPRI5
pub fn solve_dopri5_exp(u0: f64, t0: f64, t_end: f64, config: ODEConfig) -> ODESolution {
    let mut u = u0
    let mut t = t0
    let mut dt = config.dt_init

    if dt <= 0.0 {
        dt = 0.01 * (t_end - t0)
    }

    let mut nsteps: i64 = 0
    let mut nfeval: i64 = 0
    let mut nreject: i64 = 0

    while t < t_end && nsteps < config.max_steps {
        if t + dt > t_end {
            dt = t_end - t
        }

        let result = dopri5_step_exp(u, t, dt)
        nfeval = nfeval + 7

        // Error norm
        let scale = config.atol + config.rtol * (if u < 0.0 { 0.0 - u } else { u })
        let err_norm = result.err / scale

        if err_norm <= 1.0 {
            // Accept
            t = t + dt
            u = result.u_new
            nsteps = nsteps + 1

            // Grow step
            if err_norm > 0.0 {
                let factor = config.safety * fifth_root(1.0 / err_norm)
                let factor = if factor > config.max_growth { config.max_growth } else { factor }
                dt = dt * factor
            } else {
                dt = dt * config.max_growth
            }
        } else {
            // Reject
            nreject = nreject + 1
            let factor = config.safety * fifth_root(1.0 / err_norm)
            let factor = if factor < config.min_shrink { config.min_shrink } else { factor }
            dt = dt * factor
        }

        dt = if dt < config.dt_min { config.dt_min } else { dt }
        dt = if dt > config.dt_max { config.dt_max } else { dt }
    }

    return ODESolution {
        success: t >= t_end - config.dt_min,
        nsteps: nsteps,
        nfeval: nfeval,
        nreject: nreject,
        t_final: t,
        u_final: u
    }
}

// ============================================================================
// BDF SOLVER STUB (STIFF SYSTEMS)
// ============================================================================

/// Backward Differentiation Formula solver for stiff systems
/// Variable order (1-5), variable step
pub struct BDFState {
    /// Current solution
    pub u: f64,
    /// Current time
    pub t: f64,
    /// History for multistep
    history: Vec<f64>,
    /// Current order
    order: i64,
}

/// BDF coefficients for orders 1-5
fn bdf_alpha(order: i64, idx: i64) -> f64 {
    // Returns coefficient for y_{n-idx} in BDF formula
    // BDF1: y_n = y_{n-1} + h*f_n
    // BDF2: y_n = 4/3*y_{n-1} - 1/3*y_{n-2} + 2/3*h*f_n
    // etc.
    if order == 1 {
        if idx == 0 { return 1.0 }
        if idx == 1 { return 0.0 - 1.0 }
    }
    if order == 2 {
        if idx == 0 { return 1.0 }
        if idx == 1 { return 0.0 - 4.0/3.0 }
        if idx == 2 { return 1.0/3.0 }
    }
    return 0.0
}

/// Simplified BDF1 (backward Euler) for exponential decay
pub fn solve_bdf1_exp(u0: f64, t0: f64, t_end: f64, n_steps: i64) -> ODESolution {
    let dt = (t_end - t0) / (n_steps as f64)
    let k = 0.1  // decay constant
    let mut u = u0
    let mut t = t0
    let mut nsteps: i64 = 0

    // For du/dt = -k*u, backward Euler gives:
    // u_{n+1} = u_n + dt * (-k * u_{n+1})
    // u_{n+1} * (1 + k*dt) = u_n
    // u_{n+1} = u_n / (1 + k*dt)
    let factor = 1.0 / (1.0 + k * dt)

    while nsteps < n_steps {
        u = u * factor
        t = t + dt
        nsteps = nsteps + 1
    }

    return ODESolution {
        success: true,
        nsteps: nsteps,
        nfeval: nsteps,
        nreject: 0,
        t_final: t,
        u_final: u
    }
}

// ============================================================================
// CONVENIENCE FUNCTIONS
// ============================================================================

/// Solve ODE using best method for problem type
pub fn solve_auto(u0: f64, t0: f64, t_end: f64) -> ODESolution {
    // Default to Tsit5 for non-stiff
    return solve_exp_decay(u0, t0, t_end, default_config())
}

/// Fifth root for step size control
fn fifth_root(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    let mut y = 1.0
    y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    y = y - (y * y * y * y * y - x) / (5.0 * y * y * y * y)
    return y
}

// ============================================================================
// TESTS
// ============================================================================

#[test]
fn test_dopri5_exp_decay() {
    let sol = solve_dopri5_exp(100.0, 0.0, 10.0, default_config())
    let analytical = exp_decay_analytical(100.0, 0.1, 10.0)
    let rel_err = abs_f64(sol.u_final - analytical) / analytical
    assert_true(rel_err < 0.0001)
}

#[test]
fn test_bdf1_exp_decay() {
    let sol = solve_bdf1_exp(100.0, 0.0, 10.0, 10000)
    let analytical = exp_decay_analytical(100.0, 0.1, 10.0)
    let rel_err = abs_f64(sol.u_final - analytical) / analytical
    assert_true(rel_err < 0.01)
}
