// PBPK Regulatory Compliance Module for Sounio
//
// Full compliance with FDA and EMA 2024-2025 guidelines:
// - FDA: "Physiologically Based Pharmacokinetic Analyses — Format and Content"
// - EMA: "Guideline on Reporting of PBPK Modelling and Simulation"
//
// References:
// - https://www.fda.gov/regulatory-information/search-fda-guidance-documents/physiologically-based-pharmacokinetic-analyses-format-and-content-guidance-industry
// - https://www.ema.europa.eu/en/reporting-physiologically-based-pharmacokinetic-pbpk-modelling-simulation-scientific-guideline
// - CPT Pharmacometrics Syst Pharmacol. 2025 - Current Use of PBPK modeling at EMA

module pbpk::regulatory

use units::qudt::*
use pbpk::*

// =============================================================================
// Validation Metrics (FDA/EMA Standard)
// =============================================================================

/// Comprehensive PBPK validation metrics per FDA/EMA guidance
pub struct ValidationMetrics {
    // === Primary Metrics (Required) ===

    /// Geometric Mean Fold Error - measures prediction accuracy
    /// Target: GMFE <= 2.0 for qualified models
    pub gmfe: f64,

    /// Average Fold Error - measures bias
    /// Target: AFE close to 1.0 (0.8-1.25 acceptable)
    pub afe: f64,

    /// Absolute Average Fold Error - measures precision
    /// Target: AAFE < 2.0 (< 1.5 preferred)
    pub aafe: f64,

    /// Fraction within 2-fold of observed
    /// Target: >= 80% for qualified models
    pub within_2fold: f64,

    /// Fraction within 1.5-fold (stricter criterion)
    /// Target: >= 50% for high-confidence models
    pub within_1_5fold: f64,

    // === Secondary Metrics ===

    /// Root Mean Square Error
    pub rmse: f64,

    /// Mean Prediction Error (%)
    pub mpe_percent: f64,

    /// Mean Absolute Prediction Error (%)
    pub mape_percent: f64,

    /// Coefficient of determination (R²)
    pub r_squared: f64,

    /// Concordance correlation coefficient
    pub ccc: f64,

    // === DDI-Specific Metrics (FDA) ===

    /// AUC ratio prediction accuracy (for DDI)
    pub auc_ratio_afe: Option<f64>,
    pub auc_ratio_aafe: Option<f64>,

    /// Cmax ratio prediction accuracy (for DDI)
    pub cmax_ratio_afe: Option<f64>,
    pub cmax_ratio_aafe: Option<f64>,

    // === Epistemic Metrics (Sounio-specific) ===

    /// Minimum confidence of input parameters
    pub min_input_confidence: f64,

    /// Propagated output confidence
    pub output_confidence: f64,

    /// Provenance completeness score
    pub provenance_completeness: f64,
}

impl ValidationMetrics {
    /// Calculate all validation metrics from predicted vs observed data
    pub fn calculate(
        predicted: &[f64],
        observed: &[f64],
    ) -> Result<Self, ValidationError> {
        if predicted.len() != observed.len() {
            return Err(ValidationError::DataMismatch {
                expected: observed.len(),
                actual: predicted.len(),
            });
        }

        let n = predicted.len() as f64;

        // Fold errors for each observation
        let fold_errors: Vec<f64> = predicted.iter()
            .zip(observed)
            .map(|(p, o)| p / o)
            .collect();

        // GMFE: exp(mean(|log(pred/obs)|))
        let log_errors: Vec<f64> = fold_errors.iter()
            .map(|fe| fe.ln().abs())
            .collect();
        let gmfe = (log_errors.iter().sum::<f64>() / n).exp();

        // AFE: 10^(mean(log10(pred/obs))) - measures bias
        let log10_errors: Vec<f64> = fold_errors.iter()
            .map(|fe| fe.log10())
            .collect();
        let afe = 10.0_f64.powf(log10_errors.iter().sum::<f64>() / n);

        // AAFE: 10^(mean(|log10(pred/obs)|)) - measures precision
        let abs_log10_errors: Vec<f64> = log10_errors.iter()
            .map(|e| e.abs())
            .collect();
        let aafe = 10.0_f64.powf(abs_log10_errors.iter().sum::<f64>() / n);

        // Fraction within X-fold
        let within_2fold = fold_errors.iter()
            .filter(|fe| **fe >= 0.5 && **fe <= 2.0)
            .count() as f64 / n;

        let within_1_5fold = fold_errors.iter()
            .filter(|fe| **fe >= 0.667 && **fe <= 1.5)
            .count() as f64 / n;

        // RMSE
        let se_sum: f64 = predicted.iter()
            .zip(observed)
            .map(|(p, o)| (p - o).powi(2))
            .sum();
        let rmse = (se_sum / n).sqrt();

        // MPE% and MAPE%
        let pe: Vec<f64> = predicted.iter()
            .zip(observed)
            .map(|(p, o)| (p - o) / o * 100.0)
            .collect();
        let mpe_percent = pe.iter().sum::<f64>() / n;
        let mape_percent = pe.iter().map(|e| e.abs()).sum::<f64>() / n;

        // R²
        let mean_obs = observed.iter().sum::<f64>() / n;
        let ss_tot: f64 = observed.iter().map(|o| (o - mean_obs).powi(2)).sum();
        let ss_res: f64 = predicted.iter()
            .zip(observed)
            .map(|(p, o)| (p - o).powi(2))
            .sum();
        let r_squared = 1.0 - ss_res / ss_tot;

        // Concordance Correlation Coefficient (CCC)
        let mean_pred = predicted.iter().sum::<f64>() / n;
        let var_pred: f64 = predicted.iter().map(|p| (p - mean_pred).powi(2)).sum() / n;
        let var_obs: f64 = observed.iter().map(|o| (o - mean_obs).powi(2)).sum() / n;
        let covar: f64 = predicted.iter()
            .zip(observed)
            .map(|(p, o)| (p - mean_pred) * (o - mean_obs))
            .sum::<f64>() / n;
        let ccc = (2.0 * covar) / (var_pred + var_obs + (mean_pred - mean_obs).powi(2));

        Ok(Self {
            gmfe,
            afe,
            aafe,
            within_2fold,
            within_1_5fold,
            rmse,
            mpe_percent,
            mape_percent,
            r_squared,
            ccc,
            auc_ratio_afe: None,
            auc_ratio_aafe: None,
            cmax_ratio_afe: None,
            cmax_ratio_aafe: None,
            min_input_confidence: 1.0,
            output_confidence: 1.0,
            provenance_completeness: 1.0,
        })
    }

    /// Calculate DDI-specific metrics
    pub fn with_ddi_metrics(
        mut self,
        pred_auc_ratios: &[f64],
        obs_auc_ratios: &[f64],
        pred_cmax_ratios: &[f64],
        obs_cmax_ratios: &[f64],
    ) -> Self {
        let n_auc = pred_auc_ratios.len() as f64;
        let n_cmax = pred_cmax_ratios.len() as f64;

        // AUC ratio metrics
        if n_auc > 0.0 {
            let log10_auc: Vec<f64> = pred_auc_ratios.iter()
                .zip(obs_auc_ratios)
                .map(|(p, o)| (p / o).log10())
                .collect();
            self.auc_ratio_afe = Some(10.0_f64.powf(log10_auc.iter().sum::<f64>() / n_auc));
            self.auc_ratio_aafe = Some(10.0_f64.powf(
                log10_auc.iter().map(|e| e.abs()).sum::<f64>() / n_auc
            ));
        }

        // Cmax ratio metrics
        if n_cmax > 0.0 {
            let log10_cmax: Vec<f64> = pred_cmax_ratios.iter()
                .zip(obs_cmax_ratios)
                .map(|(p, o)| (p / o).log10())
                .collect();
            self.cmax_ratio_afe = Some(10.0_f64.powf(log10_cmax.iter().sum::<f64>() / n_cmax));
            self.cmax_ratio_aafe = Some(10.0_f64.powf(
                log10_cmax.iter().map(|e| e.abs()).sum::<f64>() / n_cmax
            ));
        }

        self
    }

    /// Add epistemic metrics from Sounio Knowledge types
    pub fn with_epistemic_metrics(
        mut self,
        min_input_confidence: f64,
        output_confidence: f64,
        provenance_completeness: f64,
    ) -> Self {
        self.min_input_confidence = min_input_confidence;
        self.output_confidence = output_confidence;
        self.provenance_completeness = provenance_completeness;
        self
    }
}

// =============================================================================
// EMA Impact Classification (2018/2025 Guidelines)
// =============================================================================

/// EMA PBPK impact classification
/// Determines qualification requirements based on regulatory impact
pub enum EmaImpactLevel {
    /// Low impact: Descriptive/mechanistic understanding
    /// Clinical PK study conducted, model supports interpretation
    /// Qualification: Standard documentation sufficient
    Low,

    /// Medium impact: Supports regulatory decision with clinical data
    /// Model contributes evidence assessed with clinical data
    /// Qualification: Verification against relevant clinical data required
    Medium,

    /// High impact: Key source for SmPC (label) information
    /// Model is primary evidence for regulatory decision
    /// Qualification: Full qualification with prospective prediction required
    High,
}

impl EmaImpactLevel {
    /// Determine impact level based on intended use
    pub fn from_intended_use(use_case: &EmaIntendedUse) -> Self {
        match use_case {
            EmaIntendedUse::MechanisticUnderstanding => EmaImpactLevel::Low,
            EmaIntendedUse::SupportClinicalInterpretation => EmaImpactLevel::Low,
            EmaIntendedUse::InformTrialDesign => EmaImpactLevel::Medium,
            EmaIntendedUse::SupportDosingRecommendation => EmaImpactLevel::Medium,
            EmaIntendedUse::PredictDDI => EmaImpactLevel::Medium,
            EmaIntendedUse::PredictSpecialPopulation => EmaImpactLevel::Medium,
            EmaIntendedUse::WaiveClinicalStudy => EmaImpactLevel::High,
            EmaIntendedUse::PrimaryEvidenceForLabel => EmaImpactLevel::High,
            EmaIntendedUse::PediatricExtrapolation => EmaImpactLevel::High,
        }
    }

    /// Get minimum acceptance criteria for this impact level
    pub fn acceptance_criteria(&self) -> AcceptanceCriteria {
        match self {
            EmaImpactLevel::Low => AcceptanceCriteria {
                gmfe_max: 3.0,
                aafe_max: 3.0,
                within_2fold_min: 0.50,
                min_confidence: 0.50,
            },
            EmaImpactLevel::Medium => AcceptanceCriteria {
                gmfe_max: 2.0,
                aafe_max: 2.0,
                within_2fold_min: 0.80,
                min_confidence: 0.75,
            },
            EmaImpactLevel::High => AcceptanceCriteria {
                gmfe_max: 1.5,
                aafe_max: 1.5,
                within_2fold_min: 0.90,
                min_confidence: 0.85,
            },
        }
    }
}

/// EMA intended use categories
pub enum EmaIntendedUse {
    MechanisticUnderstanding,
    SupportClinicalInterpretation,
    InformTrialDesign,
    SupportDosingRecommendation,
    PredictDDI,
    PredictSpecialPopulation,
    WaiveClinicalStudy,
    PrimaryEvidenceForLabel,
    PediatricExtrapolation,
}

/// Acceptance criteria thresholds
pub struct AcceptanceCriteria {
    pub gmfe_max: f64,
    pub aafe_max: f64,
    pub within_2fold_min: f64,
    pub min_confidence: f64,  // Sounio epistemic requirement
}

// =============================================================================
// FDA Report Structure (6 Sections)
// =============================================================================

/// FDA-compliant PBPK report structure
/// Per FDA Guidance "Physiologically Based Pharmacokinetic Analyses — Format and Content"
pub struct FdaReport {
    /// Section A: Executive Summary
    pub executive_summary: ExecutiveSummary,

    /// Section B: Introduction (Objectives & Background)
    pub introduction: Introduction,

    /// Section C: Materials and Methods
    pub materials_methods: MaterialsMethods,

    /// Section D: Results
    pub results: Results,

    /// Section E: Discussion
    pub discussion: Discussion,

    /// Section F: Appendices
    pub appendices: Appendices,
}

/// Section A: Executive Summary
pub struct ExecutiveSummary {
    /// Objective of PBPK analysis
    pub objective: string,

    /// Key conclusions
    pub conclusions: Vec<string>,

    /// Regulatory impact summary
    pub regulatory_impact: string,

    /// Model qualification status
    pub qualification_status: QualificationStatus,
}

pub enum QualificationStatus {
    Qualified { confidence: f64 },
    ConditionallyQualified { limitations: Vec<string> },
    NotQualified { reasons: Vec<string> },
}

/// Section B: Introduction
pub struct Introduction {
    /// Background and rationale
    pub background: string,

    /// Specific objectives
    pub objectives: Vec<string>,

    /// Intended use (maps to EMA impact level)
    pub intended_use: EmaIntendedUse,

    /// Relevant prior knowledge
    pub prior_knowledge: Vec<string>,
}

/// Section C: Materials and Methods
pub struct MaterialsMethods {
    /// Platform information
    pub platform: PlatformInfo,

    /// Model structure description
    pub model_structure: ModelStructure,

    /// Drug-dependent parameters
    pub drug_parameters: Vec<DrugParameter>,

    /// System-dependent parameters
    pub system_parameters: Vec<SystemParameter>,

    /// Virtual population description
    pub virtual_population: VirtualPopulation,

    /// Simulation design
    pub simulation_design: SimulationDesign,

    /// Validation strategy
    pub validation_strategy: ValidationStrategy,
}

pub struct PlatformInfo {
    pub name: string,
    pub version: string,
    pub vendor: string,
    pub qualification_status: string,
}

pub struct ModelStructure {
    /// Number of compartments
    pub n_compartments: u32,

    /// Organs included
    pub organs: Vec<string>,

    /// Absorption model (if applicable)
    pub absorption_model: Option<string>,

    /// Distribution model
    pub distribution_model: string,

    /// Metabolism pathways
    pub metabolism_pathways: Vec<string>,

    /// Excretion pathways
    pub excretion_pathways: Vec<string>,

    /// Key assumptions
    pub assumptions: Vec<string>,
}

pub struct DrugParameter {
    pub name: string,
    pub value: f64,
    pub unit: string,
    pub source: string,
    pub confidence: f64,  // Sounio epistemic
    pub method: string,   // In vitro, in vivo, predicted, etc.
}

pub struct SystemParameter {
    pub name: string,
    pub value: f64,
    pub unit: string,
    pub population: string,
    pub source: string,
}

pub struct VirtualPopulation {
    pub n_subjects: u32,
    pub age_range: (f64, f64),
    pub weight_range: (f64, f64),
    pub sex_distribution: f64,  // Fraction female
    pub special_populations: Vec<string>,
}

pub struct SimulationDesign {
    pub dosing_regimens: Vec<string>,
    pub simulation_duration: h,
    pub output_parameters: Vec<string>,
    pub n_trials: u32,
}

pub struct ValidationStrategy {
    /// Clinical studies used for verification
    pub verification_studies: Vec<ClinicalStudy>,

    /// Predefined acceptance criteria
    pub acceptance_criteria: AcceptanceCriteria,

    /// Sensitivity analysis plan
    pub sensitivity_analysis: SensitivityAnalysis,
}

pub struct ClinicalStudy {
    pub study_id: string,
    pub reference: string,
    pub n_subjects: u32,
    pub design: string,
    pub endpoints: Vec<string>,
}

pub struct SensitivityAnalysis {
    pub parameters_tested: Vec<string>,
    pub method: string,  // Local, global, etc.
    pub variation_range: f64,
}

/// Section D: Results
pub struct Results {
    /// Model verification results
    pub verification: VerificationResults,

    /// Simulation results
    pub simulations: SimulationResults,

    /// Sensitivity analysis results
    pub sensitivity: SensitivityResults,

    /// Validation metrics
    pub metrics: ValidationMetrics,
}

pub struct VerificationResults {
    /// Observed vs predicted comparisons
    pub obs_vs_pred: Vec<ObsVsPred>,

    /// PK parameter predictions
    pub pk_parameters: Vec<PKParameterResult>,
}

pub struct ObsVsPred {
    pub study_id: string,
    pub parameter: string,
    pub observed: f64,
    pub predicted: f64,
    pub fold_error: f64,
}

pub struct PKParameterResult {
    pub parameter: string,
    pub unit: string,
    pub observed_mean: f64,
    pub observed_cv: f64,
    pub predicted_mean: f64,
    pub predicted_cv: f64,
    pub within_acceptance: bool,
}

pub struct SimulationResults {
    pub primary_endpoint: string,
    pub result_summary: string,
    pub confidence_intervals: Vec<(f64, f64)>,
}

pub struct SensitivityResults {
    pub influential_parameters: Vec<(string, f64)>,  // (param, sensitivity index)
    pub robustness_assessment: string,
}

/// Section E: Discussion
pub struct Discussion {
    /// Model strengths
    pub strengths: Vec<string>,

    /// Model limitations
    pub limitations: Vec<string>,

    /// Comparison to clinical data
    pub clinical_comparison: string,

    /// Uncertainty assessment
    pub uncertainty_assessment: string,

    /// Regulatory implications
    pub regulatory_implications: string,
}

/// Section F: Appendices
pub struct Appendices {
    /// Detailed parameter tables
    pub parameter_tables: Vec<string>,

    /// Individual simulation results
    pub individual_results: Vec<string>,

    /// Model code/files
    pub model_files: Vec<string>,

    /// References
    pub references: Vec<string>,

    /// Provenance audit trail (Sounio-specific)
    pub provenance_audit: string,
}

// =============================================================================
// Report Generation Functions
// =============================================================================

/// Generate FDA-compliant report from simulation results
pub fn generate_fda_report(
    drug: &Drug,
    params: &PBPKParams,
    result: &SimulationResult,
    observed_data: &[(f64, f64)],  // (time, concentration)
    config: &ReportConfig,
) -> FdaReport with IO {

    // Calculate validation metrics
    let predicted: Vec<f64> = observed_data.iter()
        .map(|(t, _)| interpolate_at_time(result, *t))
        .collect();
    let observed: Vec<f64> = observed_data.iter().map(|(_, c)| *c).collect();
    let metrics = ValidationMetrics::calculate(&predicted, &observed)
        .unwrap_or_default()
        .with_epistemic_metrics(
            params.min_confidence(),
            result.confidence,
            result.provenance.completeness_score(),
        );

    // Determine qualification status
    let impact_level = EmaImpactLevel::from_intended_use(&config.intended_use);
    let criteria = impact_level.acceptance_criteria();
    let qualification_status = if metrics.gmfe <= criteria.gmfe_max
        && metrics.within_2fold >= criteria.within_2fold_min
        && metrics.min_input_confidence >= criteria.min_confidence {
        QualificationStatus::Qualified { confidence: metrics.output_confidence }
    } else {
        let mut reasons = Vec::new();
        if metrics.gmfe > criteria.gmfe_max {
            reasons.push(format!("GMFE {:.2} exceeds threshold {:.2}", metrics.gmfe, criteria.gmfe_max));
        }
        if metrics.within_2fold < criteria.within_2fold_min {
            reasons.push(format!("Within 2-fold {:.1}% below {:.1}%",
                metrics.within_2fold * 100.0, criteria.within_2fold_min * 100.0));
        }
        if metrics.min_input_confidence < criteria.min_confidence {
            reasons.push(format!("Input confidence {:.2} below {:.2}",
                metrics.min_input_confidence, criteria.min_confidence));
        }
        QualificationStatus::NotQualified { reasons }
    };

    FdaReport {
        executive_summary: ExecutiveSummary {
            objective: config.objective.clone(),
            conclusions: derive_conclusions(&metrics, &qualification_status),
            regulatory_impact: describe_regulatory_impact(&impact_level),
            qualification_status,
        },
        introduction: Introduction {
            background: config.background.clone(),
            objectives: config.objectives.clone(),
            intended_use: config.intended_use,
            prior_knowledge: config.prior_knowledge.clone(),
        },
        materials_methods: MaterialsMethods {
            platform: PlatformInfo {
                name: "Sounio".to_string(),
                version: env!("CARGO_PKG_VERSION").to_string(),
                vendor: "Sounio Language Project".to_string(),
                qualification_status: "Epistemic-verified".to_string(),
            },
            model_structure: ModelStructure {
                n_compartments: 14,
                organs: ORGANS.to_vec(),
                absorption_model: Some("First-order with lag".to_string()),
                distribution_model: "Perfusion-limited".to_string(),
                metabolism_pathways: config.metabolism_pathways.clone(),
                excretion_pathways: config.excretion_pathways.clone(),
                assumptions: config.assumptions.clone(),
            },
            drug_parameters: extract_drug_parameters(drug, params),
            system_parameters: default_system_parameters(),
            virtual_population: config.virtual_population.clone(),
            simulation_design: config.simulation_design.clone(),
            validation_strategy: ValidationStrategy {
                verification_studies: config.verification_studies.clone(),
                acceptance_criteria: criteria,
                sensitivity_analysis: config.sensitivity_analysis.clone(),
            },
        },
        results: Results {
            verification: VerificationResults {
                obs_vs_pred: observed_data.iter()
                    .enumerate()
                    .map(|(i, (t, obs))| ObsVsPred {
                        study_id: config.verification_studies[0].study_id.clone(),
                        parameter: format!("C({:.1}h)", t),
                        observed: *obs,
                        predicted: predicted[i],
                        fold_error: predicted[i] / obs,
                    })
                    .collect(),
                pk_parameters: vec![],
            },
            simulations: SimulationResults {
                primary_endpoint: "Plasma concentration-time profile".to_string(),
                result_summary: format!(
                    "Simulation completed with overall confidence {:.1}%",
                    result.confidence * 100.0
                ),
                confidence_intervals: vec![],
            },
            sensitivity: SensitivityResults {
                influential_parameters: vec![],
                robustness_assessment: "Pending sensitivity analysis".to_string(),
            },
            metrics,
        },
        discussion: Discussion {
            strengths: vec![
                "Full epistemic tracking of parameter confidence".to_string(),
                "Automatic provenance audit trail".to_string(),
                "Compile-time unit verification".to_string(),
            ],
            limitations: config.limitations.clone(),
            clinical_comparison: "See verification results".to_string(),
            uncertainty_assessment: format!(
                "Overall output confidence: {:.1}%", result.confidence * 100.0
            ),
            regulatory_implications: describe_regulatory_impact(&impact_level),
        },
        appendices: Appendices {
            parameter_tables: vec![],
            individual_results: vec![],
            model_files: vec!["pbpk_model.d".to_string()],
            references: config.references.clone(),
            provenance_audit: result.provenance.to_audit_trail(),
        },
    }
}

/// Report configuration
pub struct ReportConfig {
    pub objective: string,
    pub background: string,
    pub objectives: Vec<string>,
    pub intended_use: EmaIntendedUse,
    pub prior_knowledge: Vec<string>,
    pub metabolism_pathways: Vec<string>,
    pub excretion_pathways: Vec<string>,
    pub assumptions: Vec<string>,
    pub virtual_population: VirtualPopulation,
    pub simulation_design: SimulationDesign,
    pub verification_studies: Vec<ClinicalStudy>,
    pub sensitivity_analysis: SensitivityAnalysis,
    pub limitations: Vec<string>,
    pub references: Vec<string>,
}

// =============================================================================
// EMA Qualification Report
// =============================================================================

/// EMA-compliant qualification report
pub struct EmaQualificationReport {
    /// Platform qualification
    pub platform_qualification: PlatformQualification,

    /// Model qualification for intended use
    pub model_qualification: ModelQualification,

    /// Supporting evidence
    pub supporting_evidence: Vec<SupportingEvidence>,

    /// Qualification opinion
    pub qualification_opinion: QualificationOpinion,
}

pub struct PlatformQualification {
    pub platform: string,
    pub version: string,
    pub qualification_date: string,
    pub intended_uses: Vec<EmaIntendedUse>,
    pub chmp_opinion: Option<string>,
}

pub struct ModelQualification {
    pub model_id: string,
    pub drug_name: string,
    pub intended_use: EmaIntendedUse,
    pub impact_level: EmaImpactLevel,
    pub verification_status: VerificationStatus,
}

pub enum VerificationStatus {
    Verified { studies: Vec<string>, metrics: ValidationMetrics },
    PartiallyVerified { verified_aspects: Vec<string>, gaps: Vec<string> },
    NotVerified { reason: string },
}

pub struct SupportingEvidence {
    pub evidence_type: EvidenceType,
    pub description: string,
    pub strength: EvidenceStrength,
}

pub enum EvidenceType {
    InVitroData,
    ClinicalPK,
    DDIStudy,
    SpecialPopulation,
    LiteratureData,
}

pub enum EvidenceStrength {
    Strong,
    Moderate,
    Weak,
}

pub enum QualificationOpinion {
    Qualified,
    ConditionallyQualified { conditions: Vec<string> },
    NotQualified { reasons: Vec<string> },
    PendingCHMP,
}

// =============================================================================
// Validation Functions with Epistemic Requirements
// =============================================================================

/// Validate model for FDA submission
/// REQUIRES: All parameters have ε >= impact-appropriate threshold
pub fn validate_for_fda_submission(
    predictions: &[Knowledge[f64, ε >= 0.75]],
    observed: &[f64],
    intended_use: &EmaIntendedUse,
) -> Result<ValidationMetrics, ValidationError> with IO {

    let impact_level = EmaImpactLevel::from_intended_use(intended_use);
    let criteria = impact_level.acceptance_criteria();

    // Check confidence requirements
    for (i, pred) in predictions.iter().enumerate() {
        if pred.confidence < criteria.min_confidence {
            return Err(ValidationError::InsufficientConfidence {
                index: i,
                required: criteria.min_confidence,
                actual: pred.confidence,
            });
        }
    }

    // Calculate metrics
    let pred_values: Vec<f64> = predictions.iter().map(|p| p.value).collect();
    let metrics = ValidationMetrics::calculate(&pred_values, observed)?;

    // Check acceptance criteria
    if metrics.gmfe > criteria.gmfe_max {
        return Err(ValidationError::AcceptanceCriteriaFailed {
            metric: "GMFE",
            required: criteria.gmfe_max,
            actual: metrics.gmfe,
        });
    }

    if metrics.within_2fold < criteria.within_2fold_min {
        return Err(ValidationError::AcceptanceCriteriaFailed {
            metric: "Within 2-fold",
            required: criteria.within_2fold_min,
            actual: metrics.within_2fold,
        });
    }

    Ok(metrics)
}

/// Validate DDI predictions per FDA guidance
pub fn validate_ddi_predictions(
    pred_auc_ratios: &[Knowledge[f64, ε >= 0.80]],
    obs_auc_ratios: &[f64],
    pred_cmax_ratios: &[Knowledge[f64, ε >= 0.80]],
    obs_cmax_ratios: &[f64],
) -> Result<ValidationMetrics, ValidationError> {

    let pred_auc: Vec<f64> = pred_auc_ratios.iter().map(|p| p.value).collect();
    let pred_cmax: Vec<f64> = pred_cmax_ratios.iter().map(|p| p.value).collect();

    let mut metrics = ValidationMetrics::calculate(&pred_auc, obs_auc_ratios)?;
    metrics = metrics.with_ddi_metrics(&pred_auc, obs_auc_ratios, &pred_cmax, obs_cmax_ratios);

    // DDI-specific criteria (FDA)
    // AUC ratio: AFE 0.8-1.25, AAFE < 2.0
    // Cmax ratio: Similar criteria
    if let Some(afe) = metrics.auc_ratio_afe {
        if afe < 0.8 || afe > 1.25 {
            return Err(ValidationError::DDICriteriaFailed {
                metric: "AUC ratio AFE",
                value: afe,
                acceptable_range: (0.8, 1.25),
            });
        }
    }

    Ok(metrics)
}

// =============================================================================
// Error Types
// =============================================================================

pub enum ValidationError {
    DataMismatch {
        expected: usize,
        actual: usize,
    },
    InsufficientConfidence {
        index: usize,
        required: f64,
        actual: f64,
    },
    AcceptanceCriteriaFailed {
        metric: &'static str,
        required: f64,
        actual: f64,
    },
    DDICriteriaFailed {
        metric: &'static str,
        value: f64,
        acceptable_range: (f64, f64),
    },
    MissingProvenance {
        parameter: string,
    },
}

// =============================================================================
// Helper Functions
// =============================================================================

fn derive_conclusions(metrics: &ValidationMetrics, status: &QualificationStatus) -> Vec<string> {
    let mut conclusions = vec![
        format!("GMFE: {:.2}", metrics.gmfe),
        format!("AFE: {:.2} (bias)", metrics.afe),
        format!("AAFE: {:.2} (precision)", metrics.aafe),
        format!("Within 2-fold: {:.1}%", metrics.within_2fold * 100.0),
    ];

    match status {
        QualificationStatus::Qualified { confidence } => {
            conclusions.push(format!("Model QUALIFIED with {:.1}% confidence", confidence * 100.0));
        }
        QualificationStatus::ConditionallyQualified { limitations } => {
            conclusions.push("Model CONDITIONALLY QUALIFIED".to_string());
            conclusions.extend(limitations.clone());
        }
        QualificationStatus::NotQualified { reasons } => {
            conclusions.push("Model NOT QUALIFIED".to_string());
            conclusions.extend(reasons.clone());
        }
    }

    conclusions
}

fn describe_regulatory_impact(level: &EmaImpactLevel) -> string {
    match level {
        EmaImpactLevel::Low =>
            "Low impact: Model supports mechanistic understanding".to_string(),
        EmaImpactLevel::Medium =>
            "Medium impact: Model contributes evidence with clinical data".to_string(),
        EmaImpactLevel::High =>
            "High impact: Model is key evidence for regulatory decision".to_string(),
    }
}

fn interpolate_at_time(result: &SimulationResult, time: f64) -> f64 {
    // Linear interpolation
    let idx = result.times.iter()
        .position(|t| *t >= time)
        .unwrap_or(result.times.len() - 1);

    if idx == 0 {
        return result.concentrations[0][0].value;
    }

    let t0 = result.times[idx - 1];
    let t1 = result.times[idx];
    let c0 = result.concentrations[idx - 1][0].value;
    let c1 = result.concentrations[idx][0].value;

    let frac = (time - t0) / (t1 - t0);
    c0 + frac * (c1 - c0)
}

fn extract_drug_parameters(drug: &Drug, params: &PBPKParams) -> Vec<DrugParameter> {
    vec![
        DrugParameter {
            name: "Molecular Weight".to_string(),
            value: drug.mw,
            unit: "g/mol".to_string(),
            source: drug.chebi_id.clone(),
            confidence: 0.99,
            method: "Calculated".to_string(),
        },
        DrugParameter {
            name: "LogP".to_string(),
            value: drug.logp,
            unit: "".to_string(),
            source: "Experimental".to_string(),
            confidence: 0.95,
            method: "Measured".to_string(),
        },
        DrugParameter {
            name: "Fraction Unbound".to_string(),
            value: drug.fu.value,
            unit: "".to_string(),
            source: drug.fu.provenance.to_string(),
            confidence: drug.fu.confidence,
            method: "In vitro".to_string(),
        },
        DrugParameter {
            name: "Hepatic Clearance".to_string(),
            value: params.cl_hepatic.value,
            unit: "L/h".to_string(),
            source: params.cl_hepatic.provenance.to_string(),
            confidence: params.cl_hepatic.confidence,
            method: "Population PK".to_string(),
        },
        DrugParameter {
            name: "Renal Clearance".to_string(),
            value: params.cl_renal.value,
            unit: "L/h".to_string(),
            source: params.cl_renal.provenance.to_string(),
            confidence: params.cl_renal.confidence,
            method: "Clinical".to_string(),
        },
        DrugParameter {
            name: "Volume of Distribution".to_string(),
            value: params.vd.value,
            unit: "L".to_string(),
            source: params.vd.provenance.to_string(),
            confidence: params.vd.confidence,
            method: "Population PK".to_string(),
        },
        DrugParameter {
            name: "Absorption Rate".to_string(),
            value: params.ka.value,
            unit: "1/h".to_string(),
            source: params.ka.provenance.to_string(),
            confidence: params.ka.confidence,
            method: "Population PK".to_string(),
        },
    ]
}

fn default_system_parameters() -> Vec<SystemParameter> {
    vec![
        SystemParameter {
            name: "Cardiac Output".to_string(),
            value: 348.0,
            unit: "L/h".to_string(),
            population: "Adult".to_string(),
            source: "Literature".to_string(),
        },
        SystemParameter {
            name: "Liver Blood Flow".to_string(),
            value: 90.0,
            unit: "L/h".to_string(),
            population: "Adult".to_string(),
            source: "Literature".to_string(),
        },
        SystemParameter {
            name: "GFR".to_string(),
            value: 7.2,
            unit: "L/h".to_string(),
            population: "Adult".to_string(),
            source: "Literature".to_string(),
        },
    ]
}

// =============================================================================
// Tests
// =============================================================================

#[test]
fn test_validation_metrics() {
    let predicted = [1.0, 2.0, 3.0, 4.0, 5.0];
    let observed = [1.1, 1.9, 3.2, 3.8, 5.1];

    let metrics = ValidationMetrics::calculate(&predicted, &observed).unwrap();

    assert!(metrics.gmfe < 1.1);
    assert!(metrics.within_2fold >= 1.0);
    assert!(metrics.afe > 0.9 && metrics.afe < 1.1);
}

#[test]
fn test_ema_impact_levels() {
    let high = EmaImpactLevel::from_intended_use(&EmaIntendedUse::WaiveClinicalStudy);
    let criteria = high.acceptance_criteria();

    assert!(criteria.gmfe_max <= 1.5);
    assert!(criteria.within_2fold_min >= 0.90);
}

#[test]
fn test_acceptance_criteria() {
    let criteria = EmaImpactLevel::Medium.acceptance_criteria();

    assert_eq!(criteria.gmfe_max, 2.0);
    assert_eq!(criteria.within_2fold_min, 0.80);
}
