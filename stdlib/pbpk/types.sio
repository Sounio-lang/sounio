// types.d - MedLang-compatible PK/PD Domain Types for Sounio
//
// These struct definitions provide semantic meaning to physical quantities,
// making pharmacokinetic code more readable and self-documenting.
//
// Inspired by MedLang DSL (github.com/agourakis82/medlang)
// Adapted for Sounio type system.
//
// Reference: Track D Pharmacometrics QSP Specification
//
// Module: pbpk::types (for future module system)
//
// NOTE: When Sounio supports type aliases and units, this file
// should be updated to use proper `type` and `unit` definitions.

// =============================================================================
// MATH HELPERS
// =============================================================================

fn abs_f64(x: f64) -> f64 {
    if x < 0.0 { return 0.0 - x }
    return x
}

// =============================================================================
// WRAPPER TYPES FOR TYPE SAFETY
// =============================================================================
// These structs wrap f64 values with semantic meaning.
// In the future, these will be replaced by proper type aliases with units.

// Amount types - drug mass in compartments
struct DoseMass { value: f64 }        // Amount in mg
struct DrugAmount { value: f64 }      // Drug quantity in mg

// Volume types
struct VolumeL { value: f64 }         // Volume in L
struct PlasmaVolume { value: f64 }    // Plasma volume in L
struct TissueVolume { value: f64 }    // Tissue volume in L

// Concentration types - mass per volume
struct Concentration { value: f64 }   // Concentration in mg/L
struct PlasmaConc { value: f64 }      // Plasma concentration in mg/L
struct TissueConc { value: f64 }      // Tissue concentration in mg/L

// Clearance types - volume per time
struct Clearance { value: f64 }       // Clearance in L/h
struct HepaticClearance { value: f64 }// Liver clearance in L/h
struct RenalClearance { value: f64 }  // Kidney clearance in L/h

// Flow types - volume per time
struct BloodFlow { value: f64 }       // Blood flow in L/h
struct CardiacOutput { value: f64 }   // Total CO in L/h

// Rate constant types - inverse time
struct RateConst { value: f64 }       // Rate constant in 1/h
struct AbsorptionRate { value: f64 }  // Ka in 1/h
struct EliminationRate { value: f64 } // Ke in 1/h

// Time types
struct TimeH { value: f64 }           // Time in hours
struct HalfLife { value: f64 }        // Half-life in hours

// Body measurements
struct BodyWeight { value: f64 }      // Weight in kg
struct BodyHeight { value: f64 }      // Height in cm
struct Age { value: f64 }             // Age in years

// Renal function
struct CreatinineClearance { value: f64 }  // CrCL in mL/min
struct GFR { value: f64 }                  // GFR in mL/min
struct SerumCreatinine { value: f64 }      // SCr in mg/dL

// =============================================================================
// CONSTRUCTORS
// =============================================================================

fn dose_mg(value: f64) -> DoseMass {
    return DoseMass { value: value }
}

fn volume_L(value: f64) -> VolumeL {
    return VolumeL { value: value }
}

fn conc_mg_per_L(value: f64) -> Concentration {
    return Concentration { value: value }
}

fn clearance_L_per_h(value: f64) -> Clearance {
    return Clearance { value: value }
}

fn rate_per_h(value: f64) -> RateConst {
    return RateConst { value: value }
}

fn time_h(value: f64) -> TimeH {
    return TimeH { value: value }
}

fn weight_kg(value: f64) -> BodyWeight {
    return BodyWeight { value: value }
}

// =============================================================================
// HELPER FUNCTIONS FOR TYPE CONVERSIONS
// =============================================================================

// Convert clearance from L/h to mL/min
fn L_per_h_to_mL_per_min(cl: f64) -> f64 {
    // 1 L/h = 1000 mL / 60 min = 16.667 mL/min
    return cl * 16.667
}

// Convert mL/min to L/h
fn mL_per_min_to_L_per_h(cl: f64) -> f64 {
    // 1 mL/min = 0.06 L/h
    return cl * 0.06
}

// Calculate half-life from elimination rate constant
fn rate_to_halflife(ke: f64) -> f64 {
    let ln2 = 0.693147180559945
    return ln2 / ke
}

// Calculate elimination rate from half-life
fn halflife_to_rate(t_half: f64) -> f64 {
    let ln2 = 0.693147180559945
    return ln2 / t_half
}

// =============================================================================
// VALIDATION CONSTRAINTS
// =============================================================================

// Check if a fraction is in valid range [0, 1]
fn is_valid_fraction(f: f64) -> bool {
    if f < 0.0 { return false }
    if f > 1.0 { return false }
    return true
}

// Check if clearance is physiologically plausible
// Human liver blood flow ~90 L/h, total CO ~348 L/h
fn is_plausible_clearance(cl: f64) -> bool {
    if cl < 0.0 { return false }
    if cl > 500.0 { return false }
    return true
}

// Check if volume is physiologically plausible
// Adult human total body water ~42L, Vd can be much higher for lipophilic drugs
fn is_plausible_volume(v: f64) -> bool {
    if v < 0.0 { return false }
    if v > 10000.0 { return false }
    return true
}

// Check if rate constant is reasonable (t1/2 between 1 min and 1 year)
fn is_plausible_rate(k: f64) -> bool {
    // t1/2 = ln2/k, so k between 0.693/8760 and 0.693*60
    if k < 0.0000791 { return false }
    if k > 41.6 { return false }
    return true
}

// =============================================================================
// TESTS
// =============================================================================

fn main() -> i32 {
    println("=== PK Types Tests ===")
    println("")

    // Test 1: Clearance conversion
    println("Test 1: Clearance conversion")
    let cl_L_h = 10.0  // 10 L/h
    let cl_mL_min = L_per_h_to_mL_per_min(cl_L_h)
    println("  10 L/h = mL/min:")
    println(cl_mL_min)
    // 10 L/h = 166.67 mL/min
    let expected = 166.67
    let err1 = abs_f64(cl_mL_min - expected)
    println("")

    // Test 2: Half-life conversion
    println("Test 2: Half-life conversion")
    let ke = 0.1  // 0.1 per hour
    let t_half = rate_to_halflife(ke)
    println("  ke=0.1/h -> t1/2 (h):")
    println(t_half)
    // t1/2 = 0.693/0.1 = 6.93 h
    let expected_half = 6.93
    let err2 = abs_f64(t_half - expected_half)
    println("")

    // Test 3: Round-trip conversion
    println("Test 3: Rate -> HalfLife -> Rate")
    let ke_orig = 0.2
    let t_half_2 = rate_to_halflife(ke_orig)
    let ke_back = halflife_to_rate(t_half_2)
    println("  Original ke: 0.2")
    println("  Recovered ke:")
    println(ke_back)
    let err3 = abs_f64(ke_back - ke_orig)
    println("")

    // Test 4: Validation functions
    println("Test 4: Validation functions")
    let frac_valid = is_valid_fraction(0.5)
    let frac_invalid = is_valid_fraction(1.5)
    let cl_valid = is_plausible_clearance(10.0)
    let cl_invalid = is_plausible_clearance(1000.0)

    println("  is_valid_fraction(0.5):")
    println(frac_valid)
    println("  is_valid_fraction(1.5):")
    println(frac_invalid)
    println("  is_plausible_clearance(10):")
    println(cl_valid)
    println("  is_plausible_clearance(1000):")
    println(cl_invalid)
    println("")

    // Validation (use nested ifs instead of &&)
    if err1 < 1.0 {
        if err2 < 0.1 {
            if err3 < 0.001 {
                if frac_valid {
                    if cl_valid {
                        println("ALL TESTS PASSED")
                        return 0
                    }
                }
            }
        }
    }

    println("TESTS FAILED")
    println("  err1:")
    println(err1)
    println("  err2:")
    println(err2)
    println("  err3:")
    println(err3)
    return 1
}
