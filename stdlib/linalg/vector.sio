// vector.d - Fixed-size vector types for Sounio linear algebra
//
// Provides small vector types (Vec2, Vec3, Vec4) and operations commonly
// needed in scientific computing: addition, scaling, dot product, norms.
//
// These are stack-allocated, Copy types optimized for SIMD operations.

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn abs_val(x: f64) -> f64 {
    if x < 0.0 {
        return 0.0 - x
    }
    return x
}

fn max_val(a: f64, b: f64) -> f64 {
    if a > b { return a }
    return b
}

fn min_val(a: f64, b: f64) -> f64 {
    if a < b { return a }
    return b
}

// Square root via Newton-Raphson (10 iterations)
fn sqrt_val(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    let mut y = x
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    return y
}

// ============================================================================
// VEC2 - 2-ELEMENT VECTOR
// ============================================================================

struct Vec2 {
    x: f64,
    y: f64
}

fn vec2_new(x: f64, y: f64) -> Vec2 {
    return Vec2 { x: x, y: y }
}

fn vec2_zero() -> Vec2 {
    return Vec2 { x: 0.0, y: 0.0 }
}

fn vec2_ones() -> Vec2 {
    return Vec2 { x: 1.0, y: 1.0 }
}

fn vec2_add(a: Vec2, b: Vec2) -> Vec2 {
    return Vec2 { x: a.x + b.x, y: a.y + b.y }
}

fn vec2_sub(a: Vec2, b: Vec2) -> Vec2 {
    return Vec2 { x: a.x - b.x, y: a.y - b.y }
}

fn vec2_scale(v: Vec2, s: f64) -> Vec2 {
    return Vec2 { x: v.x * s, y: v.y * s }
}

fn vec2_neg(v: Vec2) -> Vec2 {
    return Vec2 { x: 0.0 - v.x, y: 0.0 - v.y }
}

fn vec2_dot(a: Vec2, b: Vec2) -> f64 {
    return a.x * b.x + a.y * b.y
}

fn vec2_norm_sq(v: Vec2) -> f64 {
    return v.x * v.x + v.y * v.y
}

fn vec2_norm(v: Vec2) -> f64 {
    return sqrt_val(vec2_norm_sq(v))
}

fn vec2_normalize(v: Vec2) -> Vec2 {
    let n = vec2_norm(v)
    if n < 0.0000000001 {
        return vec2_zero()
    }
    return vec2_scale(v, 1.0 / n)
}

fn vec2_hadamard(a: Vec2, b: Vec2) -> Vec2 {
    return Vec2 { x: a.x * b.x, y: a.y * b.y }
}

fn vec2_max(a: Vec2, b: Vec2) -> Vec2 {
    return Vec2 { x: max_val(a.x, b.x), y: max_val(a.y, b.y) }
}

fn vec2_min(a: Vec2, b: Vec2) -> Vec2 {
    return Vec2 { x: min_val(a.x, b.x), y: min_val(a.y, b.y) }
}

fn vec2_abs(v: Vec2) -> Vec2 {
    return Vec2 { x: abs_val(v.x), y: abs_val(v.y) }
}

fn vec2_max_component(v: Vec2) -> f64 {
    return max_val(v.x, v.y)
}

fn vec2_sum(v: Vec2) -> f64 {
    return v.x + v.y
}

// ============================================================================
// VEC3 - 3-ELEMENT VECTOR
// ============================================================================

struct Vec3 {
    x: f64,
    y: f64,
    z: f64
}

fn vec3_new(x: f64, y: f64, z: f64) -> Vec3 {
    return Vec3 { x: x, y: y, z: z }
}

fn vec3_zero() -> Vec3 {
    return Vec3 { x: 0.0, y: 0.0, z: 0.0 }
}

fn vec3_ones() -> Vec3 {
    return Vec3 { x: 1.0, y: 1.0, z: 1.0 }
}

fn vec3_add(a: Vec3, b: Vec3) -> Vec3 {
    return Vec3 { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z }
}

fn vec3_sub(a: Vec3, b: Vec3) -> Vec3 {
    return Vec3 { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }
}

fn vec3_scale(v: Vec3, s: f64) -> Vec3 {
    return Vec3 { x: v.x * s, y: v.y * s, z: v.z * s }
}

fn vec3_neg(v: Vec3) -> Vec3 {
    return Vec3 { x: 0.0 - v.x, y: 0.0 - v.y, z: 0.0 - v.z }
}

fn vec3_dot(a: Vec3, b: Vec3) -> f64 {
    return a.x * b.x + a.y * b.y + a.z * b.z
}

fn vec3_cross(a: Vec3, b: Vec3) -> Vec3 {
    return Vec3 {
        x: a.y * b.z - a.z * b.y,
        y: a.z * b.x - a.x * b.z,
        z: a.x * b.y - a.y * b.x
    }
}

fn vec3_norm_sq(v: Vec3) -> f64 {
    return v.x * v.x + v.y * v.y + v.z * v.z
}

fn vec3_norm(v: Vec3) -> f64 {
    return sqrt_val(vec3_norm_sq(v))
}

fn vec3_normalize(v: Vec3) -> Vec3 {
    let n = vec3_norm(v)
    if n < 0.0000000001 {
        return vec3_zero()
    }
    return vec3_scale(v, 1.0 / n)
}

fn vec3_hadamard(a: Vec3, b: Vec3) -> Vec3 {
    return Vec3 { x: a.x * b.x, y: a.y * b.y, z: a.z * b.z }
}

fn vec3_max(a: Vec3, b: Vec3) -> Vec3 {
    return Vec3 { x: max_val(a.x, b.x), y: max_val(a.y, b.y), z: max_val(a.z, b.z) }
}

fn vec3_min(a: Vec3, b: Vec3) -> Vec3 {
    return Vec3 { x: min_val(a.x, b.x), y: min_val(a.y, b.y), z: min_val(a.z, b.z) }
}

fn vec3_abs(v: Vec3) -> Vec3 {
    return Vec3 { x: abs_val(v.x), y: abs_val(v.y), z: abs_val(v.z) }
}

fn vec3_max_component(v: Vec3) -> f64 {
    return max_val(max_val(v.x, v.y), v.z)
}

fn vec3_sum(v: Vec3) -> f64 {
    return v.x + v.y + v.z
}

// ============================================================================
// VEC4 - 4-ELEMENT VECTOR
// ============================================================================

struct Vec4 {
    x: f64,
    y: f64,
    z: f64,
    w: f64
}

fn vec4_new(x: f64, y: f64, z: f64, w: f64) -> Vec4 {
    return Vec4 { x: x, y: y, z: z, w: w }
}

fn vec4_zero() -> Vec4 {
    return Vec4 { x: 0.0, y: 0.0, z: 0.0, w: 0.0 }
}

fn vec4_ones() -> Vec4 {
    return Vec4 { x: 1.0, y: 1.0, z: 1.0, w: 1.0 }
}

fn vec4_add(a: Vec4, b: Vec4) -> Vec4 {
    return Vec4 { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z, w: a.w + b.w }
}

fn vec4_sub(a: Vec4, b: Vec4) -> Vec4 {
    return Vec4 { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z, w: a.w - b.w }
}

fn vec4_scale(v: Vec4, s: f64) -> Vec4 {
    return Vec4 { x: v.x * s, y: v.y * s, z: v.z * s, w: v.w * s }
}

fn vec4_neg(v: Vec4) -> Vec4 {
    return Vec4 { x: 0.0 - v.x, y: 0.0 - v.y, z: 0.0 - v.z, w: 0.0 - v.w }
}

fn vec4_dot(a: Vec4, b: Vec4) -> f64 {
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
}

fn vec4_norm_sq(v: Vec4) -> f64 {
    return v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w
}

fn vec4_norm(v: Vec4) -> f64 {
    return sqrt_val(vec4_norm_sq(v))
}

fn vec4_normalize(v: Vec4) -> Vec4 {
    let n = vec4_norm(v)
    if n < 0.0000000001 {
        return vec4_zero()
    }
    return vec4_scale(v, 1.0 / n)
}

fn vec4_hadamard(a: Vec4, b: Vec4) -> Vec4 {
    return Vec4 { x: a.x * b.x, y: a.y * b.y, z: a.z * b.z, w: a.w * b.w }
}

fn vec4_max(a: Vec4, b: Vec4) -> Vec4 {
    return Vec4 {
        x: max_val(a.x, b.x),
        y: max_val(a.y, b.y),
        z: max_val(a.z, b.z),
        w: max_val(a.w, b.w)
    }
}

fn vec4_min(a: Vec4, b: Vec4) -> Vec4 {
    return Vec4 {
        x: min_val(a.x, b.x),
        y: min_val(a.y, b.y),
        z: min_val(a.z, b.z),
        w: min_val(a.w, b.w)
    }
}

fn vec4_abs(v: Vec4) -> Vec4 {
    return Vec4 { x: abs_val(v.x), y: abs_val(v.y), z: abs_val(v.z), w: abs_val(v.w) }
}

fn vec4_max_component(v: Vec4) -> f64 {
    return max_val(max_val(v.x, v.y), max_val(v.z, v.w))
}

fn vec4_sum(v: Vec4) -> f64 {
    return v.x + v.y + v.z + v.w
}

// ============================================================================
// VEC14 - 14-ELEMENT VECTOR (FOR PBPK COMPARTMENTS)
// ============================================================================

struct Vec14 {
    c0: f64, c1: f64, c2: f64, c3: f64, c4: f64,
    c5: f64, c6: f64, c7: f64, c8: f64, c9: f64,
    c10: f64, c11: f64, c12: f64, c13: f64
}

fn vec14_new(
    v0: f64, v1: f64, v2: f64, v3: f64, v4: f64,
    v5: f64, v6: f64, v7: f64, v8: f64, v9: f64,
    v10: f64, v11: f64, v12: f64, v13: f64
) -> Vec14 {
    return Vec14 {
        c0: v0, c1: v1, c2: v2, c3: v3, c4: v4,
        c5: v5, c6: v6, c7: v7, c8: v8, c9: v9,
        c10: v10, c11: v11, c12: v12, c13: v13
    }
}

fn vec14_zero() -> Vec14 {
    return Vec14 {
        c0: 0.0, c1: 0.0, c2: 0.0, c3: 0.0, c4: 0.0,
        c5: 0.0, c6: 0.0, c7: 0.0, c8: 0.0, c9: 0.0,
        c10: 0.0, c11: 0.0, c12: 0.0, c13: 0.0
    }
}

fn vec14_ones() -> Vec14 {
    return Vec14 {
        c0: 1.0, c1: 1.0, c2: 1.0, c3: 1.0, c4: 1.0,
        c5: 1.0, c6: 1.0, c7: 1.0, c8: 1.0, c9: 1.0,
        c10: 1.0, c11: 1.0, c12: 1.0, c13: 1.0
    }
}

fn vec14_add(a: Vec14, b: Vec14) -> Vec14 {
    return Vec14 {
        c0: a.c0 + b.c0, c1: a.c1 + b.c1, c2: a.c2 + b.c2, c3: a.c3 + b.c3, c4: a.c4 + b.c4,
        c5: a.c5 + b.c5, c6: a.c6 + b.c6, c7: a.c7 + b.c7, c8: a.c8 + b.c8, c9: a.c9 + b.c9,
        c10: a.c10 + b.c10, c11: a.c11 + b.c11, c12: a.c12 + b.c12, c13: a.c13 + b.c13
    }
}

fn vec14_sub(a: Vec14, b: Vec14) -> Vec14 {
    return Vec14 {
        c0: a.c0 - b.c0, c1: a.c1 - b.c1, c2: a.c2 - b.c2, c3: a.c3 - b.c3, c4: a.c4 - b.c4,
        c5: a.c5 - b.c5, c6: a.c6 - b.c6, c7: a.c7 - b.c7, c8: a.c8 - b.c8, c9: a.c9 - b.c9,
        c10: a.c10 - b.c10, c11: a.c11 - b.c11, c12: a.c12 - b.c12, c13: a.c13 - b.c13
    }
}

fn vec14_scale(v: Vec14, s: f64) -> Vec14 {
    return Vec14 {
        c0: v.c0 * s, c1: v.c1 * s, c2: v.c2 * s, c3: v.c3 * s, c4: v.c4 * s,
        c5: v.c5 * s, c6: v.c6 * s, c7: v.c7 * s, c8: v.c8 * s, c9: v.c9 * s,
        c10: v.c10 * s, c11: v.c11 * s, c12: v.c12 * s, c13: v.c13 * s
    }
}

fn vec14_neg(v: Vec14) -> Vec14 {
    return Vec14 {
        c0: 0.0 - v.c0, c1: 0.0 - v.c1, c2: 0.0 - v.c2, c3: 0.0 - v.c3, c4: 0.0 - v.c4,
        c5: 0.0 - v.c5, c6: 0.0 - v.c6, c7: 0.0 - v.c7, c8: 0.0 - v.c8, c9: 0.0 - v.c9,
        c10: 0.0 - v.c10, c11: 0.0 - v.c11, c12: 0.0 - v.c12, c13: 0.0 - v.c13
    }
}

fn vec14_dot(a: Vec14, b: Vec14) -> f64 {
    return a.c0 * b.c0 + a.c1 * b.c1 + a.c2 * b.c2 + a.c3 * b.c3 + a.c4 * b.c4
         + a.c5 * b.c5 + a.c6 * b.c6 + a.c7 * b.c7 + a.c8 * b.c8 + a.c9 * b.c9
         + a.c10 * b.c10 + a.c11 * b.c11 + a.c12 * b.c12 + a.c13 * b.c13
}

fn vec14_norm_sq(v: Vec14) -> f64 {
    return vec14_dot(v, v)
}

fn vec14_norm(v: Vec14) -> f64 {
    return sqrt_val(vec14_norm_sq(v))
}

fn vec14_sum(v: Vec14) -> f64 {
    return v.c0 + v.c1 + v.c2 + v.c3 + v.c4 + v.c5 + v.c6
         + v.c7 + v.c8 + v.c9 + v.c10 + v.c11 + v.c12 + v.c13
}

fn vec14_hadamard(a: Vec14, b: Vec14) -> Vec14 {
    return Vec14 {
        c0: a.c0 * b.c0, c1: a.c1 * b.c1, c2: a.c2 * b.c2, c3: a.c3 * b.c3, c4: a.c4 * b.c4,
        c5: a.c5 * b.c5, c6: a.c6 * b.c6, c7: a.c7 * b.c7, c8: a.c8 * b.c8, c9: a.c9 * b.c9,
        c10: a.c10 * b.c10, c11: a.c11 * b.c11, c12: a.c12 * b.c12, c13: a.c13 * b.c13
    }
}

fn vec14_abs(v: Vec14) -> Vec14 {
    return Vec14 {
        c0: abs_val(v.c0), c1: abs_val(v.c1), c2: abs_val(v.c2), c3: abs_val(v.c3), c4: abs_val(v.c4),
        c5: abs_val(v.c5), c6: abs_val(v.c6), c7: abs_val(v.c7), c8: abs_val(v.c8), c9: abs_val(v.c9),
        c10: abs_val(v.c10), c11: abs_val(v.c11), c12: abs_val(v.c12), c13: abs_val(v.c13)
    }
}

fn vec14_max(a: Vec14, b: Vec14) -> Vec14 {
    return Vec14 {
        c0: max_val(a.c0, b.c0), c1: max_val(a.c1, b.c1), c2: max_val(a.c2, b.c2),
        c3: max_val(a.c3, b.c3), c4: max_val(a.c4, b.c4), c5: max_val(a.c5, b.c5),
        c6: max_val(a.c6, b.c6), c7: max_val(a.c7, b.c7), c8: max_val(a.c8, b.c8),
        c9: max_val(a.c9, b.c9), c10: max_val(a.c10, b.c10), c11: max_val(a.c11, b.c11),
        c12: max_val(a.c12, b.c12), c13: max_val(a.c13, b.c13)
    }
}

// RMS norm for ODE error estimation (weighted)
fn vec14_rms_weighted(err: Vec14, scale: Vec14) -> f64 {
    let e0 = err.c0 / scale.c0
    let e1 = err.c1 / scale.c1
    let e2 = err.c2 / scale.c2
    let e3 = err.c3 / scale.c3
    let e4 = err.c4 / scale.c4
    let e5 = err.c5 / scale.c5
    let e6 = err.c6 / scale.c6
    let e7 = err.c7 / scale.c7
    let e8 = err.c8 / scale.c8
    let e9 = err.c9 / scale.c9
    let e10 = err.c10 / scale.c10
    let e11 = err.c11 / scale.c11
    let e12 = err.c12 / scale.c12
    let e13 = err.c13 / scale.c13
    let sum_sq = e0*e0 + e1*e1 + e2*e2 + e3*e3 + e4*e4 + e5*e5 + e6*e6
               + e7*e7 + e8*e8 + e9*e9 + e10*e10 + e11*e11 + e12*e12 + e13*e13
    return sqrt_val(sum_sq / 14.0)
}

// ============================================================================
// TESTS
// ============================================================================

fn main() -> i32 {
    println("=== Sounio Vector Types Test ===")
    println("")

    // Test Vec3
    println("Testing Vec3:")
    let v1 = vec3_new(1.0, 2.0, 3.0)
    let v2 = vec3_new(4.0, 5.0, 6.0)

    let v_add = vec3_add(v1, v2)
    println("  v1 + v2 = ")
    println(v_add.x)
    println(v_add.y)
    println(v_add.z)

    let dot = vec3_dot(v1, v2)
    println("  v1 . v2 = ")
    println(dot)

    let norm1 = vec3_norm(v1)
    println("  |v1| = ")
    println(norm1)

    let cross = vec3_cross(v1, v2)
    println("  v1 x v2 = ")
    println(cross.x)
    println(cross.y)
    println(cross.z)
    println("")

    // Test Vec14 for PBPK
    println("Testing Vec14 (PBPK compartments):")
    let pbpk_state = vec14_new(100.0, 50.0, 25.0, 12.5, 6.25, 3.125, 1.5625, 0.78125,
                               0.39, 0.195, 0.0975, 0.04875, 0.024375, 0.0121875)
    let total = vec14_sum(pbpk_state)
    println("  Total drug mass = ")
    println(total)

    let norm14 = vec14_norm(pbpk_state)
    println("  |pbpk_state| = ")
    println(norm14)

    // Test RMS error norm
    let err = vec14_new(0.001, 0.002, 0.001, 0.0005, 0.0003, 0.0002, 0.0001, 0.0001,
                        0.00005, 0.00003, 0.00002, 0.00001, 0.000005, 0.000003)
    let scale = vec14_ones()
    let rms = vec14_rms_weighted(err, scale)
    println("  RMS error = ")
    println(rms)
    println("")

    // Verify expected values
    // dot(v1, v2) = 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32
    let dot_expected = 32.0
    let dot_err = abs_val(dot - dot_expected)

    // |v1| = sqrt(1 + 4 + 9) = sqrt(14) â‰ˆ 3.7417
    let norm_expected = 3.7416573867739413
    let norm_err = abs_val(norm1 - norm_expected)

    // Cross product: (2*6-3*5, 3*4-1*6, 1*5-2*4) = (12-15, 12-6, 5-8) = (-3, 6, -3)
    let cross_expected_x = 0.0 - 3.0
    let cross_expected_y = 6.0
    let cross_expected_z = 0.0 - 3.0
    let cross_err = abs_val(cross.x - cross_expected_x) + abs_val(cross.y - cross_expected_y) + abs_val(cross.z - cross_expected_z)

    if dot_err < 0.0001 && norm_err < 0.0001 && cross_err < 0.0001 {
        println("TEST PASSED: All vector operations correct")
        return 0
    } else {
        println("TEST FAILED: Vector operation errors")
        println("  dot_err = ")
        println(dot_err)
        println("  norm_err = ")
        println(norm_err)
        println("  cross_err = ")
        println(cross_err)
        return 1
    }
}
