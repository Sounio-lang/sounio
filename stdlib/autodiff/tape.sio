// tape.d - Reverse-Mode Automatic Differentiation using Wengert Tape
//
// Reverse-mode AD is efficient for functions f: R^n -> R (many inputs, one output)
// which is common in machine learning (loss functions) and optimization.
//
// The algorithm:
// 1. Forward pass: compute values and record operations on a "tape"
// 2. Backward pass: traverse tape in reverse, accumulating gradients
//
// This implementation uses a fixed-size tape suitable for Sounio without
// dynamic allocation. Tape size is limited but sufficient for most ML uses.
//
// Reference: "Evaluating Derivatives" by Griewank & Walther

// ============================================================================
// TAPE CONFIGURATION
// ============================================================================

// Maximum number of nodes in computational graph (20 for basic ops)
fn max_tape_size() -> i64 { return 20 }

// Operation codes
fn op_const() -> i64 { return 0 }   // Constant input
fn op_var() -> i64 { return 1 }     // Variable input
fn op_add() -> i64 { return 2 }
fn op_sub() -> i64 { return 3 }
fn op_mul() -> i64 { return 4 }
fn op_div() -> i64 { return 5 }
fn op_neg() -> i64 { return 6 }
fn op_sqrt() -> i64 { return 7 }
fn op_exp() -> i64 { return 8 }
fn op_ln() -> i64 { return 9 }
fn op_sin() -> i64 { return 10 }
fn op_cos() -> i64 { return 11 }
fn op_tanh() -> i64 { return 12 }
fn op_pow() -> i64 { return 13 }
fn op_relu() -> i64 { return 14 }
fn op_sigmoid() -> i64 { return 15 }

// ============================================================================
// MATH HELPERS (same as dual.d)
// ============================================================================

fn abs_f64(x: f64) -> f64 {
    if x < 0.0 { return 0.0 - x }
    return x
}

fn sqrt_f64(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    let mut y = x
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    return y
}

fn exp_f64(x: f64) -> f64 {
    if x > 20.0 { return exp_f64(x / 2.0) * exp_f64(x / 2.0) }
    if x < 0.0 - 20.0 { return 1.0 / exp_f64(0.0 - x) }
    let mut sum = 1.0
    let mut term = 1.0
    term = term * x / 1.0
    sum = sum + term
    term = term * x / 2.0
    sum = sum + term
    term = term * x / 3.0
    sum = sum + term
    term = term * x / 4.0
    sum = sum + term
    term = term * x / 5.0
    sum = sum + term
    term = term * x / 6.0
    sum = sum + term
    term = term * x / 7.0
    sum = sum + term
    term = term * x / 8.0
    sum = sum + term
    term = term * x / 9.0
    sum = sum + term
    term = term * x / 10.0
    sum = sum + term
    term = term * x / 11.0
    sum = sum + term
    term = term * x / 12.0
    sum = sum + term
    term = term * x / 13.0
    sum = sum + term
    term = term * x / 14.0
    sum = sum + term
    term = term * x / 15.0
    sum = sum + term
    return sum
}

fn ln_f64(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 - 1000000.0 }
    let mut val = x
    let mut k = 0.0
    let e = 2.718281828459045
    while val > e {
        val = val / e
        k = k + 1.0
    }
    while val < 1.0 / e {
        val = val * e
        k = k - 1.0
    }
    let u = (val - 1.0) / (val + 1.0)
    let u2 = u * u
    let mut sum = u
    let mut term = u
    term = term * u2
    sum = sum + term / 3.0
    term = term * u2
    sum = sum + term / 5.0
    term = term * u2
    sum = sum + term / 7.0
    term = term * u2
    sum = sum + term / 9.0
    term = term * u2
    sum = sum + term / 11.0
    term = term * u2
    sum = sum + term / 13.0
    term = term * u2
    sum = sum + term / 15.0
    return 2.0 * sum + k
}

fn pow_f64(x: f64, n: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    return exp_f64(n * ln_f64(x))
}

fn sin_f64(x: f64) -> f64 {
    let pi = 3.141592653589793
    let mut y = x
    while y > pi { y = y - 2.0 * pi }
    while y < 0.0 - pi { y = y + 2.0 * pi }
    let x2 = y * y
    let mut sum = y
    let mut term = y
    term = term * (0.0 - x2) / (2.0 * 3.0)
    sum = sum + term
    term = term * (0.0 - x2) / (4.0 * 5.0)
    sum = sum + term
    term = term * (0.0 - x2) / (6.0 * 7.0)
    sum = sum + term
    term = term * (0.0 - x2) / (8.0 * 9.0)
    sum = sum + term
    term = term * (0.0 - x2) / (10.0 * 11.0)
    sum = sum + term
    return sum
}

fn cos_f64(x: f64) -> f64 {
    let pi = 3.141592653589793
    let mut y = x
    while y > pi { y = y - 2.0 * pi }
    while y < 0.0 - pi { y = y + 2.0 * pi }
    let x2 = y * y
    let mut sum = 1.0
    let mut term = 1.0
    term = term * (0.0 - x2) / (1.0 * 2.0)
    sum = sum + term
    term = term * (0.0 - x2) / (3.0 * 4.0)
    sum = sum + term
    term = term * (0.0 - x2) / (5.0 * 6.0)
    sum = sum + term
    term = term * (0.0 - x2) / (7.0 * 8.0)
    sum = sum + term
    term = term * (0.0 - x2) / (9.0 * 10.0)
    sum = sum + term
    return sum
}

fn tanh_f64(x: f64) -> f64 {
    let e2x = exp_f64(2.0 * x)
    return (e2x - 1.0) / (e2x + 1.0)
}

// ============================================================================
// TAPE NODE STRUCTURE
// ============================================================================

struct TapeNode {
    value: f64,      // Forward pass value
    adjoint: f64,    // Backward pass gradient (∂L/∂v)
    op: i64,         // Operation code
    parent1: i64,    // First parent index (-1 if none)
    parent2: i64,    // Second parent index (-1 if none)
    aux: f64         // Auxiliary data (e.g., exponent for pow)
}

// ============================================================================
// TAPE STRUCTURE (Fixed size - 20 nodes for basic operations)
// ============================================================================

struct Tape {
    // Node storage (fixed size - 20 nodes)
    n0: TapeNode, n1: TapeNode, n2: TapeNode, n3: TapeNode, n4: TapeNode,
    n5: TapeNode, n6: TapeNode, n7: TapeNode, n8: TapeNode, n9: TapeNode,
    n10: TapeNode, n11: TapeNode, n12: TapeNode, n13: TapeNode, n14: TapeNode,
    n15: TapeNode, n16: TapeNode, n17: TapeNode, n18: TapeNode, n19: TapeNode,
    size: i64        // Current number of nodes
}

fn empty_node() -> TapeNode {
    return TapeNode { value: 0.0, adjoint: 0.0, op: 0, parent1: 0 - 1, parent2: 0 - 1, aux: 0.0 }
}

fn new_tape() -> Tape {
    return Tape {
        n0: empty_node(), n1: empty_node(), n2: empty_node(), n3: empty_node(), n4: empty_node(),
        n5: empty_node(), n6: empty_node(), n7: empty_node(), n8: empty_node(), n9: empty_node(),
        n10: empty_node(), n11: empty_node(), n12: empty_node(), n13: empty_node(), n14: empty_node(),
        n15: empty_node(), n16: empty_node(), n17: empty_node(), n18: empty_node(), n19: empty_node(),
        size: 0
    }
}

// Get node by index
fn tape_get(tape: Tape, idx: i64) -> TapeNode {
    if idx == 0 { return tape.n0 }
    if idx == 1 { return tape.n1 }
    if idx == 2 { return tape.n2 }
    if idx == 3 { return tape.n3 }
    if idx == 4 { return tape.n4 }
    if idx == 5 { return tape.n5 }
    if idx == 6 { return tape.n6 }
    if idx == 7 { return tape.n7 }
    if idx == 8 { return tape.n8 }
    if idx == 9 { return tape.n9 }
    if idx == 10 { return tape.n10 }
    if idx == 11 { return tape.n11 }
    if idx == 12 { return tape.n12 }
    if idx == 13 { return tape.n13 }
    if idx == 14 { return tape.n14 }
    if idx == 15 { return tape.n15 }
    if idx == 16 { return tape.n16 }
    if idx == 17 { return tape.n17 }
    if idx == 18 { return tape.n18 }
    return tape.n19
}

// Helper functions for creating tapes with a specific node set
// (Because Sounio doesn't support individual field assignment)

fn tape_set_0(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: node, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_1(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: node, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_2(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: node, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_3(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: node, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_4(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: node,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_5(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: node, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_6(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: node, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_7(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: node, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_8(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: node, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_9(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: node,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_10(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: node, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_11(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: node, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_12(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: node, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_13(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: node, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_14(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: node,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_15(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: node, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_16(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: node, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_17(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: node, n18: tape.n18, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_18(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: node, n19: tape.n19,
        size: tape.size
    }
}

fn tape_set_19(tape: Tape, node: TapeNode) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: node,
        size: tape.size
    }
}

// Set node by index (returns new tape)
fn tape_set(tape: Tape, idx: i64, node: TapeNode) -> Tape {
    if idx == 0 { return tape_set_0(tape, node) }
    if idx == 1 { return tape_set_1(tape, node) }
    if idx == 2 { return tape_set_2(tape, node) }
    if idx == 3 { return tape_set_3(tape, node) }
    if idx == 4 { return tape_set_4(tape, node) }
    if idx == 5 { return tape_set_5(tape, node) }
    if idx == 6 { return tape_set_6(tape, node) }
    if idx == 7 { return tape_set_7(tape, node) }
    if idx == 8 { return tape_set_8(tape, node) }
    if idx == 9 { return tape_set_9(tape, node) }
    if idx == 10 { return tape_set_10(tape, node) }
    if idx == 11 { return tape_set_11(tape, node) }
    if idx == 12 { return tape_set_12(tape, node) }
    if idx == 13 { return tape_set_13(tape, node) }
    if idx == 14 { return tape_set_14(tape, node) }
    if idx == 15 { return tape_set_15(tape, node) }
    if idx == 16 { return tape_set_16(tape, node) }
    if idx == 17 { return tape_set_17(tape, node) }
    if idx == 18 { return tape_set_18(tape, node) }
    return tape_set_19(tape, node)
}

// Helper to set tape size
fn tape_with_size(tape: Tape, new_size: i64) -> Tape {
    return Tape {
        n0: tape.n0, n1: tape.n1, n2: tape.n2, n3: tape.n3, n4: tape.n4,
        n5: tape.n5, n6: tape.n6, n7: tape.n7, n8: tape.n8, n9: tape.n9,
        n10: tape.n10, n11: tape.n11, n12: tape.n12, n13: tape.n13, n14: tape.n14,
        n15: tape.n15, n16: tape.n16, n17: tape.n17, n18: tape.n18, n19: tape.n19,
        size: new_size
    }
}

// ============================================================================
// TRACKED VALUE TYPE
// ============================================================================

struct Var {
    idx: i64,    // Index in tape
    val: f64     // Cached value
}

// Get the last variable added to the tape
fn tape_last_var(tape: Tape) -> Var {
    let idx = tape.size - 1
    let node = tape_get(tape, idx)
    return Var { idx: idx, val: node.value }
}

// Create variable input - returns modified tape
fn tape_new_var(tape: Tape, val: f64) -> Tape {
    let idx = tape.size
    let node = TapeNode { value: val, adjoint: 0.0, op: op_var(), parent1: 0 - 1, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

// Create constant - returns modified tape
fn tape_const(tape: Tape, val: f64) -> Tape {
    let idx = tape.size
    let node = TapeNode { value: val, adjoint: 0.0, op: op_const(), parent1: 0 - 1, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

// ============================================================================
// FORWARD PASS OPERATIONS (record on tape, return modified tape)
// Use tape_last_var() after each operation to get the result Var
// ============================================================================

fn tape_add(tape: Tape, a: Var, b: Var) -> Tape {
    let idx = tape.size
    let val = a.val + b.val
    let node = TapeNode { value: val, adjoint: 0.0, op: op_add(), parent1: a.idx, parent2: b.idx, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_sub(tape: Tape, a: Var, b: Var) -> Tape {
    let idx = tape.size
    let val = a.val - b.val
    let node = TapeNode { value: val, adjoint: 0.0, op: op_sub(), parent1: a.idx, parent2: b.idx, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_mul(tape: Tape, a: Var, b: Var) -> Tape {
    let idx = tape.size
    let val = a.val * b.val
    let node = TapeNode { value: val, adjoint: 0.0, op: op_mul(), parent1: a.idx, parent2: b.idx, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_div(tape: Tape, a: Var, b: Var) -> Tape {
    let idx = tape.size
    let val = a.val / b.val
    let node = TapeNode { value: val, adjoint: 0.0, op: op_div(), parent1: a.idx, parent2: b.idx, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_neg(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = 0.0 - a.val
    let node = TapeNode { value: val, adjoint: 0.0, op: op_neg(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_sqrt(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = sqrt_f64(a.val)
    let node = TapeNode { value: val, adjoint: 0.0, op: op_sqrt(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_exp(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = exp_f64(a.val)
    let node = TapeNode { value: val, adjoint: 0.0, op: op_exp(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_ln(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = ln_f64(a.val)
    let node = TapeNode { value: val, adjoint: 0.0, op: op_ln(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_sin(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = sin_f64(a.val)
    let node = TapeNode { value: val, adjoint: 0.0, op: op_sin(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_cos(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = cos_f64(a.val)
    let node = TapeNode { value: val, adjoint: 0.0, op: op_cos(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_tanh(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = tanh_f64(a.val)
    let node = TapeNode { value: val, adjoint: 0.0, op: op_tanh(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_pow(tape: Tape, a: Var, n: f64) -> Tape {
    let idx = tape.size
    let val = pow_f64(a.val, n)
    let node = TapeNode { value: val, adjoint: 0.0, op: op_pow(), parent1: a.idx, parent2: 0 - 1, aux: n }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_relu(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = if a.val > 0.0 { a.val } else { 0.0 }
    let node = TapeNode { value: val, adjoint: 0.0, op: op_relu(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

fn tape_sigmoid(tape: Tape, a: Var) -> Tape {
    let idx = tape.size
    let val = 1.0 / (1.0 + exp_f64(0.0 - a.val))
    let node = TapeNode { value: val, adjoint: 0.0, op: op_sigmoid(), parent1: a.idx, parent2: 0 - 1, aux: 0.0 }
    let t = tape_set(tape, idx, node)
    return tape_with_size(t, idx + 1)
}

// ============================================================================
// BACKWARD PASS
// ============================================================================

// Helper: Add adjoint to parent2 for add operation
fn backward_add_p2(tape: Tape, p2_idx: i64, adj: f64) -> Tape {
    if p2_idx < 0 { return tape }
    let p2 = tape_get(tape, p2_idx)
    let p2_new = TapeNode { value: p2.value, adjoint: p2.adjoint + adj, op: p2.op, parent1: p2.parent1, parent2: p2.parent2, aux: p2.aux }
    return tape_set(tape, p2_idx, p2_new)
}

// Helper: Subtract adjoint from parent2 for sub operation
fn backward_sub_p2(tape: Tape, p2_idx: i64, adj: f64) -> Tape {
    if p2_idx < 0 { return tape }
    let p2 = tape_get(tape, p2_idx)
    let p2_new = TapeNode { value: p2.value, adjoint: p2.adjoint - adj, op: p2.op, parent1: p2.parent1, parent2: p2.parent2, aux: p2.aux }
    return tape_set(tape, p2_idx, p2_new)
}

// Helper: Add gradient for mul operation to both parents
fn backward_mul(tape: Tape, p1_idx: i64, p2_idx: i64, adj: f64) -> Tape {
    if p2_idx < 0 { return tape }
    let p1 = tape_get(tape, p1_idx)
    let p2 = tape_get(tape, p2_idx)

    if p1_idx == p2_idx {
        // Same variable: d/dx(x*x) = 2x
        let p1_new = TapeNode { value: p1.value, adjoint: p1.adjoint + adj * p1.value * 2.0, op: p1.op, parent1: p1.parent1, parent2: p1.parent2, aux: p1.aux }
        return tape_set(tape, p1_idx, p1_new)
    }

    // Different variables: d/da(a*b) = b, d/db(a*b) = a
    let p1_new = TapeNode { value: p1.value, adjoint: p1.adjoint + adj * p2.value, op: p1.op, parent1: p1.parent1, parent2: p1.parent2, aux: p1.aux }
    let tape2 = tape_set(tape, p1_idx, p1_new)
    let p2_new = TapeNode { value: p2.value, adjoint: p2.adjoint + adj * p1.value, op: p2.op, parent1: p2.parent1, parent2: p2.parent2, aux: p2.aux }
    return tape_set(tape2, p2_idx, p2_new)
}

// Helper: Add gradient for div operation to both parents
fn backward_div(tape: Tape, p1_idx: i64, p2_idx: i64, adj: f64) -> Tape {
    if p2_idx < 0 { return tape }
    let p1 = tape_get(tape, p1_idx)
    let p2 = tape_get(tape, p2_idx)
    // d/da(a/b) = 1/b, d/db(a/b) = -a/b²
    let p1_new = TapeNode { value: p1.value, adjoint: p1.adjoint + adj / p2.value, op: p1.op, parent1: p1.parent1, parent2: p1.parent2, aux: p1.aux }
    let tape2 = tape_set(tape, p1_idx, p1_new)
    let p2_new = TapeNode { value: p2.value, adjoint: p2.adjoint - adj * p1.value / (p2.value * p2.value), op: p2.op, parent1: p2.parent1, parent2: p2.parent2, aux: p2.aux }
    return tape_set(tape2, p2_idx, p2_new)
}

// Helper: Add gradient for unary op to parent
fn backward_unary(tape: Tape, p1_idx: i64, grad: f64) -> Tape {
    let p1 = tape_get(tape, p1_idx)
    let p1_new = TapeNode { value: p1.value, adjoint: p1.adjoint + grad, op: p1.op, parent1: p1.parent1, parent2: p1.parent2, aux: p1.aux }
    return tape_set(tape, p1_idx, p1_new)
}

// Propagate gradient from node to parents
// Refactored to avoid nested if blocks (Sounio compiler scoping bug workaround)
fn backward_node(tape: Tape, idx: i64) -> Tape {
    let node = tape_get(tape, idx)

    // Copy ALL needed values to local vars at function start
    let cur_adj = node.adjoint
    let cur_op = node.op
    let cur_p1_idx = node.parent1
    let cur_p2_idx = node.parent2
    let cur_aux = node.aux
    let cur_value = node.value

    // No parent means nothing to backprop
    if cur_p1_idx < 0 {
        return tape
    }

    // Get parent info
    let p1 = tape_get(tape, cur_p1_idx)
    let p1_value = p1.value

    // Dispatch to helper functions (no nested if blocks)
    if cur_op == op_add() {
        let t1 = backward_unary(tape, cur_p1_idx, cur_adj)
        return backward_add_p2(t1, cur_p2_idx, cur_adj)
    }

    if cur_op == op_sub() {
        let t1 = backward_unary(tape, cur_p1_idx, cur_adj)
        return backward_sub_p2(t1, cur_p2_idx, cur_adj)
    }

    if cur_op == op_mul() {
        return backward_mul(tape, cur_p1_idx, cur_p2_idx, cur_adj)
    }

    if cur_op == op_div() {
        return backward_div(tape, cur_p1_idx, cur_p2_idx, cur_adj)
    }

    if cur_op == op_neg() {
        return backward_unary(tape, cur_p1_idx, 0.0 - cur_adj)
    }

    if cur_op == op_sqrt() {
        // d/dx sqrt(x) = 1/(2*sqrt(x))
        let grad = cur_adj / (2.0 * cur_value)
        return backward_unary(tape, cur_p1_idx, grad)
    }

    if cur_op == op_exp() {
        // d/dx exp(x) = exp(x)
        let grad = cur_adj * cur_value
        return backward_unary(tape, cur_p1_idx, grad)
    }

    if cur_op == op_ln() {
        // d/dx ln(x) = 1/x
        let grad = cur_adj / p1_value
        return backward_unary(tape, cur_p1_idx, grad)
    }

    if cur_op == op_sin() {
        // d/dx sin(x) = cos(x)
        let grad = cur_adj * cos_f64(p1_value)
        return backward_unary(tape, cur_p1_idx, grad)
    }

    if cur_op == op_cos() {
        // d/dx cos(x) = -sin(x)
        let grad = 0.0 - cur_adj * sin_f64(p1_value)
        return backward_unary(tape, cur_p1_idx, grad)
    }

    if cur_op == op_tanh() {
        // d/dx tanh(x) = 1 - tanh²(x)
        let grad = cur_adj * (1.0 - cur_value * cur_value)
        return backward_unary(tape, cur_p1_idx, grad)
    }

    if cur_op == op_pow() {
        // d/dx x^n = n * x^(n-1)
        let n = cur_aux
        let grad = cur_adj * n * pow_f64(p1_value, n - 1.0)
        return backward_unary(tape, cur_p1_idx, grad)
    }

    if cur_op == op_relu() {
        // d/dx ReLU(x) = 1 if x > 0, else 0
        let grad = if p1_value > 0.0 { cur_adj } else { 0.0 }
        return backward_unary(tape, cur_p1_idx, grad)
    }

    if cur_op == op_sigmoid() {
        // d/dx σ(x) = σ(x)(1-σ(x))
        let grad = cur_adj * cur_value * (1.0 - cur_value)
        return backward_unary(tape, cur_p1_idx, grad)
    }

    // Unknown op - return unchanged
    return tape
}

// Run full backward pass from output node
fn backward(tape: Tape, output: Var) -> Tape {

    // Set output adjoint to 1
    let out_node = tape_get(tape, output.idx)
    let out_new = TapeNode { value: out_node.value, adjoint: 1.0, op: out_node.op, parent1: out_node.parent1, parent2: out_node.parent2, aux: out_node.aux }
    let mut t = tape_set(tape, output.idx, out_new)

    // Traverse in reverse order
    let mut i = output.idx
    while i >= 0 {
        t = backward_node(t, i)
        i = i - 1
    }

    return t
}

// Get gradient of a variable
fn get_grad(tape: Tape, v: Var) -> f64 {
    return tape_get(tape, v.idx).adjoint
}

// ============================================================================
// TESTS
// ============================================================================

fn main() -> i32 {
    println("=== Sounio Reverse-Mode Automatic Differentiation ===")
    println("")

    // Test 1: Simple f(x) = x² at x=3
    println("Test 1: Reverse-mode d/dx(x^2) at x=3")
    let mut t1 = new_tape()
    t1 = tape_new_var(t1, 3.0)
    let x1 = tape_last_var(t1)
    t1 = tape_mul(t1, x1, x1)
    let y1 = tape_last_var(t1)
    let t1c = backward(t1, y1)
    println("  f(3) = ")
    println(y1.val)
    println("  df/dx = ")
    println(get_grad(t1c, x1))
    println("  Expected: f=9, df/dx=6")
    println("")

    // Test 2: f(x,y) = x*y + sin(x) at (2, 3)
    println("Test 2: f(x,y) = x*y + sin(x) at (2,3)")
    let mut t2 = new_tape()
    t2 = tape_new_var(t2, 2.0)
    let x2 = tape_last_var(t2)
    t2 = tape_new_var(t2, 3.0)
    let y2 = tape_last_var(t2)
    t2 = tape_mul(t2, x2, y2)
    let xy = tape_last_var(t2)
    t2 = tape_sin(t2, x2)
    let sinx = tape_last_var(t2)
    t2 = tape_add(t2, xy, sinx)
    let f2 = tape_last_var(t2)
    let t2f = backward(t2, f2)
    println("  f(2,3) = ")
    println(f2.val)
    println("  df/dx = ")
    println(get_grad(t2f, x2))
    println("  df/dy = ")
    println(get_grad(t2f, y2))
    // df/dx = y + cos(x) = 3 + cos(2) ≈ 3 - 0.416 ≈ 2.584
    // df/dy = x = 2
    println("  Expected: df/dx~2.584, df/dy=2")
    println("")

    // Test 3: Neural network layer: sigmoid(w*x + b)
    println("Test 3: sigmoid(w*x + b) at w=0.5, x=2, b=0.1")
    let mut t3 = new_tape()
    t3 = tape_new_var(t3, 0.5)
    let w3 = tape_last_var(t3)
    t3 = tape_new_var(t3, 2.0)
    let x3 = tape_last_var(t3)
    t3 = tape_new_var(t3, 0.1)
    let b3 = tape_last_var(t3)
    t3 = tape_mul(t3, w3, x3)
    let wx = tape_last_var(t3)
    t3 = tape_add(t3, wx, b3)
    let wxb = tape_last_var(t3)
    t3 = tape_sigmoid(t3, wxb)
    let out3 = tape_last_var(t3)
    let t3g = backward(t3, out3)
    println("  output = ")
    println(out3.val)
    println("  d/dw = ")
    println(get_grad(t3g, w3))
    println("  d/dx = ")
    println(get_grad(t3g, x3))
    println("  d/db = ")
    println(get_grad(t3g, b3))
    println("")

    // Test 4: exp and ln - f(x) = exp(ln(x)) = x
    println("Test 4: f(x) = exp(ln(x)) at x=3")
    let mut t4 = new_tape()
    t4 = tape_new_var(t4, 3.0)
    let x4 = tape_last_var(t4)
    t4 = tape_ln(t4, x4)
    let lnx = tape_last_var(t4)
    t4 = tape_exp(t4, lnx)
    let f4 = tape_last_var(t4)
    let t4g = backward(t4, f4)
    println("  f(3) = ")
    println(f4.val)
    println("  df/dx = ")
    println(get_grad(t4g, x4))
    println("  Expected: f=3, df/dx=1")
    println("")

    // Test 5: Division - f(x,y) = x/y at (6, 2)
    println("Test 5: f(x,y) = x/y at (6,2)")
    let mut t5 = new_tape()
    t5 = tape_new_var(t5, 6.0)
    let x5 = tape_last_var(t5)
    t5 = tape_new_var(t5, 2.0)
    let y5 = tape_last_var(t5)
    t5 = tape_div(t5, x5, y5)
    let f5 = tape_last_var(t5)
    let t5g = backward(t5, f5)
    println("  f(6,2) = ")
    println(f5.val)
    println("  df/dx = ")
    println(get_grad(t5g, x5))
    println("  df/dy = ")
    println(get_grad(t5g, y5))
    // df/dx = 1/y = 0.5, df/dy = -x/y² = -6/4 = -1.5
    println("  Expected: f=3, df/dx=0.5, df/dy=-1.5")
    println("")

    // Test 6: tanh - f(x) = tanh(x) at x=0.5
    println("Test 6: f(x) = tanh(x) at x=0.5")
    let mut t6 = new_tape()
    t6 = tape_new_var(t6, 0.5)
    let x6 = tape_last_var(t6)
    t6 = tape_tanh(t6, x6)
    let f6 = tape_last_var(t6)
    let t6g = backward(t6, f6)
    let tanh_val = f6.val
    let tanh_grad = 1.0 - tanh_val * tanh_val
    println("  f(0.5) = ")
    println(f6.val)
    println("  df/dx = ")
    println(get_grad(t6g, x6))
    println("  Expected df/dx = 1 - tanh²(0.5) = ")
    println(tanh_grad)
    println("")

    // Validation
    let err1 = abs_f64(get_grad(t1c, x1) - 6.0)
    let err2_x = abs_f64(get_grad(t2f, x2) - (3.0 + cos_f64(2.0)))
    let err2_y = abs_f64(get_grad(t2f, y2) - 2.0)
    let err4 = abs_f64(get_grad(t4g, x4) - 1.0)
    let err5_x = abs_f64(get_grad(t5g, x5) - 0.5)
    let err5_y = abs_f64(get_grad(t5g, y5) - (0.0 - 1.5))
    let err6 = abs_f64(get_grad(t6g, x6) - tanh_grad)

    let all_pass = err1 < 0.001 && err2_x < 0.001 && err2_y < 0.001 && err4 < 0.001 && err5_x < 0.001 && err5_y < 0.001 && err6 < 0.001

    if all_pass {
        println("ALL TESTS PASSED: Reverse-mode AD working correctly")
        return 0
    } else {
        println("TEST FAILED: Gradient errors")
        println("  err1 = ")
        println(err1)
        println("  err2_x = ")
        println(err2_x)
        println("  err2_y = ")
        println(err2_y)
        println("  err4 = ")
        println(err4)
        println("  err5_x = ")
        println(err5_x)
        println("  err5_y = ")
        println(err5_y)
        println("  err6 = ")
        println(err6)
        return 1
    }
}
