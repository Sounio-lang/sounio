// MedLang Compatibility Layer for Sounio
//
// Provides interoperability with Darwin PBPK Platform's MedLang DSL.
// MedLang is a domain-specific language for clinical pharmacology
// designed for regulatory submissions.
//
// This module allows Sounio to:
// 1. Parse MedLang syntax into Sounio AST
// 2. Type-check MedLang with Sounio epistemic types
// 3. Generate MedLang from Sounio code
// 4. Validate against FDA PBPK guidance

module interop::medlang

use units::qudt::*
use pbpk::*

// =============================================================================
// MedLang Core Constructs
// =============================================================================

/// MedLang drug definition
///
/// MedLang syntax:
/// ```medlang
/// drug Metformin {
///     mw: 129.16 g/mol
///     logP: -1.43
///     pKa: [2.8, 11.5]
///     fu: 1.0
/// }
/// ```
pub struct MedLangDrug {
    pub name: string,
    pub molecular_weight: g/mol,
    pub log_p: f64,
    pub pka_values: Vec<f64>,
    pub fraction_unbound: f64,
    pub chebi_id: Option<string>,
}

impl MedLangDrug {
    /// Convert to Sounio Drug with epistemic tracking
    pub fn to_sounio(self, confidence: f64) -> Drug {
        Drug {
            chebi_id: self.chebi_id.unwrap_or("CHEBI:unknown"),
            name: self.name,
            mw: self.molecular_weight,
            logp: self.log_p,
            fu: Knowledge::new(
                value: self.fraction_unbound,
                confidence: confidence,
                provenance: Provenance::source("MedLang_import"),
            ),
        }
    }
}

/// MedLang compartment model
pub enum MedLangModel {
    /// One-compartment model
    OneCompartment {
        ka: per_h,
        ke: per_h,
        vd: L,
    },

    /// Two-compartment model
    TwoCompartment {
        ka: per_h,
        k12: per_h,
        k21: per_h,
        ke: per_h,
        vc: L,
        vp: L,
    },

    /// Full PBPK model (14 compartments)
    PBPK {
        params: PBPKParams,
    },
}

/// MedLang dosing regimen
pub struct MedLangDosing {
    pub route: DosingRoute,
    pub amount: mg,
    pub interval: Option<h>,
    pub n_doses: Option<u32>,
    pub infusion_duration: Option<h>,
}

pub enum DosingRoute {
    Oral,
    IV,
    IVBolus,
    IVInfusion,
    SC,
    IM,
    Topical,
}

/// MedLang simulation specification
pub struct MedLangSimulation {
    pub drug: MedLangDrug,
    pub model: MedLangModel,
    pub dosing: MedLangDosing,
    pub duration: h,
    pub output_times: Option<Vec<h>>,
}

// =============================================================================
// MedLang Parser
// =============================================================================

/// Parse MedLang source code into AST
pub fn parse_medlang(source: &str) -> Result<MedLangAst, MedLangError> with IO {
    let lexer = MedLangLexer::new(source);
    let parser = MedLangParser::new(lexer);
    parser.parse()
}

/// MedLang AST node
pub enum MedLangAst {
    DrugDef(MedLangDrug),
    ModelDef(MedLangModel),
    DosingDef(MedLangDosing),
    SimulationDef(MedLangSimulation),
    Block(Vec<MedLangAst>),
}

/// MedLang parse error
pub enum MedLangError {
    LexError { line: u32, col: u32, message: string },
    ParseError { line: u32, col: u32, expected: string, found: string },
    SemanticError { message: string },
    UnitMismatch { expected: string, found: string },
}

// Placeholder implementations
struct MedLangLexer { /* ... */ }
struct MedLangParser { /* ... */ }

impl MedLangLexer {
    fn new(source: &str) -> Self { /* ... */ }
}

impl MedLangParser {
    fn new(lexer: MedLangLexer) -> Self { /* ... */ }
    fn parse(self) -> Result<MedLangAst, MedLangError> { /* ... */ }
}

// =============================================================================
// MedLang → Sounio Translation
// =============================================================================

/// Translate MedLang AST to Sounio with epistemic annotations
pub fn translate_to_sounio(
    ast: &MedLangAst,
    confidence_config: &ConfidenceConfig,
) -> Result<SounioAst, TranslationError> {
    let translator = MedLangTranslator::new(confidence_config);
    translator.translate(ast)
}

/// Configuration for confidence assignment during translation
pub struct ConfidenceConfig {
    /// Default confidence for drug properties
    pub drug_properties: f64,

    /// Default confidence for PK parameters
    pub pk_parameters: f64,

    /// Default confidence for physiological values
    pub physiology: f64,

    /// Require provenance for all values
    pub require_provenance: bool,
}

impl Default for ConfidenceConfig {
    fn default() -> Self {
        ConfidenceConfig {
            drug_properties: 0.90,
            pk_parameters: 0.75,
            physiology: 0.95,
            require_provenance: true,
        }
    }
}

struct MedLangTranslator { /* ... */ }
pub enum SounioAst { /* ... */ }
pub enum TranslationError { /* ... */ }

impl MedLangTranslator {
    fn new(config: &ConfidenceConfig) -> Self { /* ... */ }
    fn translate(self, ast: &MedLangAst) -> Result<SounioAst, TranslationError> { /* ... */ }
}

// =============================================================================
// Sounio → MedLang Code Generation
// =============================================================================

/// Generate MedLang code from Sounio simulation
pub fn generate_medlang(
    drug: &Drug,
    params: &PBPKParams,
    dosing: &MedLangDosing,
) -> string with IO {
    let mut output = String::new();

    // Drug block
    output.push_str(&format!("drug {} {{\n", drug.name));
    output.push_str(&format!("    mw: {:.2} g/mol\n", drug.mw));
    output.push_str(&format!("    logP: {:.2}\n", drug.logp));
    output.push_str(&format!("    fu: {:.3}\n", drug.fu.value));
    if drug.chebi_id != "CHEBI:unknown" {
        output.push_str(&format!("    @chebi: \"{}\"\n", drug.chebi_id));
    }
    output.push_str("}\n\n");

    // Parameters block with confidence annotations
    output.push_str("parameters {\n");
    output.push_str(&format!("    CL_hepatic: {:.2} L/h  // ε={:.2}\n",
        params.cl_hepatic.value, params.cl_hepatic.confidence));
    output.push_str(&format!("    CL_renal: {:.2} L/h  // ε={:.2}\n",
        params.cl_renal.value, params.cl_renal.confidence));
    output.push_str(&format!("    Vd: {:.2} L  // ε={:.2}\n",
        params.vd.value, params.vd.confidence));
    output.push_str(&format!("    Ka: {:.2} /h  // ε={:.2}\n",
        params.ka.value, params.ka.confidence));
    output.push_str("}\n\n");

    // Dosing block
    output.push_str("dosing {\n");
    output.push_str(&format!("    route: {:?}\n", dosing.route));
    output.push_str(&format!("    amount: {:.1} mg\n", dosing.amount));
    if let Some(interval) = dosing.interval {
        output.push_str(&format!("    interval: {:.1} h\n", interval));
    }
    if let Some(n) = dosing.n_doses {
        output.push_str(&format!("    doses: {}\n", n));
    }
    output.push_str("}\n");

    output
}

// =============================================================================
// FDA PBPK Guidance Validation
// =============================================================================

/// FDA PBPK guidance validation criteria
pub struct FdaValidation {
    /// Model type documented
    pub model_type_documented: bool,

    /// System-specific parameters justified
    pub system_params_justified: bool,

    /// Drug-specific parameters with sources
    pub drug_params_sourced: bool,

    /// Absorption model appropriate
    pub absorption_appropriate: bool,

    /// Distribution model appropriate
    pub distribution_appropriate: bool,

    /// Metabolism pathways identified
    pub metabolism_identified: bool,

    /// Excretion pathways identified
    pub excretion_identified: bool,

    /// Model verification performed
    pub model_verified: bool,

    /// Sensitivity analysis done
    pub sensitivity_analysis: bool,

    /// Uncertainty quantified
    pub uncertainty_quantified: bool,
}

/// Validate simulation against FDA PBPK guidance
pub fn validate_fda_compliance(
    drug: &Drug,
    params: &PBPKParams,
    result: &SimulationResult,
) -> FdaValidation with IO {
    FdaValidation {
        model_type_documented: true,  // 14-compartment PBPK

        // Check if drug has valid ChEBI ID
        drug_params_sourced: drug.chebi_id != "CHEBI:unknown",

        // Check system parameters confidence
        system_params_justified:
            params.cl_hepatic.confidence >= 0.75 &&
            params.cl_renal.confidence >= 0.75 &&
            params.vd.confidence >= 0.75,

        // Epistemic tracking provides uncertainty quantification
        uncertainty_quantified: result.confidence >= 0.50,

        // Placeholders for manual checks
        absorption_appropriate: true,
        distribution_appropriate: true,
        metabolism_identified: true,
        excretion_identified: true,
        model_verified: true,
        sensitivity_analysis: true,
    }
}

/// Generate FDA submission report
pub fn generate_fda_report(
    drug: &Drug,
    params: &PBPKParams,
    result: &SimulationResult,
    validation: &FdaValidation,
) -> string with IO {
    let mut report = String::new();

    report.push_str("=" * 70);
    report.push_str("\nFDA PBPK Submission Report\n");
    report.push_str("Generated by Sounio v0.43.0\n");
    report.push_str("=" * 70);
    report.push_str("\n\n");

    // Drug information
    report.push_str("SECTION 1: DRUG INFORMATION\n");
    report.push_str("-" * 40);
    report.push_str(&format!("\nName: {}\n", drug.name));
    report.push_str(&format!("ChEBI ID: {}\n", drug.chebi_id));
    report.push_str(&format!("Molecular Weight: {:.2} g/mol\n", drug.mw));
    report.push_str(&format!("LogP: {:.2}\n", drug.logp));
    report.push_str(&format!("Fraction Unbound: {:.3} (ε={:.2})\n",
        drug.fu.value, drug.fu.confidence));
    report.push_str("\n");

    // Model parameters with confidence
    report.push_str("SECTION 2: MODEL PARAMETERS\n");
    report.push_str("-" * 40);
    report.push_str(&format!("\nHepatic Clearance: {:.2} L/h\n", params.cl_hepatic.value));
    report.push_str(&format!("  Confidence: {:.1}%\n", params.cl_hepatic.confidence * 100.0));
    report.push_str(&format!("  Provenance: {}\n", params.cl_hepatic.provenance.to_audit_trail()));
    report.push_str("\n");

    // Simulation results
    report.push_str("SECTION 3: SIMULATION RESULTS\n");
    report.push_str("-" * 40);
    report.push_str(&format!("\nTime Points: {}\n", result.times.len()));
    report.push_str(&format!("Overall Confidence: {:.1}%\n", result.confidence * 100.0));
    report.push_str("\n");

    // Validation checklist
    report.push_str("SECTION 4: FDA GUIDANCE COMPLIANCE\n");
    report.push_str("-" * 40);
    report.push_str(&format!("\n[{}] Model type documented\n",
        if validation.model_type_documented { "✓" } else { " " }));
    report.push_str(&format!("[{}] System parameters justified\n",
        if validation.system_params_justified { "✓" } else { " " }));
    report.push_str(&format!("[{}] Drug parameters sourced\n",
        if validation.drug_params_sourced { "✓" } else { " " }));
    report.push_str(&format!("[{}] Uncertainty quantified\n",
        if validation.uncertainty_quantified { "✓" } else { " " }));
    report.push_str("\n");

    // Provenance audit trail
    report.push_str("SECTION 5: PROVENANCE AUDIT TRAIL\n");
    report.push_str("-" * 40);
    report.push_str(&format!("\n{}\n", result.provenance.to_audit_trail()));

    report.push_str("\n");
    report.push_str("=" * 70);
    report.push_str("\nEND OF REPORT\n");
    report.push_str("=" * 70);

    report
}

// =============================================================================
// Darwin Integration Helpers
// =============================================================================

/// Load parameters from Darwin PBPK Platform JSON export
pub fn load_darwin_params(json: &str) -> Result<PBPKParams, string> with IO {
    // Parse JSON from Darwin export
    // Darwin uses a specific JSON schema for PBPK parameters
    // This function converts it to Sounio PBPKParams with epistemic tracking

    // Placeholder - actual implementation would parse JSON
    Err("Not implemented - requires JSON parsing")
}

/// Export to Darwin PBPK Platform format
pub fn export_to_darwin(
    params: &PBPKParams,
    confidence_threshold: f64,
) -> string with IO {
    // Convert Sounio PBPKParams to Darwin JSON format
    // Include confidence as metadata annotations

    let mut json = String::new();
    json.push_str("{\n");
    json.push_str("  \"version\": \"darwin-pbpk-1.0\",\n");
    json.push_str("  \"source\": \"sounio-export\",\n");
    json.push_str("  \"parameters\": {\n");
    json.push_str(&format!("    \"CL_hepatic\": {{\n"));
    json.push_str(&format!("      \"value\": {:.4},\n", params.cl_hepatic.value));
    json.push_str(&format!("      \"unit\": \"L/h\",\n"));
    json.push_str(&format!("      \"confidence\": {:.4}\n", params.cl_hepatic.confidence));
    json.push_str("    },\n");
    // ... more parameters
    json.push_str("  }\n");
    json.push_str("}\n");

    json
}

// =============================================================================
// Tests
// =============================================================================

#[test]
fn test_medlang_drug_conversion() {
    let ml_drug = MedLangDrug {
        name: "TestDrug",
        molecular_weight: 300.0 : g/mol,
        log_p: 2.5,
        pka_values: vec![4.5, 9.0],
        fraction_unbound: 0.15,
        chebi_id: Some("CHEBI:12345"),
    };

    let d_drug = ml_drug.to_sounio(0.85);
    assert_eq!(d_drug.name, "TestDrug");
    assert_eq!(d_drug.fu.confidence, 0.85);
}

#[test]
fn test_medlang_generation() {
    let drug = Drug {
        chebi_id: "CHEBI:6801",
        name: "Metformin",
        mw: 129.16 : g/mol,
        logp: -1.43,
        fu: Knowledge::new(1.0, 0.95, Provenance::source("test")),
    };

    let params = default_pbpk_params();
    let dosing = MedLangDosing {
        route: DosingRoute::Oral,
        amount: 500.0 : mg,
        interval: Some(12.0 : h),
        n_doses: Some(14),
        infusion_duration: None,
    };

    let code = generate_medlang(&drug, &params, &dosing);
    assert!(code.contains("Metformin"));
    assert!(code.contains("500"));
}
