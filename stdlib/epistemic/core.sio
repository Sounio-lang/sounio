//! Epistemic Core Types
//!
//! This module defines the foundational types for epistemic computing in Sounio.
//! See SEMANTICS.md for the formal invariants that these types must maintain.
//!
//! KEY INSIGHT: Uncertainty and Confidence are ORTHOGONAL concepts:
//! - Uncertainty: How precisely do we know the VALUE? (metrology)
//! - Confidence: How much do we TRUST the claim? (epistemology)

// External math functions
extern "C" {
    fn sqrt(x: f64) -> f64;
}

// Wrapper functions
fn sqrt_f64(x: f64) -> f64 {
    if x < 0.0 {
        return 0.0
    }
    return sqrt(x)
}

fn abs_f64(x: f64) -> f64 {
    if x < 0.0 {
        return 0.0 - x
    }
    return x
}

fn min_f64(a: f64, b: f64) -> f64 {
    if a < b { a } else { b }
}

fn max_f64(a: f64, b: f64) -> f64 {
    if a > b { a } else { b }
}

// ============================================================================
// UNCERTAINTY TYPES (Channel A: Metrology)
// ============================================================================

// Uncertainty representation using tagged struct
// tag: 0 = Exact, 1 = StdDev, 2 = Interval
struct Uncertainty {
    tag: i32,           // 0=Exact, 1=StdDev, 2=Interval
    std_u: f64,         // standard uncertainty (for tag=1)
    std_k: f64,         // coverage factor (for tag=1, default 1.0)
    interval_lo: f64,   // lower bound (for tag=2)
    interval_hi: f64,   // upper bound (for tag=2)
}

// Constructors for Uncertainty
fn uncertainty_exact() -> Uncertainty {
    return Uncertainty {
        tag: 0,
        std_u: 0.0,
        std_k: 1.0,
        interval_lo: 0.0,
        interval_hi: 0.0,
    }
}

fn uncertainty_std(u: f64) -> Uncertainty {
    return Uncertainty {
        tag: 1,
        std_u: if u < 0.0 { 0.0 } else { u },
        std_k: 1.0,
        interval_lo: 0.0,
        interval_hi: 0.0,
    }
}

fn uncertainty_interval(lo: f64, hi: f64) -> Uncertainty {
    return Uncertainty {
        tag: 2,
        std_u: 0.0,
        std_k: 1.0,
        interval_lo: if lo < hi { lo } else { hi },
        interval_hi: if lo < hi { hi } else { lo },
    }
}

// Extract std deviation from any uncertainty
fn uncert_to_std(u: Uncertainty) -> f64 {
    if u.tag == 0 {
        return 0.0
    } else if u.tag == 1 {
        return u.std_u
    } else {
        // Interval: use half-width / 2 as proxy for std dev
        return (u.interval_hi - u.interval_lo) / 4.0
    }
}

// ============================================================================
// THE EPISTEMIC VALUE TYPE
// ============================================================================

// EpistemicValue wraps a value with epistemic metadata
// This is the core type for epistemic computing
struct EpistemicValue {
    // The value itself
    value: f64,

    // Channel A: Uncertainty of the VALUE (metrology)
    // "How precisely do we know this number?"
    uncert: Uncertainty,

    // Channel B: Confidence in the CLAIM (epistemology)
    // "How much do we trust this information?"
    // INVARIANT: 0.0 <= conf <= 1.0
    // INVARIANT: conf never increases under pure transformations
    conf: f64,

    // Provenance ID (simplified: just an ID for now)
    provenance_id: i64,
}

// ============================================================================
// CONSTRUCTORS
// ============================================================================

// Create EpistemicValue with standard uncertainty
fn epistemic_std(value: f64, uncertainty: f64, confidence: f64) -> EpistemicValue {
    var conf = confidence
    if conf < 0.0 { conf = 0.0 }
    if conf > 1.0 { conf = 1.0 }

    return EpistemicValue {
        value: value,
        uncert: uncertainty_std(uncertainty),
        conf: conf,
        provenance_id: 0,
    }
}

// Create EpistemicValue with interval bounds
fn epistemic_interval(lo: f64, hi: f64, confidence: f64) -> EpistemicValue {
    var low = lo
    var high = hi
    if lo > hi {
        low = hi
        high = lo
    }
    let value = (low + high) / 2.0

    var conf = confidence
    if conf < 0.0 { conf = 0.0 }
    if conf > 1.0 { conf = 1.0 }

    return EpistemicValue {
        value: value,
        uncert: uncertainty_interval(low, high),
        conf: conf,
        provenance_id: 0,
    }
}

// Create exact EpistemicValue (no uncertainty)
fn epistemic_exact(value: f64, confidence: f64) -> EpistemicValue {
    var conf = confidence
    if conf < 0.0 { conf = 0.0 }
    if conf > 1.0 { conf = 1.0 }

    return EpistemicValue {
        value: value,
        uncert: uncertainty_exact(),
        conf: conf,
        provenance_id: 0,
    }
}

// ============================================================================
// ACCESSORS
// ============================================================================

fn get_value(k: EpistemicValue) -> f64 {
    return k.value
}

fn get_confidence(k: EpistemicValue) -> f64 {
    return k.conf
}

fn get_std_uncertainty(k: EpistemicValue) -> f64 {
    return uncert_to_std(k.uncert)
}

fn get_interval_lo(k: EpistemicValue) -> f64 {
    if k.uncert.tag == 0 {
        return k.value
    } else if k.uncert.tag == 1 {
        return k.value - k.uncert.std_u * k.uncert.std_k * 2.0
    } else {
        return k.uncert.interval_lo
    }
}

fn get_interval_hi(k: EpistemicValue) -> f64 {
    if k.uncert.tag == 0 {
        return k.value
    } else if k.uncert.tag == 1 {
        return k.value + k.uncert.std_u * k.uncert.std_k * 2.0
    } else {
        return k.uncert.interval_hi
    }
}

// ============================================================================
// GUM UNCERTAINTY PROPAGATION
// ============================================================================

// Add two EpistemicValues with GUM uncertainty propagation
// INVARIANT: output.conf <= min(a.conf, b.conf)
fn add_epistemic(a: EpistemicValue, b: EpistemicValue) -> EpistemicValue {
    let value = a.value + b.value
    let conf = min_f64(a.conf, b.conf)

    // GUM: u(y)² = u(a)² + u(b)² for independent inputs
    let ua = uncert_to_std(a.uncert)
    let ub = uncert_to_std(b.uncert)
    let u_combined = sqrt_f64(ua * ua + ub * ub)

    return EpistemicValue {
        value: value,
        uncert: uncertainty_std(u_combined),
        conf: conf,
        provenance_id: 0,
    }
}

// Subtract two EpistemicValues
fn sub_epistemic(a: EpistemicValue, b: EpistemicValue) -> EpistemicValue {
    let value = a.value - b.value
    let conf = min_f64(a.conf, b.conf)

    // Same as addition: variances add
    let ua = uncert_to_std(a.uncert)
    let ub = uncert_to_std(b.uncert)
    let u_combined = sqrt_f64(ua * ua + ub * ub)

    return EpistemicValue {
        value: value,
        uncert: uncertainty_std(u_combined),
        conf: conf,
        provenance_id: 0,
    }
}

// Multiply two EpistemicValues
fn mul_epistemic(a: EpistemicValue, b: EpistemicValue) -> EpistemicValue {
    let value = a.value * b.value
    let conf = min_f64(a.conf, b.conf)

    // GUM: relative uncertainties add in quadrature
    let ua = uncert_to_std(a.uncert)
    let ub = uncert_to_std(b.uncert)

    var u_rel_a = 0.0
    var u_rel_b = 0.0
    if abs_f64(a.value) > 1.0e-15 {
        u_rel_a = ua / abs_f64(a.value)
    }
    if abs_f64(b.value) > 1.0e-15 {
        u_rel_b = ub / abs_f64(b.value)
    }

    let u_rel_combined = sqrt_f64(u_rel_a * u_rel_a + u_rel_b * u_rel_b)
    let u_combined = abs_f64(value) * u_rel_combined

    return EpistemicValue {
        value: value,
        uncert: uncertainty_std(u_combined),
        conf: conf,
        provenance_id: 0,
    }
}

// Divide two EpistemicValues
fn div_epistemic(a: EpistemicValue, b: EpistemicValue) -> EpistemicValue {
    // Guard against division by zero
    if abs_f64(b.value) < 1.0e-15 {
        return EpistemicValue {
            value: 0.0,
            uncert: uncertainty_interval(-1.0e308, 1.0e308),
            conf: 0.0,
            provenance_id: 0,
        }
    }

    let value = a.value / b.value
    let conf = min_f64(a.conf, b.conf)

    let ua = uncert_to_std(a.uncert)
    let ub = uncert_to_std(b.uncert)

    var u_rel_a = 0.0
    var u_rel_b = 0.0
    if abs_f64(a.value) > 1.0e-15 {
        u_rel_a = ua / abs_f64(a.value)
    }
    if abs_f64(b.value) > 1.0e-15 {
        u_rel_b = ub / abs_f64(b.value)
    }

    let u_rel_combined = sqrt_f64(u_rel_a * u_rel_a + u_rel_b * u_rel_b)
    let u_combined = abs_f64(value) * u_rel_combined

    return EpistemicValue {
        value: value,
        uncert: uncertainty_std(u_combined),
        conf: conf,
        provenance_id: 0,
    }
}

// ============================================================================
// INTERVAL ARITHMETIC
// ============================================================================

fn add_interval(a: EpistemicValue, b: EpistemicValue) -> EpistemicValue {
    let a_lo = get_interval_lo(a)
    let a_hi = get_interval_hi(a)
    let b_lo = get_interval_lo(b)
    let b_hi = get_interval_hi(b)

    // [a,b] + [c,d] = [a+c, b+d]
    let lo = a_lo + b_lo
    let hi = a_hi + b_hi
    let conf = min_f64(a.conf, b.conf)

    return EpistemicValue {
        value: (lo + hi) / 2.0,
        uncert: uncertainty_interval(lo, hi),
        conf: conf,
        provenance_id: 0,
    }
}

fn mul_interval(a: EpistemicValue, b: EpistemicValue) -> EpistemicValue {
    let a_lo = get_interval_lo(a)
    let a_hi = get_interval_hi(a)
    let b_lo = get_interval_lo(b)
    let b_hi = get_interval_hi(b)

    // Find min and max of all products
    let p1 = a_lo * b_lo
    let p2 = a_lo * b_hi
    let p3 = a_hi * b_lo
    let p4 = a_hi * b_hi

    var lo = p1
    lo = min_f64(lo, p2)
    lo = min_f64(lo, p3)
    lo = min_f64(lo, p4)

    var hi = p1
    hi = max_f64(hi, p2)
    hi = max_f64(hi, p3)
    hi = max_f64(hi, p4)

    let conf = min_f64(a.conf, b.conf)

    return EpistemicValue {
        value: (lo + hi) / 2.0,
        uncert: uncertainty_interval(lo, hi),
        conf: conf,
        provenance_id: 0,
    }
}

// ============================================================================
// EVIDENCE FUSION
// ============================================================================

fn fuse_measurements(a: EpistemicValue, b: EpistemicValue) -> EpistemicValue {
    let u_a = uncert_to_std(a.uncert)
    let u_b = uncert_to_std(b.uncert)

    // Handle exact cases
    if u_a < 1.0e-15 && u_b < 1.0e-15 {
        let value = (a.value + b.value) / 2.0
        let conf = max_f64(a.conf, b.conf)
        return epistemic_exact(value, conf)
    }
    if u_a < 1.0e-15 {
        return a
    }
    if u_b < 1.0e-15 {
        return b
    }

    // Inverse-variance weighting
    let var_a = u_a * u_a
    let var_b = u_b * u_b
    let w_a = 1.0 / var_a
    let w_b = 1.0 / var_b
    let w_total = w_a + w_b

    let value = (w_a * a.value + w_b * b.value) / w_total
    let var_combined = 1.0 / w_total
    let u_combined = sqrt_f64(var_combined)
    let conf = max_f64(a.conf, b.conf)

    return EpistemicValue {
        value: value,
        uncert: uncertainty_std(u_combined),
        conf: conf,
        provenance_id: 0,
    }
}

// ============================================================================
// INVARIANT CHECKS
// ============================================================================

fn is_valid_confidence(k: EpistemicValue) -> bool {
    return k.conf >= 0.0 && k.conf <= 1.0
}

fn is_valid_uncertainty(k: EpistemicValue) -> bool {
    if k.uncert.tag == 1 {
        return k.uncert.std_u >= 0.0
    } else if k.uncert.tag == 2 {
        return k.uncert.interval_lo <= k.uncert.interval_hi
    }
    return true
}

fn check_invariants(k: EpistemicValue) -> bool {
    return is_valid_confidence(k) && is_valid_uncertainty(k)
}

// ============================================================================
// PROPERTY TESTS
// ============================================================================

fn test_confidence_monotonicity_add(a: EpistemicValue, b: EpistemicValue) -> bool {
    let result = add_epistemic(a, b)
    let min_conf = min_f64(a.conf, b.conf)
    return result.conf <= min_conf + 1.0e-10
}

fn test_confidence_monotonicity_mul(a: EpistemicValue, b: EpistemicValue) -> bool {
    let result = mul_epistemic(a, b)
    let min_conf = min_f64(a.conf, b.conf)
    return result.conf <= min_conf + 1.0e-10
}

fn test_uncertainty_growth(a: EpistemicValue, b: EpistemicValue) -> bool {
    let result = add_epistemic(a, b)
    let u_result = uncert_to_std(result.uncert)
    let max_input = max_f64(uncert_to_std(a.uncert), uncert_to_std(b.uncert))
    return u_result >= max_input * 0.99
}

fn test_interval_enclosure(a: EpistemicValue, b: EpistemicValue) -> bool {
    let result = add_interval(a, b)
    let test_sum = a.value + b.value
    return test_sum >= get_interval_lo(result) - 0.01 &&
           test_sum <= get_interval_hi(result) + 0.01
}

// ============================================================================
// MAIN
// ============================================================================

fn main() -> i32 {
    // Test construction
    let mass = epistemic_std(75.0, 0.5, 0.95)
    let height = epistemic_std(1.75, 0.01, 0.90)

    // Test GUM propagation
    let sum = add_epistemic(mass, height)
    let product = mul_epistemic(mass, height)

    if !check_invariants(sum) { return 1 }
    if !check_invariants(product) { return 2 }

    // Confidence monotonicity
    if !test_confidence_monotonicity_add(mass, height) { return 3 }
    if !test_confidence_monotonicity_mul(mass, height) { return 4 }

    // Uncertainty growth
    if !test_uncertainty_growth(mass, height) { return 5 }

    // Interval arithmetic
    let int_a = epistemic_interval(1.0, 2.0, 0.99)
    let int_b = epistemic_interval(3.0, 4.0, 0.95)
    let int_sum = add_interval(int_a, int_b)

    let lo = get_interval_lo(int_sum)
    let hi = get_interval_hi(int_sum)
    if lo > 4.01 || hi < 5.99 { return 6 }

    // Interval enclosure
    if !test_interval_enclosure(int_a, int_b) { return 7 }

    // Fusion reduces uncertainty
    let m1 = epistemic_std(100.0, 5.0, 0.9)
    let m2 = epistemic_std(102.0, 5.0, 0.85)
    let fused = fuse_measurements(m1, m2)

    let fused_u = uncert_to_std(fused.uncert)
    if fused_u >= 5.0 { return 8 }
    if fused.conf < 0.89 { return 9 }

    return 0
}
