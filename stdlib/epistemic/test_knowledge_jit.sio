/// JIT-Compatible Test: Knowledge and Variance Propagation
///
/// Tests the core epistemic computing concepts in a format
/// that works with the current Sounio JIT.

// ============================================================================
// NUMERIC HELPERS
// ============================================================================

fn abs_f64(x: f64) -> f64 {
    if x < 0.0 { return 0.0 - x }
    return x
}

fn max_f64(a: f64, b: f64) -> f64 {
    if a > b { return a }
    return b
}

fn sqrt_f64(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    var y = x
    var i = 0
    while i < 10 {
        y = 0.5 * (y + x / y)
        i = i + 1
    }
    return y
}

fn exp_f64(x: f64) -> f64 {
    if x > 10.0 { return 22026.465794806718 * exp_f64(x - 10.0) }
    if x < 0.0 - 10.0 { return 0.00004539992976248485 * exp_f64(x + 10.0) }
    var result = 1.0
    var term = 1.0
    var nf = 1.0
    var n = 1
    while n < 20 {
        term = term * x / nf
        result = result + term
        n = n + 1
        nf = nf + 1.0
    }
    return result
}

fn ln_f64(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 - 999999.0 }
    if x == 1.0 { return 0.0 }
    let y = (x - 1.0) / (x + 1.0)
    var result = 0.0
    var term = y
    var i = 1
    while i < 30 {
        result = result + term / (i * 1.0)
        term = term * y * y
        i = i + 2
    }
    return 2.0 * result
}

fn erf_approx(x: f64) -> f64 {
    let a1 = 0.254829592
    let a2 = 0.0 - 0.284496736
    let a3 = 1.421413741
    let a4 = 0.0 - 1.453152027
    let a5 = 1.061405429
    let p = 0.3275911
    let sign = if x < 0.0 { 0.0 - 1.0 } else { 1.0 }
    let x_abs = if x < 0.0 { 0.0 - x } else { x }
    let t = 1.0 / (1.0 + p * x_abs)
    let y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp_f64(0.0 - x_abs * x_abs)
    return sign * y
}

// ============================================================================
// EPISTEMIC VALUE STRUCT (Simplified for JIT)
// ============================================================================

struct EpistemicValue {
    value: f64,
    variance: f64,
    conf_alpha: f64,
    conf_beta: f64
}

fn epistemic_new(value: f64, variance: f64) -> EpistemicValue {
    return EpistemicValue {
        value: value,
        variance: variance,
        conf_alpha: 1.0,
        conf_beta: 1.0
    }
}

fn epistemic_std(k: EpistemicValue) -> f64 {
    return sqrt_f64(k.variance)
}

fn epistemic_conf_mean(k: EpistemicValue) -> f64 {
    return k.conf_alpha / (k.conf_alpha + k.conf_beta)
}

// ============================================================================
// VARIANCE PROPAGATION
// ============================================================================

/// X + Y: Var(X + Y) = Var(X) + Var(Y)
fn epistemic_add(x: EpistemicValue, y: EpistemicValue) -> EpistemicValue {
    return EpistemicValue {
        value: x.value + y.value,
        variance: x.variance + y.variance,
        conf_alpha: x.conf_alpha + y.conf_alpha - 1.0,
        conf_beta: x.conf_beta + y.conf_beta - 1.0
    }
}

/// X - Y: Var(X - Y) = Var(X) + Var(Y)
fn epistemic_sub(x: EpistemicValue, y: EpistemicValue) -> EpistemicValue {
    return EpistemicValue {
        value: x.value - y.value,
        variance: x.variance + y.variance,
        conf_alpha: x.conf_alpha + y.conf_alpha - 1.0,
        conf_beta: x.conf_beta + y.conf_beta - 1.0
    }
}

/// X * Y: Var(XY) ≈ Y²Var(X) + X²Var(Y) (delta method)
fn epistemic_mul(x: EpistemicValue, y: EpistemicValue) -> EpistemicValue {
    let new_variance = y.value * y.value * x.variance + x.value * x.value * y.variance
    return EpistemicValue {
        value: x.value * y.value,
        variance: new_variance,
        conf_alpha: x.conf_alpha + y.conf_alpha - 1.0,
        conf_beta: x.conf_beta + y.conf_beta - 1.0
    }
}

/// X / Y: Var(X/Y) ≈ (1/Y²)Var(X) + (X²/Y⁴)Var(Y) (delta method)
fn epistemic_div(x: EpistemicValue, y: EpistemicValue) -> EpistemicValue {
    let y2 = y.value * y.value
    let y4 = y2 * y2
    let new_variance = x.variance / y2 + x.value * x.value * y.variance / y4
    return EpistemicValue {
        value: x.value / y.value,
        variance: new_variance,
        conf_alpha: x.conf_alpha + y.conf_alpha - 1.0,
        conf_beta: x.conf_beta + y.conf_beta - 1.0
    }
}

/// Scale by constant: Var(cX) = c²Var(X)
fn epistemic_scale(k: EpistemicValue, c: f64) -> EpistemicValue {
    return EpistemicValue {
        value: k.value * c,
        variance: k.variance * c * c,
        conf_alpha: k.conf_alpha,
        conf_beta: k.conf_beta
    }
}

/// e^X: Var(e^X) ≈ e^(2X) · Var(X)
fn epistemic_exp(k: EpistemicValue) -> EpistemicValue {
    let new_value = exp_f64(k.value)
    let new_variance = exp_f64(2.0 * k.value) * k.variance
    return EpistemicValue {
        value: new_value,
        variance: new_variance,
        conf_alpha: k.conf_alpha,
        conf_beta: k.conf_beta
    }
}

/// ln(X): Var(ln X) ≈ Var(X)/X²
fn epistemic_ln(k: EpistemicValue) -> EpistemicValue {
    let new_value = ln_f64(k.value)
    let new_variance = k.variance / (k.value * k.value)
    return EpistemicValue {
        value: new_value,
        variance: new_variance,
        conf_alpha: k.conf_alpha,
        conf_beta: k.conf_beta
    }
}

/// √X: Var(√X) ≈ Var(X)/(4X)
fn epistemic_sqrt(k: EpistemicValue) -> EpistemicValue {
    let new_value = sqrt_f64(k.value)
    let new_variance = k.variance / (4.0 * k.value)
    return EpistemicValue {
        value: new_value,
        variance: new_variance,
        conf_alpha: k.conf_alpha,
        conf_beta: k.conf_beta
    }
}

/// X²: Var(X²) ≈ 4X²Var(X)
fn epistemic_square(k: EpistemicValue) -> EpistemicValue {
    let new_value = k.value * k.value
    let new_variance = 4.0 * new_value * k.variance
    return EpistemicValue {
        value: new_value,
        variance: new_variance,
        conf_alpha: k.conf_alpha,
        conf_beta: k.conf_beta
    }
}

// ============================================================================
// PROBABILITY QUERIES
// ============================================================================

/// P(X > thresh) using normal approximation
fn epistemic_prob_gt(k: EpistemicValue, thresh: f64) -> f64 {
    if k.variance <= 0.0000001 {
        if k.value > thresh { return 1.0 }
        return 0.0
    }
    let z = (k.value - thresh) / sqrt_f64(k.variance)
    return 0.5 * (1.0 + erf_approx(z / 1.4142135623730951))
}

/// 95% CI lower bound
fn epistemic_ci95_lo(k: EpistemicValue) -> f64 {
    return k.value - 1.96 * sqrt_f64(k.variance)
}

/// 95% CI upper bound
fn epistemic_ci95_hi(k: EpistemicValue) -> f64 {
    return k.value + 1.96 * sqrt_f64(k.variance)
}

// ============================================================================
// BELIEF UPDATE (Active Inference)
// ============================================================================

fn precision_of(k: EpistemicValue) -> f64 {
    return 1.0 / max_f64(k.variance, 0.0000001)
}

fn update_belief(prior: EpistemicValue, observation: f64, obs_variance: f64) -> EpistemicValue {
    let prior_prec = precision_of(prior)
    let obs_prec = 1.0 / max_f64(obs_variance, 0.0000001)
    let total_prec = prior_prec + obs_prec
    let posterior_mean = (prior_prec * prior.value + obs_prec * observation) / total_prec
    let posterior_var = 1.0 / total_prec
    return EpistemicValue {
        value: posterior_mean,
        variance: posterior_var,
        conf_alpha: prior.conf_alpha + 1.0,
        conf_beta: prior.conf_beta
    }
}

// ============================================================================
// TESTS
// ============================================================================

fn main() -> f64 {
    var passed = 0.0
    var failed = 0.0
    let tol = 0.001

    // Test 1: Addition variance propagation
    let k1 = epistemic_new(100.0, 4.0)
    let k2 = epistemic_new(50.0, 1.0)
    let sum = epistemic_add(k1, k2)
    // Var(X + Y) = 4 + 1 = 5
    if abs_f64(sum.variance - 5.0) < tol {
        if abs_f64(sum.value - 150.0) < tol {
            passed = passed + 1.0
        } else { failed = failed + 1.0 }
    } else { failed = failed + 1.0 }

    // Test 2: Multiplication variance propagation
    let k3 = epistemic_new(10.0, 0.25)
    let k4 = epistemic_new(5.0, 0.04)
    let prod = epistemic_mul(k3, k4)
    // Var(XY) ≈ Y²Var(X) + X²Var(Y) = 25*0.25 + 100*0.04 = 10.25
    let expected_prod_var = 25.0 * 0.25 + 100.0 * 0.04
    if abs_f64(prod.variance - expected_prod_var) < 0.1 {
        if abs_f64(prod.value - 50.0) < tol {
            passed = passed + 1.0
        } else { failed = failed + 1.0 }
    } else { failed = failed + 1.0 }

    // Test 3: Division variance propagation
    let dose = epistemic_new(500.0, 25.0)
    let volume = epistemic_new(10.0, 0.01)
    let conc = epistemic_div(dose, volume)
    // Var(X/Y) ≈ Var(X)/Y² + X²Var(Y)/Y⁴
    // = 25/100 + 250000*0.01/10000 = 0.25 + 0.25 = 0.5
    let expected_div_var = 25.0 / 100.0 + 250000.0 * 0.01 / 10000.0
    if abs_f64(conc.variance - expected_div_var) < 0.1 {
        if abs_f64(conc.value - 50.0) < tol {
            passed = passed + 1.0
        } else { failed = failed + 1.0 }
    } else { failed = failed + 1.0 }

    // Test 4: P(X > 0) for N(0,1) should be 0.5
    let k5 = epistemic_new(0.0, 1.0)
    let p = epistemic_prob_gt(k5, 0.0)
    if abs_f64(p - 0.5) < 0.01 {
        passed = passed + 1.0
    } else { failed = failed + 1.0 }

    // Test 5: 95% CI for N(100, 4)
    let k6 = epistemic_new(100.0, 4.0)
    let ci_lo = epistemic_ci95_lo(k6)
    let ci_hi = epistemic_ci95_hi(k6)
    // Should be [96.08, 103.92]
    if abs_f64(ci_lo - 96.08) < 0.1 {
        if abs_f64(ci_hi - 103.92) < 0.1 {
            passed = passed + 1.0
        } else { failed = failed + 1.0 }
    } else { failed = failed + 1.0 }

    // Test 6: Scale by constant
    let k7 = epistemic_new(10.0, 1.0)
    let scaled = epistemic_scale(k7, 3.0)
    // Value = 30, Var = 9
    if abs_f64(scaled.value - 30.0) < tol {
        if abs_f64(scaled.variance - 9.0) < tol {
            passed = passed + 1.0
        } else { failed = failed + 1.0 }
    } else { failed = failed + 1.0 }

    // Test 7: Belief update reduces variance
    let prior = epistemic_new(10.0, 4.0)
    let posterior = update_belief(prior, 11.0, 1.0)
    if posterior.variance < prior.variance {
        passed = passed + 1.0
    } else { failed = failed + 1.0 }

    // Test 8: Posterior mean is weighted average
    // Prior: N(10, 4), Obs: 11 with var=1
    // Posterior mean = (0.25*10 + 1*11)/(0.25+1) = 13.5/1.25 = 10.8
    let expected_mean = (0.25 * 10.0 + 1.0 * 11.0) / (0.25 + 1.0)
    if abs_f64(posterior.value - expected_mean) < 0.1 {
        passed = passed + 1.0
    } else { failed = failed + 1.0 }

    // Return score: passed - failed (positive = success)
    return passed - failed
}
