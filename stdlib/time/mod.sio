//! Time Module for Sounio
//!
//! Provides comprehensive date/time utilities:
//! - Current time and timestamps
//! - Duration arithmetic
//! - Date and time formatting and parsing
//! - Timezone support
//!
//! # Quick Start
//!
//! ```d
//! import time::*
//!
//! fn main() with IO {
//!     // Get current time
//!     let now = Instant::now();
//!
//!     // Duration arithmetic
//!     let duration = Duration::from_secs(60);
//!     let later = now + duration;
//!
//!     // Format date/time
//!     let dt = DateTime::now();
//!     println("Current time: {}", dt.format("%Y-%m-%d %H:%M:%S"));
//!
//!     // Parse date/time
//!     let parsed = DateTime::parse("2024-01-15 10:30:00", "%Y-%m-%d %H:%M:%S")?;
//! }
//! ```

module time

// =============================================================================
// Duration
// =============================================================================

/// Represents a span of time
pub struct Duration {
    /// Total nanoseconds
    nanos: i64,
}

impl Duration {
    /// Create zero duration
    pub fn zero() -> Duration {
        Duration { nanos: 0 }
    }

    /// Create duration from nanoseconds
    pub fn from_nanos(nanos: i64) -> Duration {
        Duration { nanos: nanos }
    }

    /// Create duration from microseconds
    pub fn from_micros(micros: i64) -> Duration {
        Duration { nanos: micros * 1000 }
    }

    /// Create duration from milliseconds
    pub fn from_millis(millis: i64) -> Duration {
        Duration { nanos: millis * 1_000_000 }
    }

    /// Create duration from seconds
    pub fn from_secs(secs: i64) -> Duration {
        Duration { nanos: secs * 1_000_000_000 }
    }

    /// Create duration from minutes
    pub fn from_mins(mins: i64) -> Duration {
        Duration::from_secs(mins * 60)
    }

    /// Create duration from hours
    pub fn from_hours(hours: i64) -> Duration {
        Duration::from_secs(hours * 3600)
    }

    /// Create duration from days
    pub fn from_days(days: i64) -> Duration {
        Duration::from_secs(days * 86400)
    }

    /// Create duration from weeks
    pub fn from_weeks(weeks: i64) -> Duration {
        Duration::from_days(weeks * 7)
    }

    /// Create duration from seconds as f64
    pub fn from_secs_f64(secs: f64) -> Duration {
        Duration { nanos: (secs * 1_000_000_000.0) as i64 }
    }

    /// Get duration as nanoseconds
    pub fn as_nanos(self: &Duration) -> i64 {
        self.nanos
    }

    /// Get duration as microseconds
    pub fn as_micros(self: &Duration) -> i64 {
        self.nanos / 1000
    }

    /// Get duration as milliseconds
    pub fn as_millis(self: &Duration) -> i64 {
        self.nanos / 1_000_000
    }

    /// Get duration as seconds (truncated)
    pub fn as_secs(self: &Duration) -> i64 {
        self.nanos / 1_000_000_000
    }

    /// Get duration as seconds with fractional part
    pub fn as_secs_f64(self: &Duration) -> f64 {
        self.nanos as f64 / 1_000_000_000.0
    }

    /// Get subsecond nanoseconds
    pub fn subsec_nanos(self: &Duration) -> i64 {
        self.nanos % 1_000_000_000
    }

    /// Check if duration is zero
    pub fn is_zero(self: &Duration) -> bool {
        self.nanos == 0
    }

    /// Check if duration is positive
    pub fn is_positive(self: &Duration) -> bool {
        self.nanos > 0
    }

    /// Check if duration is negative
    pub fn is_negative(self: &Duration) -> bool {
        self.nanos < 0
    }

    /// Get absolute value of duration
    pub fn abs(self: &Duration) -> Duration {
        if self.nanos >= 0 {
            Duration { nanos: self.nanos }
        } else {
            Duration { nanos: -self.nanos }
        }
    }

    /// Saturating addition
    pub fn saturating_add(self: &Duration, other: &Duration) -> Duration {
        Duration { nanos: self.nanos.saturating_add(other.nanos) }
    }

    /// Saturating subtraction
    pub fn saturating_sub(self: &Duration, other: &Duration) -> Duration {
        Duration { nanos: self.nanos.saturating_sub(other.nanos) }
    }

    /// Multiply by scalar
    pub fn mul(self: &Duration, factor: i64) -> Duration {
        Duration { nanos: self.nanos * factor }
    }

    /// Divide by scalar
    pub fn div(self: &Duration, divisor: i64) -> Duration {
        Duration { nanos: self.nanos / divisor }
    }
}

impl Add for Duration {
    type Output = Duration;

    fn add(self, other: Duration) -> Duration {
        Duration { nanos: self.nanos + other.nanos }
    }
}

impl Sub for Duration {
    type Output = Duration;

    fn sub(self, other: Duration) -> Duration {
        Duration { nanos: self.nanos - other.nanos }
    }
}

impl Neg for Duration {
    type Output = Duration;

    fn neg(self) -> Duration {
        Duration { nanos: -self.nanos }
    }
}

impl Ord for Duration {
    fn cmp(self: &Duration, other: &Duration) -> Ordering {
        self.nanos.cmp(&other.nanos)
    }
}

impl PartialOrd for Duration {
    fn partial_cmp(self: &Duration, other: &Duration) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Eq for Duration {}

impl PartialEq for Duration {
    fn eq(self: &Duration, other: &Duration) -> bool {
        self.nanos == other.nanos
    }
}

impl ToString for Duration {
    fn to_string(self) -> String {
        if self.nanos < 1000 {
            self.nanos.to_string() ++ "ns"
        } else if self.nanos < 1_000_000 {
            (self.nanos / 1000).to_string() ++ "us"
        } else if self.nanos < 1_000_000_000 {
            (self.nanos / 1_000_000).to_string() ++ "ms"
        } else {
            self.as_secs_f64().to_string() ++ "s"
        }
    }
}

// =============================================================================
// Instant (Monotonic Clock)
// =============================================================================

/// A measurement of a monotonically non-decreasing clock
pub struct Instant {
    /// Nanoseconds since some arbitrary point
    nanos: i64,
}

impl Instant {
    /// Get current instant
    pub fn now() -> Instant with IO {
        extern "C" {
            fn __sounio_monotonic_time_ns() -> i64;
        }

        let nanos = unsafe { __sounio_monotonic_time_ns() };
        Instant { nanos: nanos }
    }

    /// Duration since this instant
    pub fn elapsed(self: &Instant) -> Duration with IO {
        let now = Instant::now();
        now.duration_since(self)
    }

    /// Duration between two instants
    pub fn duration_since(self: &Instant, earlier: &Instant) -> Duration {
        Duration { nanos: self.nanos - earlier.nanos }
    }

    /// Checked duration between two instants (returns None if earlier is after self)
    pub fn checked_duration_since(self: &Instant, earlier: &Instant) -> Option<Duration> {
        if self.nanos >= earlier.nanos {
            Some(Duration { nanos: self.nanos - earlier.nanos })
        } else {
            None
        }
    }

    /// Saturating duration since
    pub fn saturating_duration_since(self: &Instant, earlier: &Instant) -> Duration {
        if self.nanos >= earlier.nanos {
            Duration { nanos: self.nanos - earlier.nanos }
        } else {
            Duration::zero()
        }
    }

    /// Add duration to instant
    pub fn add(self: &Instant, duration: &Duration) -> Instant {
        Instant { nanos: self.nanos + duration.nanos }
    }

    /// Subtract duration from instant
    pub fn sub(self: &Instant, duration: &Duration) -> Instant {
        Instant { nanos: self.nanos - duration.nanos }
    }
}

impl Add<Duration> for Instant {
    type Output = Instant;

    fn add(self, duration: Duration) -> Instant {
        Instant { nanos: self.nanos + duration.nanos }
    }
}

impl Sub<Duration> for Instant {
    type Output = Instant;

    fn sub(self, duration: Duration) -> Instant {
        Instant { nanos: self.nanos - duration.nanos }
    }
}

impl Sub<Instant> for Instant {
    type Output = Duration;

    fn sub(self, other: Instant) -> Duration {
        Duration { nanos: self.nanos - other.nanos }
    }
}

impl Ord for Instant {
    fn cmp(self: &Instant, other: &Instant) -> Ordering {
        self.nanos.cmp(&other.nanos)
    }
}

impl PartialOrd for Instant {
    fn partial_cmp(self: &Instant, other: &Instant) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Eq for Instant {}

impl PartialEq for Instant {
    fn eq(self: &Instant, other: &Instant) -> bool {
        self.nanos == other.nanos
    }
}

// =============================================================================
// SystemTime (Wall Clock)
// =============================================================================

/// A measurement of the system clock (wall time)
pub struct SystemTime {
    /// Nanoseconds since Unix epoch (1970-01-01 00:00:00 UTC)
    nanos_since_epoch: i64,
}

/// Error when system time is before Unix epoch
pub struct SystemTimeError {
    pub duration: Duration,
}

impl SystemTime {
    /// The Unix epoch (1970-01-01 00:00:00 UTC)
    pub const UNIX_EPOCH: SystemTime = SystemTime { nanos_since_epoch: 0 };

    /// Get current system time
    pub fn now() -> SystemTime with IO {
        extern "C" {
            fn __sounio_system_time_ns() -> i64;
        }

        let nanos = unsafe { __sounio_system_time_ns() };
        SystemTime { nanos_since_epoch: nanos }
    }

    /// Create from Unix timestamp (seconds)
    pub fn from_unix_timestamp(secs: i64) -> SystemTime {
        SystemTime { nanos_since_epoch: secs * 1_000_000_000 }
    }

    /// Create from Unix timestamp (milliseconds)
    pub fn from_unix_timestamp_millis(millis: i64) -> SystemTime {
        SystemTime { nanos_since_epoch: millis * 1_000_000 }
    }

    /// Create from Unix timestamp (nanoseconds)
    pub fn from_unix_timestamp_nanos(nanos: i64) -> SystemTime {
        SystemTime { nanos_since_epoch: nanos }
    }

    /// Get duration since Unix epoch
    pub fn duration_since_epoch(self: &SystemTime) -> Duration {
        Duration { nanos: self.nanos_since_epoch }
    }

    /// Duration since an earlier time
    pub fn duration_since(self: &SystemTime, earlier: &SystemTime) -> Result<Duration, SystemTimeError> {
        if self.nanos_since_epoch >= earlier.nanos_since_epoch {
            Ok(Duration { nanos: self.nanos_since_epoch - earlier.nanos_since_epoch })
        } else {
            Err(SystemTimeError {
                duration: Duration { nanos: earlier.nanos_since_epoch - self.nanos_since_epoch }
            })
        }
    }

    /// Elapsed time since this system time
    pub fn elapsed(self: &SystemTime) -> Result<Duration, SystemTimeError> with IO {
        let now = SystemTime::now();
        now.duration_since(self)
    }

    /// Get Unix timestamp in seconds
    pub fn unix_timestamp(self: &SystemTime) -> i64 {
        self.nanos_since_epoch / 1_000_000_000
    }

    /// Get Unix timestamp in milliseconds
    pub fn unix_timestamp_millis(self: &SystemTime) -> i64 {
        self.nanos_since_epoch / 1_000_000
    }

    /// Get Unix timestamp in nanoseconds
    pub fn unix_timestamp_nanos(self: &SystemTime) -> i64 {
        self.nanos_since_epoch
    }

    /// Add duration
    pub fn add(self: &SystemTime, duration: &Duration) -> SystemTime {
        SystemTime { nanos_since_epoch: self.nanos_since_epoch + duration.nanos }
    }

    /// Subtract duration
    pub fn sub(self: &SystemTime, duration: &Duration) -> SystemTime {
        SystemTime { nanos_since_epoch: self.nanos_since_epoch - duration.nanos }
    }
}

impl Add<Duration> for SystemTime {
    type Output = SystemTime;

    fn add(self, duration: Duration) -> SystemTime {
        SystemTime { nanos_since_epoch: self.nanos_since_epoch + duration.nanos }
    }
}

impl Sub<Duration> for SystemTime {
    type Output = SystemTime;

    fn sub(self, duration: Duration) -> SystemTime {
        SystemTime { nanos_since_epoch: self.nanos_since_epoch - duration.nanos }
    }
}

// =============================================================================
// Date Components
// =============================================================================

/// Represents a calendar date
pub struct Date {
    pub year: i32,
    pub month: u8,   // 1-12
    pub day: u8,     // 1-31
}

impl Date {
    /// Create a new date
    pub fn new(year: i32, month: u8, day: u8) -> Result<Date, TimeError> {
        if month < 1 || month > 12 {
            return Err(TimeError::InvalidMonth { month: month });
        }

        let max_day = days_in_month(year, month);
        if day < 1 || day > max_day {
            return Err(TimeError::InvalidDay { day: day, month: month, year: year });
        }

        Ok(Date { year: year, month: month, day: day })
    }

    /// Get today's date in UTC
    pub fn today() -> Date with IO {
        DateTime::now_utc().date()
    }

    /// Get today's date in local timezone
    pub fn today_local() -> Date with IO {
        DateTime::now_local().date()
    }

    /// Get day of week (0 = Sunday, 6 = Saturday)
    pub fn weekday(self: &Date) -> u8 {
        // Zeller's formula
        var y = self.year as i32;
        var m = self.month as i32;
        let d = self.day as i32;

        if m < 3 {
            m = m + 12;
            y = y - 1;
        }

        let k = y % 100;
        let j = y / 100;
        let h = (d + (13 * (m + 1)) / 5 + k + k / 4 + j / 4 - 2 * j) % 7;
        ((h + 6) % 7) as u8
    }

    /// Get day of year (1-366)
    pub fn day_of_year(self: &Date) -> u16 {
        var doy: u16 = 0;
        for m in 1..self.month {
            doy = doy + days_in_month(self.year, m) as u16;
        }
        doy + self.day as u16
    }

    /// Check if date is in a leap year
    pub fn is_leap_year(self: &Date) -> bool {
        is_leap_year(self.year)
    }

    /// Get ISO week number
    pub fn week_number(self: &Date) -> u8 {
        let doy = self.day_of_year();
        let dow = self.weekday();
        // ISO week starts on Monday (convert Sunday=0 to Monday=6, Mon=1 to 0, etc.)
        let iso_dow = if dow == 0 { 6 } else { dow - 1 };
        let week = (doy as i32 - iso_dow as i32 + 10) / 7;
        week as u8
    }

    /// Format date
    pub fn format(self: &Date, fmt: &str) -> String {
        format_date(self, fmt)
    }
}

impl ToString for Date {
    fn to_string(self) -> String {
        format!("{:04}-{:02}-{:02}", self.year, self.month, self.day)
    }
}

impl Eq for Date {}

impl PartialEq for Date {
    fn eq(self: &Date, other: &Date) -> bool {
        self.year == other.year && self.month == other.month && self.day == other.day
    }
}

impl Ord for Date {
    fn cmp(self: &Date, other: &Date) -> Ordering {
        match self.year.cmp(&other.year) {
            Ordering::Equal => match self.month.cmp(&other.month) {
                Ordering::Equal => self.day.cmp(&other.day),
                ord => ord,
            },
            ord => ord,
        }
    }
}

impl PartialOrd for Date {
    fn partial_cmp(self: &Date, other: &Date) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

/// Represents time of day
pub struct Time {
    pub hour: u8,    // 0-23
    pub minute: u8,  // 0-59
    pub second: u8,  // 0-59
    pub nano: u32,   // 0-999999999
}

impl Time {
    /// Create a new time
    pub fn new(hour: u8, minute: u8, second: u8) -> Result<Time, TimeError> {
        Time::with_nanos(hour, minute, second, 0)
    }

    /// Create a new time with nanoseconds
    pub fn with_nanos(hour: u8, minute: u8, second: u8, nano: u32) -> Result<Time, TimeError> {
        if hour > 23 {
            return Err(TimeError::InvalidHour { hour: hour });
        }
        if minute > 59 {
            return Err(TimeError::InvalidMinute { minute: minute });
        }
        if second > 59 {
            return Err(TimeError::InvalidSecond { second: second });
        }
        if nano > 999_999_999 {
            return Err(TimeError::InvalidNano { nano: nano });
        }

        Ok(Time { hour: hour, minute: minute, second: second, nano: nano })
    }

    /// Midnight (00:00:00)
    pub fn midnight() -> Time {
        Time { hour: 0, minute: 0, second: 0, nano: 0 }
    }

    /// Noon (12:00:00)
    pub fn noon() -> Time {
        Time { hour: 12, minute: 0, second: 0, nano: 0 }
    }

    /// Total seconds since midnight
    pub fn seconds_since_midnight(self: &Time) -> u32 {
        (self.hour as u32) * 3600 + (self.minute as u32) * 60 + (self.second as u32)
    }

    /// Total nanoseconds since midnight
    pub fn nanos_since_midnight(self: &Time) -> i64 {
        (self.seconds_since_midnight() as i64) * 1_000_000_000 + (self.nano as i64)
    }

    /// Format time
    pub fn format(self: &Time, fmt: &str) -> String {
        format_time(self, fmt)
    }
}

impl ToString for Time {
    fn to_string(self) -> String {
        format!("{:02}:{:02}:{:02}", self.hour, self.minute, self.second)
    }
}

impl Eq for Time {}

impl PartialEq for Time {
    fn eq(self: &Time, other: &Time) -> bool {
        self.hour == other.hour && self.minute == other.minute &&
        self.second == other.second && self.nano == other.nano
    }
}

// =============================================================================
// DateTime
// =============================================================================

/// Represents a date and time
pub struct DateTime {
    pub date: Date,
    pub time: Time,
    /// Offset from UTC in seconds
    pub offset: i32,
}

impl DateTime {
    /// Create a new DateTime
    pub fn new(date: Date, time: Time) -> DateTime {
        DateTime { date: date, time: time, offset: 0 }
    }

    /// Create DateTime with timezone offset
    pub fn with_offset(date: Date, time: Time, offset_hours: i32) -> DateTime {
        DateTime { date: date, time: time, offset: offset_hours * 3600 }
    }

    /// Get current UTC datetime
    pub fn now_utc() -> DateTime with IO {
        DateTime::from_system_time(&SystemTime::now(), 0)
    }

    /// Get current local datetime
    pub fn now_local() -> DateTime with IO {
        extern "C" {
            fn __sounio_local_timezone_offset() -> i32;
        }

        let offset = unsafe { __sounio_local_timezone_offset() };
        DateTime::from_system_time(&SystemTime::now(), offset)
    }

    /// Alias for now_local
    pub fn now() -> DateTime with IO {
        DateTime::now_local()
    }

    /// Create from Unix timestamp
    pub fn from_unix_timestamp(secs: i64) -> DateTime {
        DateTime::from_system_time(&SystemTime::from_unix_timestamp(secs), 0)
    }

    /// Create from system time
    pub fn from_system_time(st: &SystemTime, offset: i32) -> DateTime {
        let adjusted = st.nanos_since_epoch + (offset as i64) * 1_000_000_000;

        // Calculate date and time from timestamp
        let secs = adjusted / 1_000_000_000;
        let nanos = (adjusted % 1_000_000_000) as u32;

        // Days since epoch
        var days = secs / 86400;
        var day_secs = secs % 86400;
        if day_secs < 0 {
            days = days - 1;
            day_secs = day_secs + 86400;
        }

        // Calculate date components
        let date = date_from_days(days as i32);

        // Calculate time components
        let hour = (day_secs / 3600) as u8;
        let minute = ((day_secs % 3600) / 60) as u8;
        let second = (day_secs % 60) as u8;

        DateTime {
            date: date,
            time: Time { hour: hour, minute: minute, second: second, nano: nanos },
            offset: offset,
        }
    }

    /// Convert to Unix timestamp
    pub fn unix_timestamp(self: &DateTime) -> i64 {
        let days = days_from_date(&self.date);
        let secs = (days as i64) * 86400 +
                   (self.time.hour as i64) * 3600 +
                   (self.time.minute as i64) * 60 +
                   (self.time.second as i64);
        secs - (self.offset as i64)
    }

    /// Convert to SystemTime
    pub fn to_system_time(self: &DateTime) -> SystemTime {
        let secs = self.unix_timestamp();
        SystemTime::from_unix_timestamp_nanos(secs * 1_000_000_000 + self.time.nano as i64)
    }

    /// Get date component
    pub fn date(self: &DateTime) -> Date {
        self.date.clone()
    }

    /// Get time component
    pub fn time(self: &DateTime) -> Time {
        self.time.clone()
    }

    /// Is this datetime in UTC?
    pub fn is_utc(self: &DateTime) -> bool {
        self.offset == 0
    }

    /// Convert to UTC
    pub fn to_utc(self: &DateTime) -> DateTime {
        if self.offset == 0 {
            self.clone()
        } else {
            DateTime::from_system_time(&self.to_system_time(), 0)
        }
    }

    /// Convert to different timezone offset
    pub fn to_offset(self: &DateTime, offset_hours: i32) -> DateTime {
        DateTime::from_system_time(&self.to_system_time(), offset_hours * 3600)
    }

    /// Add duration
    pub fn add_duration(self: &DateTime, duration: &Duration) -> DateTime {
        let st = self.to_system_time();
        DateTime::from_system_time(&st.add(duration), self.offset)
    }

    /// Subtract duration
    pub fn sub_duration(self: &DateTime, duration: &Duration) -> DateTime {
        let st = self.to_system_time();
        DateTime::from_system_time(&st.sub(duration), self.offset)
    }

    /// Duration between two DateTimes
    pub fn duration_since(self: &DateTime, earlier: &DateTime) -> Duration {
        let self_st = self.to_system_time();
        let earlier_st = earlier.to_system_time();
        Duration { nanos: self_st.nanos_since_epoch - earlier_st.nanos_since_epoch }
    }

    /// Format datetime
    pub fn format(self: &DateTime, fmt: &str) -> String {
        format_datetime(self, fmt)
    }

    /// Parse datetime from string
    pub fn parse(s: &str, fmt: &str) -> Result<DateTime, TimeError> {
        parse_datetime(s, fmt)
    }
}

impl Add<Duration> for DateTime {
    type Output = DateTime;

    fn add(self, duration: Duration) -> DateTime {
        self.add_duration(&duration)
    }
}

impl Sub<Duration> for DateTime {
    type Output = DateTime;

    fn sub(self, duration: Duration) -> DateTime {
        self.sub_duration(&duration)
    }
}

impl ToString for DateTime {
    fn to_string(self) -> String {
        format!("{} {}", self.date.to_string(), self.time.to_string())
    }
}

// =============================================================================
// Errors
// =============================================================================

/// Error type for time operations
pub enum TimeError {
    InvalidMonth { month: u8 },
    InvalidDay { day: u8, month: u8, year: i32 },
    InvalidHour { hour: u8 },
    InvalidMinute { minute: u8 },
    InvalidSecond { second: u8 },
    InvalidNano { nano: u32 },
    ParseError { input: String, format: String, message: String },
    InvalidTimezone { tz: String },
}

impl TimeError {
    pub fn message(self) -> String {
        match self {
            TimeError::InvalidMonth { month } =>
                "Invalid month: " ++ month.to_string(),
            TimeError::InvalidDay { day, month, year } =>
                "Invalid day " ++ day.to_string() ++ " for " ++ year.to_string() ++ "-" ++ month.to_string(),
            TimeError::InvalidHour { hour } =>
                "Invalid hour: " ++ hour.to_string(),
            TimeError::InvalidMinute { minute } =>
                "Invalid minute: " ++ minute.to_string(),
            TimeError::InvalidSecond { second } =>
                "Invalid second: " ++ second.to_string(),
            TimeError::InvalidNano { nano } =>
                "Invalid nanosecond: " ++ nano.to_string(),
            TimeError::ParseError { input, format, message } =>
                "Failed to parse '" ++ input ++ "' with format '" ++ format ++ "': " ++ message,
            TimeError::InvalidTimezone { tz } =>
                "Invalid timezone: " ++ tz,
        }
    }
}

impl ToString for TimeError {
    fn to_string(self) -> String {
        self.message()
    }
}

// =============================================================================
// Helper Functions
// =============================================================================

/// Check if year is a leap year
pub fn is_leap_year(year: i32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

/// Days in month
pub fn days_in_month(year: i32, month: u8) -> u8 {
    match month {
        1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,
        4 | 6 | 9 | 11 => 30,
        2 => if is_leap_year(year) { 29 } else { 28 },
        _ => 0,
    }
}

/// Convert days since epoch to Date
fn date_from_days(days: i32) -> Date {
    // Algorithm from Howard Hinnant's date library
    var z = days + 719468;
    let era = if z >= 0 { z / 146097 } else { (z - 146096) / 146097 };
    let doe = z - era * 146097;
    let yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;
    let y = yoe + era * 400;
    let doy = doe - (365 * yoe + yoe / 4 - yoe / 100);
    let mp = (5 * doy + 2) / 153;
    let d = doy - (153 * mp + 2) / 5 + 1;
    let m = if mp < 10 { mp + 3 } else { mp - 9 };
    let year = if m <= 2 { y + 1 } else { y };

    Date { year: year as i32, month: m as u8, day: d as u8 }
}

/// Convert Date to days since epoch
fn days_from_date(date: &Date) -> i32 {
    let y = if date.month <= 2 { date.year - 1 } else { date.year };
    let era = if y >= 0 { y / 400 } else { (y - 399) / 400 };
    let yoe = y - era * 400;
    let m = date.month as i32;
    let doy = (153 * (if m > 2 { m - 3 } else { m + 9 }) + 2) / 5 + date.day as i32 - 1;
    let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
    era * 146097 + doe - 719468
}

/// Format date with pattern
fn format_date(date: &Date, fmt: &str) -> String {
    var result = "".to_string();
    var i: usize = 0;
    let len = fmt.len();

    while i < len {
        let c = fmt.char_at(i);
        if c == '%' && i + 1 < len {
            let spec = fmt.char_at(i + 1);
            match spec {
                'Y' => result = result ++ format!("{:04}", date.year),
                'y' => result = result ++ format!("{:02}", date.year % 100),
                'm' => result = result ++ format!("{:02}", date.month),
                'd' => result = result ++ format!("{:02}", date.day),
                'j' => result = result ++ format!("{:03}", date.day_of_year()),
                'w' => result = result ++ date.weekday().to_string(),
                'U' | 'W' => result = result ++ format!("{:02}", date.week_number()),
                'a' => result = result ++ short_weekday(date.weekday()),
                'A' => result = result ++ long_weekday(date.weekday()),
                'b' | 'h' => result = result ++ short_month(date.month),
                'B' => result = result ++ long_month(date.month),
                '%' => result = result ++ "%",
                _ => {
                    result = result ++ "%";
                    result = result ++ spec.to_string();
                },
            }
            i = i + 2;
        } else {
            result = result ++ c.to_string();
            i = i + 1;
        }
    }

    result
}

/// Format time with pattern
fn format_time(time: &Time, fmt: &str) -> String {
    var result = "".to_string();
    var i: usize = 0;
    let len = fmt.len();

    while i < len {
        let c = fmt.char_at(i);
        if c == '%' && i + 1 < len {
            let spec = fmt.char_at(i + 1);
            match spec {
                'H' => result = result ++ format!("{:02}", time.hour),
                'I' => {
                    let h = if time.hour == 0 { 12 } else if time.hour > 12 { time.hour - 12 } else { time.hour };
                    result = result ++ format!("{:02}", h);
                },
                'M' => result = result ++ format!("{:02}", time.minute),
                'S' => result = result ++ format!("{:02}", time.second),
                'f' => result = result ++ format!("{:06}", time.nano / 1000),
                'p' => result = result ++ if time.hour < 12 { "AM" } else { "PM" },
                'P' => result = result ++ if time.hour < 12 { "am" } else { "pm" },
                '%' => result = result ++ "%",
                _ => {
                    result = result ++ "%";
                    result = result ++ spec.to_string();
                },
            }
            i = i + 2;
        } else {
            result = result ++ c.to_string();
            i = i + 1;
        }
    }

    result
}

/// Format datetime with pattern
fn format_datetime(dt: &DateTime, fmt: &str) -> String {
    var result = "".to_string();
    var i: usize = 0;
    let len = fmt.len();

    while i < len {
        let c = fmt.char_at(i);
        if c == '%' && i + 1 < len {
            let spec = fmt.char_at(i + 1);
            match spec {
                // Date specifiers
                'Y' | 'y' | 'm' | 'd' | 'j' | 'w' | 'U' | 'W' | 'a' | 'A' | 'b' | 'h' | 'B' =>
                    result = result ++ format_date(&dt.date, fmt.slice(i, i + 2)),
                // Time specifiers
                'H' | 'I' | 'M' | 'S' | 'f' | 'p' | 'P' =>
                    result = result ++ format_time(&dt.time, fmt.slice(i, i + 2)),
                // Timezone
                'z' => {
                    let offset_mins = dt.offset / 60;
                    let sign = if offset_mins >= 0 { "+" } else { "-" };
                    let abs_mins = if offset_mins >= 0 { offset_mins } else { -offset_mins };
                    result = result ++ sign ++ format!("{:02}{:02}", abs_mins / 60, abs_mins % 60);
                },
                'Z' => result = result ++ if dt.offset == 0 { "UTC" } else { format!("UTC{:+}", dt.offset / 3600) },
                '%' => result = result ++ "%",
                _ => {
                    result = result ++ "%";
                    result = result ++ spec.to_string();
                },
            }
            i = i + 2;
        } else {
            result = result ++ c.to_string();
            i = i + 1;
        }
    }

    result
}

/// Parse datetime from string (simplified)
fn parse_datetime(s: &str, fmt: &str) -> Result<DateTime, TimeError> {
    // Simplified parser - handles common formats
    var year: i32 = 1970;
    var month: u8 = 1;
    var day: u8 = 1;
    var hour: u8 = 0;
    var minute: u8 = 0;
    var second: u8 = 0;
    var offset: i32 = 0;

    var si: usize = 0;
    var fi: usize = 0;

    while fi < fmt.len() && si < s.len() {
        let fc = fmt.char_at(fi);

        if fc == '%' && fi + 1 < fmt.len() {
            let spec = fmt.char_at(fi + 1);
            match spec {
                'Y' => {
                    let end = si + 4;
                    if end <= s.len() {
                        match s.slice(si, end).parse::<i32>() {
                            Ok(y) => year = y,
                            Err(_) => return Err(TimeError::ParseError {
                                input: s.to_string(),
                                format: fmt.to_string(),
                                message: "Invalid year".to_string(),
                            }),
                        }
                        si = end;
                    }
                },
                'm' => {
                    let end = si + 2;
                    if end <= s.len() {
                        match s.slice(si, end).parse::<u8>() {
                            Ok(m) => month = m,
                            Err(_) => return Err(TimeError::ParseError {
                                input: s.to_string(),
                                format: fmt.to_string(),
                                message: "Invalid month".to_string(),
                            }),
                        }
                        si = end;
                    }
                },
                'd' => {
                    let end = si + 2;
                    if end <= s.len() {
                        match s.slice(si, end).parse::<u8>() {
                            Ok(d) => day = d,
                            Err(_) => return Err(TimeError::ParseError {
                                input: s.to_string(),
                                format: fmt.to_string(),
                                message: "Invalid day".to_string(),
                            }),
                        }
                        si = end;
                    }
                },
                'H' => {
                    let end = si + 2;
                    if end <= s.len() {
                        match s.slice(si, end).parse::<u8>() {
                            Ok(h) => hour = h,
                            Err(_) => return Err(TimeError::ParseError {
                                input: s.to_string(),
                                format: fmt.to_string(),
                                message: "Invalid hour".to_string(),
                            }),
                        }
                        si = end;
                    }
                },
                'M' => {
                    let end = si + 2;
                    if end <= s.len() {
                        match s.slice(si, end).parse::<u8>() {
                            Ok(m) => minute = m,
                            Err(_) => return Err(TimeError::ParseError {
                                input: s.to_string(),
                                format: fmt.to_string(),
                                message: "Invalid minute".to_string(),
                            }),
                        }
                        si = end;
                    }
                },
                'S' => {
                    let end = si + 2;
                    if end <= s.len() {
                        match s.slice(si, end).parse::<u8>() {
                            Ok(sec) => second = sec,
                            Err(_) => return Err(TimeError::ParseError {
                                input: s.to_string(),
                                format: fmt.to_string(),
                                message: "Invalid second".to_string(),
                            }),
                        }
                        si = end;
                    }
                },
                '%' => {
                    if s.char_at(si) == '%' {
                        si = si + 1;
                    }
                },
                _ => {},
            }
            fi = fi + 2;
        } else {
            // Literal character
            if s.char_at(si) == fc {
                si = si + 1;
            }
            fi = fi + 1;
        }
    }

    let date = Date::new(year, month, day)?;
    let time = Time::new(hour, minute, second)?;

    Ok(DateTime { date: date, time: time, offset: offset })
}

/// Short weekday name
fn short_weekday(dow: u8) -> String {
    match dow {
        0 => "Sun".to_string(),
        1 => "Mon".to_string(),
        2 => "Tue".to_string(),
        3 => "Wed".to_string(),
        4 => "Thu".to_string(),
        5 => "Fri".to_string(),
        6 => "Sat".to_string(),
        _ => "???".to_string(),
    }
}

/// Long weekday name
fn long_weekday(dow: u8) -> String {
    match dow {
        0 => "Sunday".to_string(),
        1 => "Monday".to_string(),
        2 => "Tuesday".to_string(),
        3 => "Wednesday".to_string(),
        4 => "Thursday".to_string(),
        5 => "Friday".to_string(),
        6 => "Saturday".to_string(),
        _ => "Unknown".to_string(),
    }
}

/// Short month name
fn short_month(month: u8) -> String {
    match month {
        1 => "Jan".to_string(),
        2 => "Feb".to_string(),
        3 => "Mar".to_string(),
        4 => "Apr".to_string(),
        5 => "May".to_string(),
        6 => "Jun".to_string(),
        7 => "Jul".to_string(),
        8 => "Aug".to_string(),
        9 => "Sep".to_string(),
        10 => "Oct".to_string(),
        11 => "Nov".to_string(),
        12 => "Dec".to_string(),
        _ => "???".to_string(),
    }
}

/// Long month name
fn long_month(month: u8) -> String {
    match month {
        1 => "January".to_string(),
        2 => "February".to_string(),
        3 => "March".to_string(),
        4 => "April".to_string(),
        5 => "May".to_string(),
        6 => "June".to_string(),
        7 => "July".to_string(),
        8 => "August".to_string(),
        9 => "September".to_string(),
        10 => "October".to_string(),
        11 => "November".to_string(),
        12 => "December".to_string(),
        _ => "Unknown".to_string(),
    }
}

// =============================================================================
// Convenience Functions
// =============================================================================

/// Sleep for specified duration
pub fn sleep(duration: Duration) with IO, Async {
    extern "C" {
        fn __sounio_sleep_ns(nanos: i64);
    }

    unsafe { __sounio_sleep_ns(duration.nanos); }
}

/// Sleep for specified milliseconds
pub fn sleep_ms(ms: u64) with IO, Async {
    sleep(Duration::from_millis(ms as i64));
}

/// Sleep for specified seconds
pub fn sleep_secs(secs: u64) with IO, Async {
    sleep(Duration::from_secs(secs as i64));
}

/// Measure execution time of a function
pub fn measure<T, F: Fn() -> T>(f: F) -> (T, Duration) with IO {
    let start = Instant::now();
    let result = f();
    let elapsed = start.elapsed();
    (result, elapsed)
}

// =============================================================================
// Tests
// =============================================================================

fn main() -> i32 {
    print("Testing Time module...\n");

    // Test Duration
    let d1 = Duration::from_secs(60);
    let d2 = Duration::from_mins(1);
    if d1.as_secs() == 60 && d1 == d2 {
        print("Duration test: PASS\n");
    } else {
        print("Duration test: FAIL\n");
        return 1;
    }

    // Test Duration arithmetic
    let d3 = Duration::from_secs(30);
    let d4 = d1 + d3;
    if d4.as_secs() == 90 {
        print("Duration arithmetic test: PASS\n");
    } else {
        print("Duration arithmetic test: FAIL\n");
        return 1;
    }

    // Test Date
    match Date::new(2024, 2, 29) {
        Ok(d) => {
            if d.is_leap_year() {
                print("Leap year test: PASS\n");
            } else {
                print("Leap year test: FAIL\n");
                return 1;
            }
        },
        Err(_) => {
            print("Date creation test: FAIL\n");
            return 1;
        },
    }

    // Test invalid date
    match Date::new(2023, 2, 29) {
        Ok(_) => {
            print("Invalid date test: FAIL (should have failed)\n");
            return 1;
        },
        Err(_) => {
            print("Invalid date test: PASS\n");
        },
    }

    // Test formatting
    let date = Date { year: 2024, month: 1, day: 15 };
    let formatted = date.format("%Y-%m-%d");
    if formatted == "2024-01-15" {
        print("Date format test: PASS\n");
    } else {
        print("Date format test: FAIL\n");
        return 1;
    }

    // Test parsing
    match DateTime::parse("2024-01-15 10:30:00", "%Y-%m-%d %H:%M:%S") {
        Ok(dt) => {
            if dt.date.year == 2024 && dt.date.month == 1 && dt.date.day == 15 &&
               dt.time.hour == 10 && dt.time.minute == 30 {
                print("DateTime parse test: PASS\n");
            } else {
                print("DateTime parse test: FAIL (wrong values)\n");
                return 1;
            }
        },
        Err(e) => {
            print("DateTime parse test: FAIL (");
            print(e.to_string());
            print(")\n");
            return 1;
        },
    }

    print("All Time tests PASSED\n");
    0
}
