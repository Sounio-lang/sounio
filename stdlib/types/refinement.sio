// Refinement Type Helpers
//
// This module provides utility functions for working with refinement types
// in Sounio. Refinement types encode constraints directly in the type system,
// verified at compile-time via SMT solving.
//
// Usage:
//   use types::refinement::{try_refine, refine_or, clamp_to}

/// Try to create a refined value from a base value.
/// Returns Some(refined) if the value satisfies the constraint,
/// or None if it violates the constraint.
///
/// Example:
///   type Positive = { x: f64 | x > 0.0 }
///   let result = try_refine::<Positive>(input)
///   match result {
///       Some(p) => use_positive(p),
///       None => handle_error(),
///   }
pub fn try_refine<R>(value: BaseType<R>) -> Option<R> {
    if satisfies_constraint::<R>(value) {
        return Some(value)
    }
    return None
}

/// Create a refined value, using a default if constraint is violated.
///
/// Example:
///   type Probability = { p: f64 | 0.0 <= p && p <= 1.0 }
///   let prob = refine_or::<Probability>(input, 0.5)
pub fn refine_or<R>(value: BaseType<R>, default: R) -> R {
    match try_refine::<R>(value) {
        Some(refined) => refined,
        None => default,
    }
}

/// Clamp a value to satisfy the refinement constraint.
/// For bounded numeric refinements, clamps to the nearest valid value.
///
/// Example:
///   type Percentage = { p: f64 | 0.0 <= p && p <= 100.0 }
///   let pct = clamp_to::<Percentage>(150.0)  // Returns 100.0
pub fn clamp_to<R>(value: BaseType<R>) -> R
where R: BoundedRefinement {
    let lower = lower_bound::<R>()
    let upper = upper_bound::<R>()

    if value < lower {
        return lower
    } else if value > upper {
        return upper
    }
    return value
}

/// Check if a value satisfies the refinement constraint.
///
/// Example:
///   type Positive = { x: f64 | x > 0.0 }
///   if is_valid::<Positive>(input) {
///       // safe to use
///   }
pub fn is_valid<R>(value: BaseType<R>) -> bool {
    return satisfies_constraint::<R>(value)
}

/// Map a function over a refined value, returning None if the result
/// violates the constraint.
///
/// Example:
///   type Positive = { x: f64 | x > 0.0 }
///   let doubled = map_refined(pos, |x| x * 2.0)  // Still Positive
pub fn map_refined<R, F>(refined: R, f: F) -> Option<R>
where F: Fn(BaseType<R>) -> BaseType<R> {
    let result = f(refined)
    return try_refine::<R>(result)
}

/// Combine two refined values using a binary operation, returning None
/// if the result violates the constraint.
///
/// Example:
///   type Probability = { p: f64 | 0.0 <= p && p <= 1.0 }
///   let combined = combine_refined(p1, p2, |a, b| a * b)
pub fn combine_refined<R, F>(a: R, b: R, f: F) -> Option<R>
where F: Fn(BaseType<R>, BaseType<R>) -> BaseType<R> {
    let result = f(a, b)
    return try_refine::<R>(result)
}

// ============================================================================
// Common Refinement Types
// ============================================================================

/// Non-negative real number
pub type NonNegative = { x: f64 | x >= 0.0 }

/// Positive real number (strictly greater than zero)
pub type Positive = { x: f64 | x > 0.0 }

/// Probability value in [0, 1]
pub type Probability = { p: f64 | 0.0 <= p && p <= 1.0 }

/// Percentage value in [0, 100]
pub type Percentage = { p: f64 | 0.0 <= p && p <= 100.0 }

/// Unit interval [0, 1]
pub type UnitInterval = { x: f64 | 0.0 <= x && x <= 1.0 }

/// Non-zero integer
pub type NonZero = { x: i64 | x != 0 }

/// Positive integer
pub type PosInt = { x: i64 | x > 0 }

/// Natural number (non-negative integer)
pub type Natural = { x: i64 | x >= 0 }

// ============================================================================
// Scientific Domain Refinements
// ============================================================================

/// Concentration (non-negative, typically mg/L or similar)
pub type Concentration = { c: f64 | c >= 0.0 }

/// Volume (positive, typically L or mL)
pub type Volume = { v: f64 | v > 0.0 }

/// Mass (non-negative, typically kg, g, or mg)
pub type Mass = { m: f64 | m >= 0.0 }

/// Rate constant (positive, typically 1/h or 1/min)
pub type RateConstant = { k: f64 | k > 0.0 }

/// Half-life (positive, typically h or min)
pub type HalfLife = { t: f64 | t > 0.0 }

/// Bioavailability fraction (0 to 1)
pub type Bioavailability = { f: f64 | 0.0 <= f && f <= 1.0 }

/// Partition coefficient (positive)
pub type PartitionCoeff = { p: f64 | p > 0.0 }

// ============================================================================
// Assertion Helpers
// ============================================================================

/// Assert that a value satisfies a refinement, panicking with a message if not.
/// Use sparingly - prefer compile-time verification via type annotations.
pub fn assert_refined<R>(value: BaseType<R>, msg: string) with Panic {
    if !is_valid::<R>(value) {
        panic(msg)
    }
}

/// Debug assertion that a value satisfies a refinement.
/// Only checked in debug builds.
pub fn debug_assert_refined<R>(value: BaseType<R>, msg: string) {
    // In release builds, this is a no-op
    #[cfg(debug)]
    if !is_valid::<R>(value) {
        panic(msg)
    }
}

// ============================================================================
// Intrinsics (compiler-provided)
// ============================================================================

/// Check if a value satisfies a refinement type's constraint.
/// This is a compiler intrinsic that evaluates the type's predicate.
extern fn satisfies_constraint<R>(value: BaseType<R>) -> bool

/// Extract the base type from a refinement type.
/// This is a type-level operation provided by the compiler.
extern type BaseType<R>

/// Get the lower bound of a bounded refinement type.
extern fn lower_bound<R>() -> BaseType<R> where R: BoundedRefinement

/// Get the upper bound of a bounded refinement type.
extern fn upper_bound<R>() -> BaseType<R> where R: BoundedRefinement

/// Marker trait for refinement types with explicit bounds.
pub trait BoundedRefinement {}

// Implementations for common bounded types
impl BoundedRefinement for Probability {}
impl BoundedRefinement for Percentage {}
impl BoundedRefinement for UnitInterval {}
impl BoundedRefinement for Bioavailability {}
