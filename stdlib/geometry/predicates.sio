// Sounio Standard Library: Geometric Predicates
//
// First-order predicates for symbolic geometry reasoning.
// Each predicate is a Knowledge type with confidence and provenance.
// These form the atoms of the deductive database (DD) in AlphaGeometry.
//
// Predicates follow the AlphaGeometry DSL but with epistemic semantics:
// - Axiomatic predicates (from problem statement) have confidence = 1.0
// - Derived predicates inherit/decay confidence through inference
// - Neural-suggested predicates start with model confidence

import epistemic::Knowledge;
import epistemic::Confidence;
import epistemic::Source;
import epistemic::Evidence;
import geometry::types::*;

// =============================================================================
// Core Predicates (Atoms for Deductive Database)
// =============================================================================

/// Point equality predicate
@ontology("GEO:equal_points")
struct EqualPoints {
    p1: Point,
    p2: Point,
    status: Knowledge[bool],
}

impl EqualPoints {
    fn check(p1: Point, p2: Point, epsilon: f64) -> EqualPoints {
        let eq = p1.equals(p2, epsilon);
        EqualPoints { p1: p1, p2: p2, status: eq }
    }

    fn axiom(p1: Point, p2: Point) -> EqualPoints {
        EqualPoints {
            p1: p1,
            p2: p2,
            status: Knowledge::axiom(true),
        }
    }
}

/// Collinearity predicate: three points lie on a line
@ontology("GEO:collinear")
struct Collinear {
    p1: Point,
    p2: Point,
    p3: Point,
    status: Knowledge[bool],
}

impl Collinear {
    fn check(p1: Point, p2: Point, p3: Point) -> Collinear {
        let is_coll = is_collinear(p1, p2, p3);
        let conf = p1.x.confidence.min(p1.y.confidence)
                   .min(p2.x.confidence).min(p2.y.confidence)
                   .min(p3.x.confidence).min(p3.y.confidence);

        Collinear {
            p1: p1, p2: p2, p3: p3,
            status: Knowledge::derived(is_coll, conf, Source::Derivation("collinear_check")),
        }
    }

    fn axiom(p1: Point, p2: Point, p3: Point) -> Collinear {
        Collinear {
            p1: p1, p2: p2, p3: p3,
            status: Knowledge::axiom(true),
        }
    }
}

/// Concyclic predicate: four points lie on a circle
@ontology("GEO:concyclic")
struct Concyclic {
    p1: Point,
    p2: Point,
    p3: Point,
    p4: Point,
    status: Knowledge[bool],
}

impl Concyclic {
    fn check(p1: Point, p2: Point, p3: Point, p4: Point) -> Concyclic {
        let is_conc = is_concyclic(p1, p2, p3, p4);
        let conf = p1.x.confidence.min(p1.y.confidence)
                   .min(p2.x.confidence).min(p2.y.confidence)
                   .min(p3.x.confidence).min(p3.y.confidence)
                   .min(p4.x.confidence).min(p4.y.confidence);

        Concyclic {
            p1: p1, p2: p2, p3: p3, p4: p4,
            status: Knowledge::derived(is_conc, conf, Source::Derivation("concyclic_check")),
        }
    }

    fn axiom(p1: Point, p2: Point, p3: Point, p4: Point) -> Concyclic {
        Concyclic {
            p1: p1, p2: p2, p3: p3, p4: p4,
            status: Knowledge::axiom(true),
        }
    }
}

/// Parallel lines predicate
@ontology("GEO:parallel")
struct Parallel {
    l1: Line,
    l2: Line,
    status: Knowledge[bool],
}

impl Parallel {
    fn check(l1: Line, l2: Line) -> Parallel {
        let is_para = is_parallel(l1, l2);
        let conf = l1.a.confidence.min(l1.b.confidence)
                   .min(l2.a.confidence).min(l2.b.confidence);

        Parallel {
            l1: l1, l2: l2,
            status: Knowledge::derived(is_para, conf, Source::Derivation("parallel_check")),
        }
    }

    fn axiom(l1: Line, l2: Line) -> Parallel {
        Parallel {
            l1: l1, l2: l2,
            status: Knowledge::axiom(true),
        }
    }

    /// Parallel through points: line(p1,p2) || line(p3,p4)
    fn through_points(p1: Point, p2: Point, p3: Point, p4: Point) -> Parallel {
        let l1 = Line::through(p1, p2);
        let l2 = Line::through(p3, p4);
        Parallel::check(l1, l2)
    }
}

/// Perpendicular lines predicate
@ontology("GEO:perpendicular")
struct Perpendicular {
    l1: Line,
    l2: Line,
    status: Knowledge[bool],
}

impl Perpendicular {
    fn check(l1: Line, l2: Line) -> Perpendicular {
        let is_perp = is_perpendicular(l1, l2);
        let conf = l1.a.confidence.min(l1.b.confidence)
                   .min(l2.a.confidence).min(l2.b.confidence);

        Perpendicular {
            l1: l1, l2: l2,
            status: Knowledge::derived(is_perp, conf, Source::Derivation("perpendicular_check")),
        }
    }

    fn axiom(l1: Line, l2: Line) -> Perpendicular {
        Perpendicular {
            l1: l1, l2: l2,
            status: Knowledge::axiom(true),
        }
    }

    fn through_points(p1: Point, p2: Point, p3: Point, p4: Point) -> Perpendicular {
        let l1 = Line::through(p1, p2);
        let l2 = Line::through(p3, p4);
        Perpendicular::check(l1, l2)
    }
}

/// Equal lengths predicate
@ontology("GEO:equal_length")
struct EqualLength {
    seg1: Segment,
    seg2: Segment,
    status: Knowledge[bool],
}

impl EqualLength {
    fn check(seg1: Segment, seg2: Segment) -> EqualLength {
        let l1 = seg1.length();
        let l2 = seg2.length();
        let eq = eq_length(l1, l2);
        let conf = l1.confidence.min(l2.confidence);

        EqualLength {
            seg1: seg1, seg2: seg2,
            status: Knowledge::derived(eq, conf, Source::Derivation("equal_length_check")),
        }
    }

    fn axiom(seg1: Segment, seg2: Segment) -> EqualLength {
        EqualLength {
            seg1: seg1, seg2: seg2,
            status: Knowledge::axiom(true),
        }
    }

    fn from_points(a: Point, b: Point, c: Point, d: Point) -> EqualLength {
        let seg1 = Segment::new(a, b);
        let seg2 = Segment::new(c, d);
        EqualLength::check(seg1, seg2)
    }
}

/// Equal angles predicate
@ontology("GEO:equal_angle")
struct EqualAngle {
    angle1: AngleABC,
    angle2: AngleABC,
    status: Knowledge[bool],
}

impl EqualAngle {
    fn check(angle1: AngleABC, angle2: AngleABC) -> EqualAngle {
        let m1 = angle1.measure();
        let m2 = angle2.measure();
        let eq = (m1.value.to_radians() - m2.value.to_radians()).abs() < 1e-9;
        let conf = m1.confidence.min(m2.confidence);

        EqualAngle {
            angle1: angle1, angle2: angle2,
            status: Knowledge::derived(eq, conf, Source::Derivation("equal_angle_check")),
        }
    }

    fn axiom(angle1: AngleABC, angle2: AngleABC) -> EqualAngle {
        EqualAngle {
            angle1: angle1, angle2: angle2,
            status: Knowledge::axiom(true),
        }
    }
}

/// Right angle predicate
@ontology("GEO:right_angle")
struct RightAngle {
    angle: AngleABC,
    status: Knowledge[bool],
}

impl RightAngle {
    fn check(angle: AngleABC) -> RightAngle {
        let is_right = angle.is_right();
        RightAngle { angle: angle, status: is_right }
    }

    fn axiom(angle: AngleABC) -> RightAngle {
        RightAngle {
            angle: angle,
            status: Knowledge::axiom(true),
        }
    }

    fn from_points(a: Point, vertex: Point, c: Point) -> RightAngle {
        let angle = AngleABC::new(a, vertex, c);
        RightAngle::check(angle)
    }
}

/// Point on line predicate
@ontology("GEO:on_line")
struct OnLine {
    point: Point,
    line: Line,
    status: Knowledge[bool],
}

impl OnLine {
    fn check(point: Point, line: Line) -> OnLine {
        let on = line.contains(point);
        OnLine { point: point, line: line, status: on }
    }

    fn axiom(point: Point, line: Line) -> OnLine {
        OnLine {
            point: point, line: line,
            status: Knowledge::axiom(true),
        }
    }
}

/// Point on circle predicate
@ontology("GEO:on_circle")
struct OnCircle {
    point: Point,
    circle: Circle,
    status: Knowledge[bool],
}

impl OnCircle {
    fn check(point: Point, circle: Circle) -> OnCircle {
        let on = circle.contains(point);
        OnCircle { point: point, circle: circle, status: on }
    }

    fn axiom(point: Point, circle: Circle) -> OnCircle {
        OnCircle {
            point: point, circle: circle,
            status: Knowledge::axiom(true),
        }
    }
}

/// Midpoint predicate
@ontology("GEO:midpoint")
struct Midpoint {
    mid: Point,
    p1: Point,
    p2: Point,
    status: Knowledge[bool],
}

impl Midpoint {
    fn check(mid: Point, p1: Point, p2: Point) -> Midpoint {
        let actual_mid = Segment::new(p1, p2).midpoint();
        let is_mid = mid.equals(actual_mid, 1e-9);
        Midpoint { mid: mid, p1: p1, p2: p2, status: is_mid }
    }

    fn axiom(mid: Point, p1: Point, p2: Point) -> Midpoint {
        Midpoint {
            mid: mid, p1: p1, p2: p2,
            status: Knowledge::axiom(true),
        }
    }
}

/// Angle bisector predicate
@ontology("GEO:angle_bisector")
struct AngleBisector {
    ray: Line,
    angle: AngleABC,
    status: Knowledge[bool],
}

impl AngleBisector {
    fn check(ray: Line, angle: AngleABC) -> AngleBisector {
        let actual_bisector = angle.bisector();
        // Check if lines are same (direction may differ)
        let same_line = is_parallel(ray, actual_bisector) &&
                        ray.contains(angle.b).value;

        let conf = ray.a.confidence.min(ray.b.confidence)
                   .min(angle.a.x.confidence).min(angle.b.x.confidence).min(angle.c.x.confidence);

        AngleBisector {
            ray: ray, angle: angle,
            status: Knowledge::derived(same_line, conf, Source::Derivation("bisector_check")),
        }
    }

    fn axiom(ray: Line, angle: AngleABC) -> AngleBisector {
        AngleBisector {
            ray: ray, angle: angle,
            status: Knowledge::axiom(true),
        }
    }
}

/// Perpendicular bisector predicate
@ontology("GEO:perp_bisector")
struct PerpBisector {
    line: Line,
    segment: Segment,
    status: Knowledge[bool],
}

impl PerpBisector {
    fn check(line: Line, segment: Segment) -> PerpBisector {
        let actual_perp = segment.perpendicular_bisector();
        let same = is_parallel(line, actual_perp) &&
                   line.contains(segment.midpoint()).value;

        let conf = line.a.confidence.min(line.b.confidence)
                   .min(segment.start.x.confidence).min(segment.end.x.confidence);

        PerpBisector {
            line: line, segment: segment,
            status: Knowledge::derived(same, conf, Source::Derivation("perp_bisector_check")),
        }
    }

    fn axiom(line: Line, segment: Segment) -> PerpBisector {
        PerpBisector {
            line: line, segment: segment,
            status: Knowledge::axiom(true),
        }
    }
}

/// Circle center predicate
@ontology("GEO:circle_center")
struct CircleCenter {
    center: Point,
    circle: Circle,
    status: Knowledge[bool],
}

impl CircleCenter {
    fn check(center: Point, circle: Circle) -> CircleCenter {
        let is_center = center.equals(circle.center, 1e-9);
        CircleCenter { center: center, circle: circle, status: is_center }
    }

    fn axiom(center: Point, circle: Circle) -> CircleCenter {
        CircleCenter {
            center: center, circle: circle,
            status: Knowledge::axiom(true),
        }
    }
}

/// Tangent line to circle predicate
@ontology("GEO:tangent")
struct Tangent {
    line: Line,
    circle: Circle,
    point: Point,  // Point of tangency
    status: Knowledge[bool],
}

impl Tangent {
    fn check(line: Line, circle: Circle, point: Point) -> Tangent {
        // Line is tangent if:
        // 1. Point is on circle
        // 2. Point is on line
        // 3. Line is perpendicular to radius at point
        let on_circle = circle.contains(point);
        let on_line = line.contains(point);
        let radius_line = Line::through(circle.center, point);
        let is_perp = is_perpendicular(line, radius_line);

        let is_tangent = on_circle.value && on_line.value && is_perp;
        let conf = on_circle.confidence.min(on_line.confidence)
                   .min(line.a.confidence).min(circle.radius.confidence);

        Tangent {
            line: line, circle: circle, point: point,
            status: Knowledge::derived(is_tangent, conf, Source::Derivation("tangent_check")),
        }
    }

    fn axiom(line: Line, circle: Circle, point: Point) -> Tangent {
        Tangent {
            line: line, circle: circle, point: point,
            status: Knowledge::axiom(true),
        }
    }
}

/// Similar triangles predicate
@ontology("GEO:similar")
struct Similar {
    t1: Triangle,
    t2: Triangle,
    status: Knowledge[bool],
}

impl Similar {
    fn check(t1: Triangle, t2: Triangle) -> Similar {
        // Check if corresponding angles are equal (AA similarity)
        let angles1 = [
            AngleABC::new(t1.b, t1.a, t1.c).measure(),
            AngleABC::new(t1.a, t1.b, t1.c).measure(),
            AngleABC::new(t1.a, t1.c, t1.b).measure(),
        ];
        let angles2 = [
            AngleABC::new(t2.b, t2.a, t2.c).measure(),
            AngleABC::new(t2.a, t2.b, t2.c).measure(),
            AngleABC::new(t2.a, t2.c, t2.b).measure(),
        ];

        // Sort and compare (order-independent)
        let mut a1: Vec[f64] = angles1.iter().map(|a| a.value.to_radians()).collect();
        let mut a2: Vec[f64] = angles2.iter().map(|a| a.value.to_radians()).collect();
        a1.sort();
        a2.sort();

        let is_sim = a1.iter().zip(a2.iter())
                       .all(|(x, y)| (x - y).abs() < 1e-6);

        let conf = angles1.iter().chain(angles2.iter())
                          .map(|a| a.confidence)
                          .min()
                          .unwrap_or(Confidence::new(0.0));

        Similar {
            t1: t1, t2: t2,
            status: Knowledge::derived(is_sim, conf, Source::Derivation("similar_check")),
        }
    }

    fn axiom(t1: Triangle, t2: Triangle) -> Similar {
        Similar {
            t1: t1, t2: t2,
            status: Knowledge::axiom(true),
        }
    }
}

/// Congruent triangles predicate
@ontology("GEO:congruent")
struct Congruent {
    t1: Triangle,
    t2: Triangle,
    status: Knowledge[bool],
}

impl Congruent {
    fn check(t1: Triangle, t2: Triangle) -> Congruent {
        // Check if all corresponding sides are equal (SSS)
        let (a1, b1, c1) = t1.sides();
        let (a2, b2, c2) = t2.sides();

        let mut sides1 = vec![a1.value.to_meters(), b1.value.to_meters(), c1.value.to_meters()];
        let mut sides2 = vec![a2.value.to_meters(), b2.value.to_meters(), c2.value.to_meters()];
        sides1.sort_by(|a, b| a.partial_cmp(b).unwrap());
        sides2.sort_by(|a, b| a.partial_cmp(b).unwrap());

        let is_cong = sides1.iter().zip(sides2.iter())
                            .all(|(x, y)| (x - y).abs() < 1e-6);

        let conf = a1.confidence.min(b1.confidence).min(c1.confidence)
                   .min(a2.confidence).min(b2.confidence).min(c2.confidence);

        Congruent {
            t1: t1, t2: t2,
            status: Knowledge::derived(is_cong, conf, Source::Derivation("congruent_check")),
        }
    }

    fn axiom(t1: Triangle, t2: Triangle) -> Congruent {
        Congruent {
            t1: t1, t2: t2,
            status: Knowledge::axiom(true),
        }
    }
}

// =============================================================================
// Predicate Enumeration (for Deductive Database)
// =============================================================================

/// All predicate types for DD storage
enum Predicate {
    Collin(Collinear),
    Concyc(Concyclic),
    Para(Parallel),
    Perp(Perpendicular),
    EqLen(EqualLength),
    EqAng(EqualAngle),
    Right(RightAngle),
    OnLn(OnLine),
    OnCir(OnCircle),
    Mid(Midpoint),
    Bisect(AngleBisector),
    PerpBis(PerpBisector),
    Center(CircleCenter),
    Tang(Tangent),
    Sim(Similar),
    Cong(Congruent),
    EqPt(EqualPoints),
}

impl Predicate {
    /// Get confidence of this predicate
    fn confidence(self) -> Confidence {
        match self {
            Predicate::Collin(p) => p.status.confidence,
            Predicate::Concyc(p) => p.status.confidence,
            Predicate::Para(p) => p.status.confidence,
            Predicate::Perp(p) => p.status.confidence,
            Predicate::EqLen(p) => p.status.confidence,
            Predicate::EqAng(p) => p.status.confidence,
            Predicate::Right(p) => p.status.confidence,
            Predicate::OnLn(p) => p.status.confidence,
            Predicate::OnCir(p) => p.status.confidence,
            Predicate::Mid(p) => p.status.confidence,
            Predicate::Bisect(p) => p.status.confidence,
            Predicate::PerpBis(p) => p.status.confidence,
            Predicate::Center(p) => p.status.confidence,
            Predicate::Tang(p) => p.status.confidence,
            Predicate::Sim(p) => p.status.confidence,
            Predicate::Cong(p) => p.status.confidence,
            Predicate::EqPt(p) => p.status.confidence,
        }
    }

    /// Check if predicate is true (with confidence threshold)
    fn is_true(self, threshold: f64) -> bool {
        self.confidence().value() >= threshold
    }

    /// Get unique key for deduplication
    fn key(self) -> String {
        match self {
            Predicate::Collin(p) => format!("coll:{}:{}:{}", p.p1.id, p.p2.id, p.p3.id),
            Predicate::Concyc(p) => format!("conc:{}:{}:{}:{}", p.p1.id, p.p2.id, p.p3.id, p.p4.id),
            Predicate::Para(p) => format!("para:{}:{}", p.l1.id, p.l2.id),
            Predicate::Perp(p) => format!("perp:{}:{}", p.l1.id, p.l2.id),
            Predicate::EqLen(p) => format!("eqlen:{}:{}", p.seg1.id, p.seg2.id),
            Predicate::EqAng(p) => format!("eqang:{}:{}", p.angle1.id, p.angle2.id),
            Predicate::Right(p) => format!("right:{}", p.angle.id),
            Predicate::OnLn(p) => format!("onln:{}:{}", p.point.id, p.line.id),
            Predicate::OnCir(p) => format!("oncir:{}:{}", p.point.id, p.circle.id),
            Predicate::Mid(p) => format!("mid:{}:{}:{}", p.mid.id, p.p1.id, p.p2.id),
            Predicate::Bisect(p) => format!("bisect:{}:{}", p.ray.id, p.angle.id),
            Predicate::PerpBis(p) => format!("perpbis:{}:{}", p.line.id, p.segment.id),
            Predicate::Center(p) => format!("center:{}:{}", p.center.id, p.circle.id),
            Predicate::Tang(p) => format!("tang:{}:{}:{}", p.line.id, p.circle.id, p.point.id),
            Predicate::Sim(p) => format!("sim:{}:{}", p.t1.id, p.t2.id),
            Predicate::Cong(p) => format!("cong:{}:{}", p.t1.id, p.t2.id),
            Predicate::EqPt(p) => format!("eqpt:{}:{}", p.p1.id, p.p2.id),
        }
    }
}

// =============================================================================
// Construction Types (for Neural Suggestions)
// =============================================================================

/// Types of geometric constructions that can be suggested by LM
enum ConstructionType {
    /// Construct midpoint of segment
    ConstructMidpoint { p1: String, p2: String },

    /// Construct perpendicular from point to line
    ConstructPerpendicular { point: String, line_p1: String, line_p2: String },

    /// Construct parallel through point
    ConstructParallel { point: String, line_p1: String, line_p2: String },

    /// Construct circle through three points
    ConstructCircumcircle { p1: String, p2: String, p3: String },

    /// Construct angle bisector
    ConstructBisector { p1: String, vertex: String, p2: String },

    /// Construct intersection of lines
    ConstructLineIntersection { l1_p1: String, l1_p2: String, l2_p1: String, l2_p2: String },

    /// Construct intersection of line and circle
    ConstructLineCircleIntersection { line_p1: String, line_p2: String, circle_center: String, circle_point: String },

    /// Construct intersection of two circles
    ConstructCircleCircleIntersection { c1_center: String, c1_point: String, c2_center: String, c2_point: String },

    /// Construct reflection of point over line
    ConstructReflection { point: String, line_p1: String, line_p2: String },

    /// Construct foot of perpendicular (projection)
    ConstructFoot { point: String, line_p1: String, line_p2: String },
}

/// A construction with epistemic metadata
struct Construction {
    /// Type of construction
    kind: ConstructionType,
    /// Confidence from neural model
    confidence: Confidence,
    /// Resulting new points/objects
    result_ids: Vec[String],
    /// Source (neural or symbolic)
    source: Source,
}

impl Construction {
    /// Create construction from neural prediction
    fn from_neural(kind: ConstructionType, confidence: f64, result_ids: Vec[String]) -> Construction {
        Construction {
            kind: kind,
            confidence: Confidence::new(confidence),
            result_ids: result_ids,
            source: Source::ModelPrediction {
                model: "geometry_lm".to_string(),
                version: Some("alphageometry-d".to_string()),
            },
        }
    }

    /// Create construction from symbolic reasoning
    fn from_symbolic(kind: ConstructionType, result_ids: Vec[String]) -> Construction {
        Construction {
            kind: kind,
            confidence: Confidence::new(1.0),
            result_ids: result_ids,
            source: Source::Derivation("symbolic_construction".to_string()),
        }
    }
}
