// Sounio Standard Library: Geometry Deduction Engine
//
// Symbolic reasoning engine for geometry based on AlphaGeometry's DD+AR.
// Implements forward chaining deduction with algebraic effects.
//
// Key components:
// - DD (Deductive Database): Forward-chaining from definitions/theorems
// - AR (Algebraic Reasoning): Coordinate-based verification
// - Effects: Search, Deduce, Construct (composable via handlers)
//
// Native Sounio advantages:
// - Epistemic propagation through inference chains
// - Compile-time refinement checking for invalid constructions
// - Provenance tracking for human-readable proof generation

import epistemic::Knowledge;
import epistemic::Confidence;
import epistemic::Source;
import epistemic::Provenance;
import epistemic::bayesian::*;
import geometry::types::*;
import geometry::predicates::*;

// =============================================================================
// Proof State
// =============================================================================

/// Current state of geometric knowledge during proof search
struct ProofState {
    /// All known points
    points: Map[String, Point],

    /// All known lines
    lines: Map[String, Line],

    /// All known circles
    circles: Map[String, Circle],

    /// All established predicates (deductive database)
    predicates: Map[String, Predicate],

    /// Goal predicate to prove
    goal: Option[Predicate],

    /// Proof trace (for human-readable output)
    trace: Vec[ProofStep],

    /// Overall confidence in current state
    confidence: BetaConfidence,

    /// Constructions applied
    constructions: Vec[Construction],
}

/// A single step in the proof
struct ProofStep {
    /// What was derived
    predicate: Predicate,
    /// Rule used
    rule: String,
    /// Premises used
    premises: Vec[String],
    /// Confidence at this step
    confidence: Confidence,
    /// Provenance chain
    provenance: Provenance,
}

impl ProofState {
    /// Create empty state
    fn new() -> ProofState {
        ProofState {
            points: Map::new(),
            lines: Map::new(),
            circles: Map::new(),
            predicates: Map::new(),
            goal: None,
            trace: vec![],
            confidence: BetaConfidence::uniform_prior(),
            constructions: vec![],
        }
    }

    /// Add a point to the state
    fn add_point(mut self, point: Point) -> ProofState {
        self.points.insert(point.id.clone(), point);
        self
    }

    /// Add a line to the state
    fn add_line(mut self, line: Line) -> ProofState {
        self.lines.insert(line.id.clone(), line);
        self
    }

    /// Add a circle to the state
    fn add_circle(mut self, circle: Circle) -> ProofState {
        self.circles.insert(circle.id.clone(), circle);
        self
    }

    /// Add a predicate (fact) to the database
    fn add_predicate(mut self, pred: Predicate) -> ProofState {
        let key = pred.key();
        if !self.predicates.contains_key(&key) {
            // Update confidence with new evidence
            let pred_conf = pred.confidence().value();
            self.confidence.update(pred_conf, 1.0 - pred_conf);

            self.predicates.insert(key, pred);
        }
        self
    }

    /// Record a proof step
    fn record_step(mut self, step: ProofStep) -> ProofState {
        self.trace.push(step);
        self
    }

    /// Set the goal to prove
    fn set_goal(mut self, goal: Predicate) -> ProofState {
        self.goal = Some(goal);
        self
    }

    /// Check if goal is satisfied
    fn goal_satisfied(self) -> bool {
        match &self.goal {
            Some(goal) => {
                let key = goal.key();
                self.predicates.contains_key(&key) &&
                self.predicates.get(&key).unwrap().is_true(0.9)
            },
            None => false,
        }
    }

    /// Get point by ID
    fn get_point(self, id: &str) -> Option[Point] {
        self.points.get(id).cloned()
    }

    /// Get all points
    fn all_points(self) -> Vec[Point] {
        self.points.values().cloned().collect()
    }

    /// Get all predicates of a specific type
    fn predicates_of_type<T>(self, extractor: fn(Predicate) -> Option[T]) -> Vec[T] {
        self.predicates.values()
            .filter_map(|p| extractor(p.clone()))
            .collect()
    }
}

// =============================================================================
// Algebraic Effects for Deduction
// =============================================================================

/// Effect for symbolic deduction
effect deduce {
    /// Apply a deduction rule, returning new predicates
    fn apply_rule(state: ProofState, rule: DeductionRule) -> Vec[Predicate];

    /// Check if a predicate can be derived
    fn can_derive(state: ProofState, target: Predicate) -> bool;

    /// Get all applicable rules for current state
    fn applicable_rules(state: ProofState) -> Vec[DeductionRule];
}

/// Effect for construction (neural or symbolic)
effect construct {
    /// Suggest auxiliary constructions
    fn suggest(state: ProofState) -> Vec[Construction] with epistemic;

    /// Apply a construction, returning new state
    fn apply(state: ProofState, construction: Construction) -> ProofState;

    /// Validate a construction (refinement check)
    fn validate(construction: Construction) -> bool;
}

/// Effect for proof search
effect search {
    /// Perform one step of search
    fn step(state: ProofState) -> SearchResult;

    /// Check if search should continue
    fn should_continue(state: ProofState, depth: i32) -> bool;

    /// Backtrack to previous state
    fn backtrack() -> ProofState;
}

/// Result of a search step
enum SearchResult {
    /// Goal proven
    Proven(ProofState),
    /// Made progress (new predicates derived)
    Progress(ProofState),
    /// Stuck (need construction)
    Stuck(ProofState),
    /// Failed (contradiction or timeout)
    Failed(String),
}

// =============================================================================
// Deduction Rules
// =============================================================================

/// A deduction rule from the rule database
struct DeductionRule {
    /// Rule name (for tracing)
    name: String,
    /// Premises required
    premises: Vec[PredicatePattern],
    /// Conclusion to derive
    conclusion: PredicatePattern,
    /// Confidence decay through this rule
    confidence_factor: f64,
}

/// Pattern for matching predicates
enum PredicatePattern {
    /// Match collinear(P1, P2, P3)
    CollinearPat { p1: String, p2: String, p3: String },
    /// Match parallel(L1, L2)
    ParallelPat { l1: String, l2: String },
    /// Match perpendicular(L1, L2)
    PerpendicularPat { l1: String, l2: String },
    /// Match equal_length(S1, S2)
    EqualLengthPat { s1: String, s2: String },
    /// Match on_circle(P, C)
    OnCirclePat { point: String, circle: String },
    /// Match concyclic(P1, P2, P3, P4)
    ConcyclicPat { p1: String, p2: String, p3: String, p4: String },
    /// Wildcard (any predicate)
    Any { var: String },
}

impl DeductionRule {
    /// Create transitivity rule for collinearity
    fn collinear_transitivity() -> DeductionRule {
        // If collinear(A,B,C) and collinear(A,B,D) then collinear(C,B,D)
        DeductionRule {
            name: "collinear_transitivity".to_string(),
            premises: vec![
                PredicatePattern::CollinearPat { p1: "A".to_string(), p2: "B".to_string(), p3: "C".to_string() },
                PredicatePattern::CollinearPat { p1: "A".to_string(), p2: "B".to_string(), p3: "D".to_string() },
            ],
            conclusion: PredicatePattern::CollinearPat { p1: "C".to_string(), p2: "B".to_string(), p3: "D".to_string() },
            confidence_factor: 0.99,
        }
    }

    /// Create parallel transitivity rule
    fn parallel_transitivity() -> DeductionRule {
        // If parallel(L1,L2) and parallel(L2,L3) then parallel(L1,L3)
        DeductionRule {
            name: "parallel_transitivity".to_string(),
            premises: vec![
                PredicatePattern::ParallelPat { l1: "L1".to_string(), l2: "L2".to_string() },
                PredicatePattern::ParallelPat { l1: "L2".to_string(), l2: "L3".to_string() },
            ],
            conclusion: PredicatePattern::ParallelPat { l1: "L1".to_string(), l2: "L3".to_string() },
            confidence_factor: 0.99,
        }
    }

    /// Inscribed angle theorem
    fn inscribed_angle() -> DeductionRule {
        // If on_circle(A,C) and on_circle(B,C) and on_circle(P,C) and on_circle(Q,C)
        // and center(O,C) then angle(APB) = angle(AQB) (when on same arc)
        DeductionRule {
            name: "inscribed_angle_theorem".to_string(),
            premises: vec![
                PredicatePattern::OnCirclePat { point: "A".to_string(), circle: "C".to_string() },
                PredicatePattern::OnCirclePat { point: "B".to_string(), circle: "C".to_string() },
                PredicatePattern::OnCirclePat { point: "P".to_string(), circle: "C".to_string() },
                PredicatePattern::OnCirclePat { point: "Q".to_string(), circle: "C".to_string() },
            ],
            conclusion: PredicatePattern::Any { var: "equal_inscribed_angles".to_string() },
            confidence_factor: 0.98,
        }
    }

    /// Cyclic quadrilateral: opposite angles supplementary
    fn cyclic_quadrilateral() -> DeductionRule {
        DeductionRule {
            name: "cyclic_quadrilateral".to_string(),
            premises: vec![
                PredicatePattern::ConcyclicPat {
                    p1: "A".to_string(),
                    p2: "B".to_string(),
                    p3: "C".to_string(),
                    p4: "D".to_string()
                },
            ],
            conclusion: PredicatePattern::Any { var: "opposite_angles_supplementary".to_string() },
            confidence_factor: 0.99,
        }
    }

    /// Midpoint theorem: line through midpoints parallel to third side
    fn midpoint_theorem() -> DeductionRule {
        DeductionRule {
            name: "midpoint_theorem".to_string(),
            premises: vec![
                PredicatePattern::Any { var: "midpoint_M_AB".to_string() },
                PredicatePattern::Any { var: "midpoint_N_AC".to_string() },
            ],
            conclusion: PredicatePattern::ParallelPat { l1: "MN".to_string(), l2: "BC".to_string() },
            confidence_factor: 0.99,
        }
    }
}

/// Standard rule database (subset of AlphaGeometry's rules.txt)
fn standard_rules() -> Vec[DeductionRule] {
    vec![
        DeductionRule::collinear_transitivity(),
        DeductionRule::parallel_transitivity(),
        DeductionRule::inscribed_angle(),
        DeductionRule::cyclic_quadrilateral(),
        DeductionRule::midpoint_theorem(),
        // Add more rules as needed...
    ]
}

// =============================================================================
// Deduction Engine Implementation
// =============================================================================

/// Forward-chaining deduction engine
struct DeductionEngine {
    /// Rules to apply
    rules: Vec[DeductionRule],
    /// Maximum iterations
    max_iterations: i32,
    /// Confidence threshold for accepting derivations
    confidence_threshold: f64,
}

impl DeductionEngine {
    fn new() -> DeductionEngine {
        DeductionEngine {
            rules: standard_rules(),
            max_iterations: 1000,
            confidence_threshold: 0.8,
        }
    }

    /// Run forward chaining until fixpoint or goal
    fn deduce_all(self, mut state: ProofState) -> ProofState {
        let mut changed = true;
        let mut iterations = 0;

        while changed && iterations < self.max_iterations && !state.goal_satisfied() {
            changed = false;
            iterations += 1;

            for rule in &self.rules {
                let new_preds = self.try_apply_rule(&state, rule);
                for pred in new_preds {
                    if pred.confidence().value() >= self.confidence_threshold {
                        let key = pred.key();
                        if !state.predicates.contains_key(&key) {
                            // Record proof step
                            let step = ProofStep {
                                predicate: pred.clone(),
                                rule: rule.name.clone(),
                                premises: vec![], // TODO: track actual premises
                                confidence: pred.confidence(),
                                provenance: Provenance::derived(&rule.name),
                            };
                            state = state.add_predicate(pred);
                            state = state.record_step(step);
                            changed = true;
                        }
                    }
                }
            }
        }

        state
    }

    /// Try to apply a rule, returning any new predicates
    fn try_apply_rule(self, state: &ProofState, rule: &DeductionRule) -> Vec[Predicate] {
        // Pattern matching logic for rule application
        // This is a simplified version - full implementation would do
        // proper unification and substitution

        let mut results = vec![];

        // For each potential binding of rule variables to state objects
        // check if all premises are satisfied, then derive conclusion

        // Simplified: just check specific well-known rules
        match rule.name.as_str() {
            "collinear_transitivity" => {
                // Find all pairs of collinear predicates sharing two points
                let collins: Vec[&Collinear] = state.predicates.values()
                    .filter_map(|p| match p {
                        Predicate::Collin(c) if c.status.value => Some(c),
                        _ => None,
                    })
                    .collect();

                for c1 in &collins {
                    for c2 in &collins {
                        // Check if they share exactly two points
                        if c1.p1.id == c2.p1.id && c1.p2.id == c2.p2.id && c1.p3.id != c2.p3.id {
                            let new_coll = Collinear::check(c1.p3.clone(), c1.p2.clone(), c2.p3.clone());
                            if new_coll.status.value {
                                results.push(Predicate::Collin(new_coll));
                            }
                        }
                    }
                }
            },
            "parallel_transitivity" => {
                let paras: Vec[&Parallel] = state.predicates.values()
                    .filter_map(|p| match p {
                        Predicate::Para(par) if par.status.value => Some(par),
                        _ => None,
                    })
                    .collect();

                for p1 in &paras {
                    for p2 in &paras {
                        if p1.l2.id == p2.l1.id {
                            let new_para = Parallel::check(p1.l1.clone(), p2.l2.clone());
                            if new_para.status.value {
                                results.push(Predicate::Para(new_para));
                            }
                        }
                    }
                }
            },
            _ => {
                // Other rules not yet implemented
            }
        }

        results
    }
}

// =============================================================================
// Algebraic Reasoning (AR)
// =============================================================================

/// Algebraic reasoning engine using coordinate computation
struct AlgebraicReasoner {
    /// Tolerance for numerical comparisons
    epsilon: f64,
}

impl AlgebraicReasoner {
    fn new() -> AlgebraicReasoner {
        AlgebraicReasoner { epsilon: 1e-9 }
    }

    /// Verify a predicate algebraically
    fn verify(self, state: &ProofState, pred: &Predicate) -> Knowledge[bool] {
        match pred {
            Predicate::Collin(c) => {
                let result = is_collinear(c.p1.clone(), c.p2.clone(), c.p3.clone());
                let conf = c.status.confidence * Confidence::new(0.99); // AR slightly less certain
                Knowledge::derived(result, conf, Source::Derivation("algebraic_verify"))
            },
            Predicate::Para(p) => {
                let result = is_parallel(p.l1.clone(), p.l2.clone());
                let conf = p.status.confidence * Confidence::new(0.99);
                Knowledge::derived(result, conf, Source::Derivation("algebraic_verify"))
            },
            Predicate::Perp(p) => {
                let result = is_perpendicular(p.l1.clone(), p.l2.clone());
                let conf = p.status.confidence * Confidence::new(0.99);
                Knowledge::derived(result, conf, Source::Derivation("algebraic_verify"))
            },
            Predicate::EqLen(e) => {
                let l1 = e.seg1.length();
                let l2 = e.seg2.length();
                let result = (l1.value.to_meters() - l2.value.to_meters()).abs() < self.epsilon;
                let conf = e.status.confidence * Confidence::new(0.99);
                Knowledge::derived(result, conf, Source::Derivation("algebraic_verify"))
            },
            Predicate::Concyc(c) => {
                let result = is_concyclic(c.p1.clone(), c.p2.clone(), c.p3.clone(), c.p4.clone());
                let conf = c.status.confidence * Confidence::new(0.98);
                Knowledge::derived(result, conf, Source::Derivation("algebraic_verify"))
            },
            _ => {
                // Default: trust the predicate's own check
                Knowledge::derived(true, pred.confidence(), Source::Derivation("algebraic_passthrough"))
            }
        }
    }

    /// Check if goal is reachable algebraically
    fn check_goal(self, state: &ProofState) -> Option[Knowledge[bool]] {
        match &state.goal {
            Some(goal) => Some(self.verify(state, goal)),
            None => None,
        }
    }
}

// =============================================================================
// Combined DD+AR Engine
// =============================================================================

/// Combined deductive + algebraic reasoning
struct DDAREngine {
    dd: DeductionEngine,
    ar: AlgebraicReasoner,
}

impl DDAREngine {
    fn new() -> DDAREngine {
        DDAREngine {
            dd: DeductionEngine::new(),
            ar: AlgebraicReasoner::new(),
        }
    }

    /// Run combined reasoning
    fn reason(self, state: ProofState) -> ProofState {
        // First, run deductive forward chaining
        let state = self.dd.deduce_all(state);

        // Then verify key predicates algebraically
        // (This catches deduction errors and adds confidence)
        for (key, pred) in state.predicates.iter() {
            let verified = self.ar.verify(&state, pred);
            // Could update confidence based on AR verification
        }

        state
    }

    /// Check if stuck (no more deductions possible, goal not reached)
    fn is_stuck(self, state: &ProofState) -> bool {
        if state.goal_satisfied() {
            return false;
        }

        // Check if any rule can make progress
        for rule in &self.dd.rules {
            let new_preds = self.dd.try_apply_rule(state, rule);
            for pred in new_preds {
                let key = pred.key();
                if !state.predicates.contains_key(&key) {
                    return false; // Can still make progress
                }
            }
        }

        true // Stuck
    }
}

// =============================================================================
// Search Handler (Main Loop)
// =============================================================================

/// Handler for geometry proof search
handler geometry_search_handler for search, deduce, construct {
    engine: DDAREngine,
    neural_suggester: Option[fn(ProofState) -> Vec[Construction]],
    max_depth: i32,
    beam_width: i32,
}

impl geometry_search_handler {
    fn new() -> geometry_search_handler {
        geometry_search_handler {
            engine: DDAREngine::new(),
            neural_suggester: None,
            max_depth: 100,
            beam_width: 8,
        }
    }

    fn with_neural(mut self, suggester: fn(ProofState) -> Vec[Construction]) -> geometry_search_handler {
        self.neural_suggester = Some(suggester);
        self
    }

    /// Main search loop
    fn search(self, initial: ProofState) -> SearchResult {
        let mut state = initial;
        let mut depth = 0;

        while depth < self.max_depth {
            // Step 1: Run DD+AR
            state = self.engine.reason(state);

            // Step 2: Check if goal reached
            if state.goal_satisfied() {
                return SearchResult::Proven(state);
            }

            // Step 3: Check if stuck
            if self.engine.is_stuck(&state) {
                // Step 4: Try neural suggestions
                match &self.neural_suggester {
                    Some(suggester) => {
                        let constructions = suggester(state.clone());

                        if constructions.is_empty() {
                            return SearchResult::Stuck(state);
                        }

                        // Apply best construction (by confidence)
                        let best = constructions.iter()
                            .max_by(|a, b| a.confidence.value().partial_cmp(&b.confidence.value()).unwrap())
                            .unwrap();

                        state = self.apply_construction(state, best.clone());
                        state.constructions.push(best.clone());
                    },
                    None => {
                        return SearchResult::Stuck(state);
                    }
                }
            }

            depth += 1;
        }

        SearchResult::Failed("max depth exceeded".to_string())
    }

    /// Apply a construction to the state
    fn apply_construction(self, mut state: ProofState, construction: Construction) -> ProofState {
        match &construction.kind {
            ConstructionType::ConstructMidpoint { p1, p2 } => {
                let pt1 = state.get_point(p1).unwrap();
                let pt2 = state.get_point(p2).unwrap();
                let seg = Segment::new(pt1, pt2);
                let mid = seg.midpoint();
                state = state.add_point(mid.clone());

                // Add midpoint predicate
                let pred = Midpoint::axiom(mid, pt1, pt2);
                state = state.add_predicate(Predicate::Mid(pred));
            },
            ConstructionType::ConstructPerpendicular { point, line_p1, line_p2 } => {
                let p = state.get_point(point).unwrap();
                let lp1 = state.get_point(line_p1).unwrap();
                let lp2 = state.get_point(line_p2).unwrap();
                let line = Line::through(lp1, lp2);
                let perp = line.perpendicular_through(p);
                state = state.add_line(perp.clone());

                // Add perpendicular predicate
                let pred = Perpendicular::check(perp, line);
                state = state.add_predicate(Predicate::Perp(pred));
            },
            ConstructionType::ConstructCircumcircle { p1, p2, p3 } => {
                let pt1 = state.get_point(p1).unwrap();
                let pt2 = state.get_point(p2).unwrap();
                let pt3 = state.get_point(p3).unwrap();

                if let Some(circle) = Circle::circumscribed(pt1.clone(), pt2.clone(), pt3.clone()) {
                    state = state.add_circle(circle.clone());
                    state = state.add_point(circle.center.clone());

                    // Add on_circle predicates
                    state = state.add_predicate(Predicate::OnCir(OnCircle::axiom(pt1, circle.clone())));
                    state = state.add_predicate(Predicate::OnCir(OnCircle::axiom(pt2, circle.clone())));
                    state = state.add_predicate(Predicate::OnCir(OnCircle::axiom(pt3, circle)));
                }
            },
            ConstructionType::ConstructLineIntersection { l1_p1, l1_p2, l2_p1, l2_p2 } => {
                let lp1 = state.get_point(l1_p1).unwrap();
                let lp2 = state.get_point(l1_p2).unwrap();
                let lp3 = state.get_point(l2_p1).unwrap();
                let lp4 = state.get_point(l2_p2).unwrap();

                let line1 = Line::through(lp1, lp2);
                let line2 = Line::through(lp3, lp4);

                if let Some(inter) = Line::intersect(line1.clone(), line2.clone()) {
                    state = state.add_point(inter.clone());
                    state = state.add_predicate(Predicate::OnLn(OnLine::axiom(inter.clone(), line1)));
                    state = state.add_predicate(Predicate::OnLn(OnLine::axiom(inter, line2)));
                }
            },
            ConstructionType::ConstructFoot { point, line_p1, line_p2 } => {
                let p = state.get_point(point).unwrap();
                let lp1 = state.get_point(line_p1).unwrap();
                let lp2 = state.get_point(line_p2).unwrap();
                let line = Line::through(lp1, lp2);
                let perp = line.perpendicular_through(p.clone());

                if let Some(foot) = Line::intersect(line.clone(), perp.clone()) {
                    state = state.add_point(foot.clone());
                    state = state.add_line(perp.clone());
                    state = state.add_predicate(Predicate::OnLn(OnLine::axiom(foot.clone(), line)));
                    state = state.add_predicate(Predicate::Perp(Perpendicular::axiom(perp, line)));
                }
            },
            _ => {
                // Other construction types
            }
        }

        state
    }
}

// =============================================================================
// Proof Trace Generation
// =============================================================================

/// Generate human-readable proof from trace
fn generate_proof_text(state: &ProofState) -> String {
    let mut proof = String::new();
    proof.push_str("=== PROOF ===\n\n");

    // List givens
    proof.push_str("Given:\n");
    for (id, _point) in &state.points {
        if !id.starts_with("inter") && !id.starts_with("mid") {
            proof.push_str(&format!("  Point {}\n", id));
        }
    }
    proof.push_str("\n");

    // List constructions
    if !state.constructions.is_empty() {
        proof.push_str("Constructions:\n");
        for (i, constr) in state.constructions.iter().enumerate() {
            proof.push_str(&format!("  {}. {:?} (confidence: {:.2})\n",
                i + 1,
                constr.kind,
                constr.confidence.value()
            ));
        }
        proof.push_str("\n");
    }

    // List proof steps
    proof.push_str("Proof:\n");
    for (i, step) in state.trace.iter().enumerate() {
        proof.push_str(&format!("  {}. {} [{}] (conf: {:.2})\n",
            i + 1,
            step.predicate.key(),
            step.rule,
            step.confidence.value()
        ));
    }

    // Goal status
    proof.push_str("\n");
    if state.goal_satisfied() {
        proof.push_str("GOAL PROVEN ");
    } else {
        proof.push_str("GOAL NOT PROVEN ");
    }
    proof.push_str(&format!("(overall confidence: {:.2})\n", state.confidence.mean()));

    proof
}

// =============================================================================
// Example Usage
// =============================================================================

/// Example: Prove that the midpoint connector is parallel to the third side
fn example_midpoint_theorem() {
    // Setup: Triangle ABC with midpoints M of AB and N of AC
    let a = Point::given("A", 0.0, 0.0);
    let b = Point::given("B", 4.0, 0.0);
    let c = Point::given("C", 2.0, 3.0);

    let m = Segment::new(a.clone(), b.clone()).midpoint();  // Midpoint of AB
    let n = Segment::new(a.clone(), c.clone()).midpoint();  // Midpoint of AC

    // Initial state
    let state = ProofState::new()
        .add_point(a.clone())
        .add_point(b.clone())
        .add_point(c.clone())
        .add_point(m.clone())
        .add_point(n.clone());

    // Add midpoint predicates as axioms
    let state = state
        .add_predicate(Predicate::Mid(Midpoint::axiom(m.clone(), a.clone(), b.clone())))
        .add_predicate(Predicate::Mid(Midpoint::axiom(n.clone(), a.clone(), c.clone())));

    // Goal: line(M,N) || line(B,C)
    let line_mn = Line::through(m, n);
    let line_bc = Line::through(b, c);
    let goal = Predicate::Para(Parallel::check(line_mn, line_bc));
    let state = state.set_goal(goal);

    // Run search
    let handler = geometry_search_handler::new();
    let result = handler.search(state);

    match result {
        SearchResult::Proven(final_state) => {
            println!("{}", generate_proof_text(&final_state));
        },
        SearchResult::Stuck(state) => {
            println!("Stuck! Need auxiliary construction.");
            println!("{}", generate_proof_text(&state));
        },
        SearchResult::Failed(msg) => {
            println!("Failed: {}", msg);
        },
        _ => {}
    }
}
