//! JSON Module for Sounio
//!
//! Provides JSON parsing, serialization, and manipulation.
//! Follows RFC 7159 (The JavaScript Object Notation Data Interchange Format).

// =============================================================================
// Error Types
// =============================================================================

/// Error type for JSON parsing
pub enum ParseError {
    /// Unexpected character at position
    UnexpectedChar { position: i64, char: char, expected: String },
    /// Unexpected end of input
    UnexpectedEof { expected: String },
    /// Invalid escape sequence
    InvalidEscape { position: i64, sequence: String },
    /// Invalid number format
    InvalidNumber { position: i64, value: String },
    /// Invalid unicode escape
    InvalidUnicode { position: i64, sequence: String },
    /// Trailing data after valid JSON
    TrailingData { position: i64 },
    /// Nesting too deep
    NestingTooDeep { depth: i64, max_depth: i64 },
    /// Other parse error
    Other { message: String },
}

impl ParseError {
    /// Get error message
    pub fn message(self) -> String {
        match self {
            ParseError::UnexpectedChar { position, char, expected } =>
                "Unexpected '" ++ char.to_string() ++ "' at position " ++ position.to_string() ++ ", expected " ++ expected,
            ParseError::UnexpectedEof { expected } =>
                "Unexpected end of input, expected " ++ expected,
            ParseError::InvalidEscape { position, sequence } =>
                "Invalid escape sequence '" ++ sequence ++ "' at position " ++ position.to_string(),
            ParseError::InvalidNumber { position, value } =>
                "Invalid number '" ++ value ++ "' at position " ++ position.to_string(),
            ParseError::InvalidUnicode { position, sequence } =>
                "Invalid unicode escape '" ++ sequence ++ "' at position " ++ position.to_string(),
            ParseError::TrailingData { position } =>
                "Trailing data after valid JSON at position " ++ position.to_string(),
            ParseError::NestingTooDeep { depth, max_depth } =>
                "Nesting too deep: " ++ depth.to_string() ++ " (max " ++ max_depth.to_string() ++ ")",
            ParseError::Other { message } => message,
        }
    }
}

impl ToString for ParseError {
    fn to_string(self) -> String {
        self.message()
    }
}

impl Debug for ParseError {
    fn fmt(self, f: &mut Formatter) -> Result<(), FmtError> {
        f.write_str(self.message())
    }
}

// =============================================================================
// JSON Value Type
// =============================================================================

/// Represents any JSON value
pub enum JsonValue {
    /// Null value
    Null,
    /// Boolean value
    Bool(bool),
    /// Number value (stored as f64)
    Number(f64),
    /// String value
    String(String),
    /// Array of JSON values
    Array(Vec<JsonValue>),
    /// Object (map of string keys to JSON values)
    Object(Map<String, JsonValue>),
}

impl JsonValue {
    // =========================================================================
    // Constructors
    // =========================================================================

    /// Create a null value
    pub fn null() -> JsonValue {
        JsonValue::Null
    }

    /// Create a boolean value
    pub fn bool(b: bool) -> JsonValue {
        JsonValue::Bool(b)
    }

    /// Create a number value
    pub fn number(n: f64) -> JsonValue {
        JsonValue::Number(n)
    }

    /// Create a string value
    pub fn string(s: String) -> JsonValue {
        JsonValue::String(s)
    }

    /// Create an empty array
    pub fn array() -> JsonValue {
        JsonValue::Array(Vec::new())
    }

    /// Create an array from a vector
    pub fn array_from(items: Vec<JsonValue>) -> JsonValue {
        JsonValue::Array(items)
    }

    /// Create an empty object
    pub fn object() -> JsonValue {
        JsonValue::Object(Map::new())
    }

    /// Create an object from a map
    pub fn object_from(items: Map<String, JsonValue>) -> JsonValue {
        JsonValue::Object(items)
    }

    // =========================================================================
    // Type Checking
    // =========================================================================

    /// Check if value is null
    pub fn is_null(self: &JsonValue) -> bool {
        match self {
            JsonValue::Null => true,
            _ => false,
        }
    }

    /// Check if value is a boolean
    pub fn is_bool(self: &JsonValue) -> bool {
        match self {
            JsonValue::Bool(_) => true,
            _ => false,
        }
    }

    /// Check if value is a number
    pub fn is_number(self: &JsonValue) -> bool {
        match self {
            JsonValue::Number(_) => true,
            _ => false,
        }
    }

    /// Check if value is a string
    pub fn is_string(self: &JsonValue) -> bool {
        match self {
            JsonValue::String(_) => true,
            _ => false,
        }
    }

    /// Check if value is an array
    pub fn is_array(self: &JsonValue) -> bool {
        match self {
            JsonValue::Array(_) => true,
            _ => false,
        }
    }

    /// Check if value is an object
    pub fn is_object(self: &JsonValue) -> bool {
        match self {
            JsonValue::Object(_) => true,
            _ => false,
        }
    }

    // =========================================================================
    // Value Extraction
    // =========================================================================

    /// Get as boolean, returns None if not a boolean
    pub fn as_bool(self: &JsonValue) -> Option<bool> {
        match self {
            JsonValue::Bool(b) => Some(*b),
            _ => None,
        }
    }

    /// Get as f64, returns None if not a number
    pub fn as_f64(self: &JsonValue) -> Option<f64> {
        match self {
            JsonValue::Number(n) => Some(*n),
            _ => None,
        }
    }

    /// Get as i64 (truncates decimals), returns None if not a number
    pub fn as_i64(self: &JsonValue) -> Option<i64> {
        match self {
            JsonValue::Number(n) => Some(*n as i64),
            _ => None,
        }
    }

    /// Get as u64 (truncates decimals), returns None if not a number or negative
    pub fn as_u64(self: &JsonValue) -> Option<u64> {
        match self {
            JsonValue::Number(n) => {
                if *n >= 0.0 {
                    Some(*n as u64)
                } else {
                    None
                }
            },
            _ => None,
        }
    }

    /// Get as string reference, returns None if not a string
    pub fn as_str(self: &JsonValue) -> Option<&str> {
        match self {
            JsonValue::String(s) => Some(s.as_str()),
            _ => None,
        }
    }

    /// Get as array reference, returns None if not an array
    pub fn as_array(self: &JsonValue) -> Option<&Vec<JsonValue>> {
        match self {
            JsonValue::Array(arr) => Some(arr),
            _ => None,
        }
    }

    /// Get as mutable array reference, returns None if not an array
    pub fn as_array_mut(self: &mut JsonValue) -> Option<&mut Vec<JsonValue>> {
        match self {
            JsonValue::Array(arr) => Some(arr),
            _ => None,
        }
    }

    /// Get as object reference, returns None if not an object
    pub fn as_object(self: &JsonValue) -> Option<&Map<String, JsonValue>> {
        match self {
            JsonValue::Object(obj) => Some(obj),
            _ => None,
        }
    }

    /// Get as mutable object reference, returns None if not an object
    pub fn as_object_mut(self: &mut JsonValue) -> Option<&mut Map<String, JsonValue>> {
        match self {
            JsonValue::Object(obj) => Some(obj),
            _ => None,
        }
    }

    // =========================================================================
    // Object Access
    // =========================================================================

    /// Check if object has a key
    ///
    /// Returns false if not an object or key doesn't exist.
    ///
    /// # Example
    /// ```d
    /// let json = parse_json(r#"{"name": "test"}"#)?;
    /// if json.has("name") {
    ///     println("Has name field");
    /// }
    /// ```
    pub fn has(self: &JsonValue, key: &str) -> bool {
        match self {
            JsonValue::Object(obj) => obj.contains_key(key),
            _ => false,
        }
    }

    /// Get a value from an object by key
    ///
    /// Returns Null if not an object or key doesn't exist.
    ///
    /// # Example
    /// ```d
    /// let json = parse_json(r#"{"name": "test"}"#)?;
    /// let name = json.get("name");
    /// ```
    pub fn get(self: &JsonValue, key: &str) -> &JsonValue {
        match self {
            JsonValue::Object(obj) => {
                match obj.get(key) {
                    Some(v) => v,
                    None => &JsonValue::Null,
                }
            },
            _ => &JsonValue::Null,
        }
    }

    /// Get a mutable value from an object by key
    pub fn get_mut(self: &mut JsonValue, key: &str) -> Option<&mut JsonValue> {
        match self {
            JsonValue::Object(obj) => obj.get_mut(key),
            _ => None,
        }
    }

    /// Set a value in an object
    ///
    /// # Returns
    /// * `true` if this is an object and value was set
    /// * `false` if this is not an object
    pub fn set(self: &mut JsonValue, key: String, value: JsonValue) -> bool {
        match self {
            JsonValue::Object(obj) => {
                obj.insert(key, value);
                true
            },
            _ => false,
        }
    }

    /// Remove a key from an object
    ///
    /// # Returns
    /// * `Some(value)` if key existed
    /// * `None` if not an object or key didn't exist
    pub fn remove(self: &mut JsonValue, key: &str) -> Option<JsonValue> {
        match self {
            JsonValue::Object(obj) => obj.remove(key),
            _ => None,
        }
    }

    /// Get object keys as iterator
    pub fn keys(self: &JsonValue) -> impl Iterator<Item = &String> {
        match self {
            JsonValue::Object(obj) => obj.keys(),
            _ => [].iter(),  // Empty iterator
        }
    }

    // =========================================================================
    // Array Access
    // =========================================================================

    /// Get array length, returns 0 if not an array
    pub fn len(self: &JsonValue) -> usize {
        match self {
            JsonValue::Array(arr) => arr.len(),
            JsonValue::Object(obj) => obj.len(),
            JsonValue::String(s) => s.len(),
            _ => 0,
        }
    }

    /// Check if empty (array, object, or string)
    pub fn is_empty(self: &JsonValue) -> bool {
        self.len() == 0
    }

    /// Get element at index (for arrays)
    ///
    /// Returns Null if not an array or index out of bounds.
    pub fn at(self: &JsonValue, index: usize) -> &JsonValue {
        match self {
            JsonValue::Array(arr) => {
                if index < arr.len() {
                    &arr[index]
                } else {
                    &JsonValue::Null
                }
            },
            _ => &JsonValue::Null,
        }
    }

    /// Push value to array
    ///
    /// # Returns
    /// * `true` if this is an array and value was pushed
    /// * `false` if this is not an array
    pub fn push(self: &mut JsonValue, value: JsonValue) -> bool {
        match self {
            JsonValue::Array(arr) => {
                arr.push(value);
                true
            },
            _ => false,
        }
    }

    /// Pop value from array
    pub fn pop(self: &mut JsonValue) -> Option<JsonValue> {
        match self {
            JsonValue::Array(arr) => arr.pop(),
            _ => None,
        }
    }

    // =========================================================================
    // Traversal
    // =========================================================================

    /// Get nested value by path
    ///
    /// Path is a dot-separated string, with array indices in brackets.
    ///
    /// # Example
    /// ```d
    /// let json = parse_json(r#"{"users": [{"name": "Alice"}]}"#)?;
    /// let name = json.path("users[0].name");
    /// ```
    pub fn path(self: &JsonValue, p: &str) -> &JsonValue {
        var current = self;
        var path_str = p;

        while !path_str.is_empty() {
            // Handle array index
            if path_str.starts_with("[") {
                let end = path_str.find(']').unwrap_or(path_str.len());
                let index_str = &path_str[1..end];
                match index_str.parse::<usize>() {
                    Ok(idx) => {
                        current = current.at(idx);
                        path_str = if end + 1 < path_str.len() {
                            &path_str[(end + 1)..]
                        } else {
                            ""
                        };
                        // Skip dot after ]
                        if path_str.starts_with(".") {
                            path_str = &path_str[1..];
                        }
                    },
                    Err(_) => return &JsonValue::Null,
                }
            } else {
                // Handle object key
                let dot_pos = path_str.find('.').unwrap_or(path_str.len());
                let bracket_pos = path_str.find('[').unwrap_or(path_str.len());
                let end = min(dot_pos, bracket_pos);

                let key = &path_str[..end];
                current = current.get(key);

                if end < path_str.len() && path_str.chars().nth(end) == Some('.') {
                    path_str = &path_str[(end + 1)..];
                } else {
                    path_str = &path_str[end..];
                }
            }

            if current.is_null() {
                return &JsonValue::Null;
            }
        }

        current
    }
}

// =============================================================================
// Indexing
// =============================================================================

impl Index<&str> for JsonValue {
    type Output = JsonValue;

    /// Index into object by key
    ///
    /// Returns Null for missing keys or non-objects.
    fn index(self: &JsonValue, key: &str) -> &JsonValue {
        self.get(key)
    }
}

impl Index<usize> for JsonValue {
    type Output = JsonValue;

    /// Index into array by position
    ///
    /// Returns Null for out of bounds or non-arrays.
    fn index(self: &JsonValue, index: usize) -> &JsonValue {
        self.at(index)
    }
}

// =============================================================================
// Parser
// =============================================================================

/// Parse a JSON string into a JsonValue
///
/// # Arguments
/// * `input` - JSON string to parse
///
/// # Returns
/// * `Ok(JsonValue)` - Parsed JSON value
/// * `Err(ParseError)` - Parse error with position information
///
/// # Example
/// ```d
/// match parse_json(r#"{"name": "test", "value": 42}"#) {
///     Ok(json) => {
///         let name = json["name"].as_str().unwrap_or("default");
///         let value = json["value"].as_i64().unwrap_or(0);
///     },
///     Err(e) => {
///         println("Parse error: {}", e);
///     },
/// }
/// ```
pub fn parse_json(input: &str) -> Result<JsonValue, ParseError> {
    var parser = JsonParser::new(input);
    let value = parser.parse_value()?;

    // Check for trailing data
    parser.skip_whitespace();
    if parser.pos < parser.input.len() {
        return Err(ParseError::TrailingData { position: parser.pos as i64 });
    }

    Ok(value)
}

/// Internal JSON parser state
struct JsonParser {
    input: &str,
    pos: usize,
    depth: i32,
    max_depth: i32,
}

impl JsonParser {
    fn new(input: &str) -> JsonParser {
        JsonParser {
            input: input,
            pos: 0,
            depth: 0,
            max_depth: 128,
        }
    }

    fn peek(self: &JsonParser) -> Option<char> {
        self.input.chars().nth(self.pos)
    }

    fn advance(self: &mut JsonParser) -> Option<char> {
        let c = self.peek();
        if c.is_some() {
            self.pos = self.pos + 1;
        }
        c
    }

    fn skip_whitespace(self: &mut JsonParser) {
        while let Some(c) = self.peek() {
            match c {
                ' ' | '\t' | '\n' | '\r' => {
                    self.advance();
                },
                _ => break,
            }
        }
    }

    fn expect(self: &mut JsonParser, expected: char) -> Result<(), ParseError> {
        match self.advance() {
            Some(c) if c == expected => Ok(()),
            Some(c) => Err(ParseError::UnexpectedChar {
                position: self.pos as i64 - 1,
                char: c,
                expected: expected.to_string(),
            }),
            None => Err(ParseError::UnexpectedEof {
                expected: expected.to_string(),
            }),
        }
    }

    fn parse_value(self: &mut JsonParser) -> Result<JsonValue, ParseError> {
        self.skip_whitespace();

        match self.peek() {
            Some('n') => self.parse_null(),
            Some('t') | Some('f') => self.parse_bool(),
            Some('"') => self.parse_string(),
            Some('[') => self.parse_array(),
            Some('{') => self.parse_object(),
            Some(c) if c == '-' || c.is_ascii_digit() => self.parse_number(),
            Some(c) => Err(ParseError::UnexpectedChar {
                position: self.pos as i64,
                char: c,
                expected: "value".to_string(),
            }),
            None => Err(ParseError::UnexpectedEof {
                expected: "value".to_string(),
            }),
        }
    }

    fn parse_null(self: &mut JsonParser) -> Result<JsonValue, ParseError> {
        self.expect('n')?;
        self.expect('u')?;
        self.expect('l')?;
        self.expect('l')?;
        Ok(JsonValue::Null)
    }

    fn parse_bool(self: &mut JsonParser) -> Result<JsonValue, ParseError> {
        match self.peek() {
            Some('t') => {
                self.expect('t')?;
                self.expect('r')?;
                self.expect('u')?;
                self.expect('e')?;
                Ok(JsonValue::Bool(true))
            },
            Some('f') => {
                self.expect('f')?;
                self.expect('a')?;
                self.expect('l')?;
                self.expect('s')?;
                self.expect('e')?;
                Ok(JsonValue::Bool(false))
            },
            _ => Err(ParseError::UnexpectedEof {
                expected: "boolean".to_string(),
            }),
        }
    }

    fn parse_string(self: &mut JsonParser) -> Result<JsonValue, ParseError> {
        self.expect('"')?;
        var result = String::new();

        loop {
            match self.advance() {
                Some('"') => break,
                Some('\\') => {
                    // Handle escape sequences
                    match self.advance() {
                        Some('"') => result.push('"'),
                        Some('\\') => result.push('\\'),
                        Some('/') => result.push('/'),
                        Some('b') => result.push('\x08'),
                        Some('f') => result.push('\x0C'),
                        Some('n') => result.push('\n'),
                        Some('r') => result.push('\r'),
                        Some('t') => result.push('\t'),
                        Some('u') => {
                            // Parse 4 hex digits
                            var hex = String::new();
                            for _ in 0..4 {
                                match self.advance() {
                                    Some(c) if c.is_ascii_hexdigit() => hex.push(c),
                                    Some(c) => return Err(ParseError::InvalidUnicode {
                                        position: self.pos as i64,
                                        sequence: hex,
                                    }),
                                    None => return Err(ParseError::UnexpectedEof {
                                        expected: "hex digit".to_string(),
                                    }),
                                }
                            }
                            match u32::from_str_radix(&hex, 16) {
                                Ok(code) => {
                                    match char::from_u32(code) {
                                        Some(c) => result.push(c),
                                        None => return Err(ParseError::InvalidUnicode {
                                            position: self.pos as i64,
                                            sequence: hex,
                                        }),
                                    }
                                },
                                Err(_) => return Err(ParseError::InvalidUnicode {
                                    position: self.pos as i64,
                                    sequence: hex,
                                }),
                            }
                        },
                        Some(c) => return Err(ParseError::InvalidEscape {
                            position: self.pos as i64,
                            sequence: "\\" ++ c.to_string(),
                        }),
                        None => return Err(ParseError::UnexpectedEof {
                            expected: "escape character".to_string(),
                        }),
                    }
                },
                Some(c) => result.push(c),
                None => return Err(ParseError::UnexpectedEof {
                    expected: "\"".to_string(),
                }),
            }
        }

        Ok(JsonValue::String(result))
    }

    fn parse_number(self: &mut JsonParser) -> Result<JsonValue, ParseError> {
        let start = self.pos;
        var num_str = String::new();

        // Optional minus
        if self.peek() == Some('-') {
            num_str.push(self.advance().unwrap());
        }

        // Integer part
        match self.peek() {
            Some('0') => {
                num_str.push(self.advance().unwrap());
            },
            Some(c) if c >= '1' && c <= '9' => {
                num_str.push(self.advance().unwrap());
                while let Some(c) = self.peek() {
                    if c.is_ascii_digit() {
                        num_str.push(self.advance().unwrap());
                    } else {
                        break;
                    }
                }
            },
            _ => return Err(ParseError::InvalidNumber {
                position: start as i64,
                value: num_str,
            }),
        }

        // Fractional part
        if self.peek() == Some('.') {
            num_str.push(self.advance().unwrap());
            var has_digit = false;
            while let Some(c) = self.peek() {
                if c.is_ascii_digit() {
                    num_str.push(self.advance().unwrap());
                    has_digit = true;
                } else {
                    break;
                }
            }
            if !has_digit {
                return Err(ParseError::InvalidNumber {
                    position: start as i64,
                    value: num_str,
                });
            }
        }

        // Exponent part
        if let Some(c) = self.peek() {
            if c == 'e' || c == 'E' {
                num_str.push(self.advance().unwrap());
                if let Some(c) = self.peek() {
                    if c == '+' || c == '-' {
                        num_str.push(self.advance().unwrap());
                    }
                }
                var has_digit = false;
                while let Some(c) = self.peek() {
                    if c.is_ascii_digit() {
                        num_str.push(self.advance().unwrap());
                        has_digit = true;
                    } else {
                        break;
                    }
                }
                if !has_digit {
                    return Err(ParseError::InvalidNumber {
                        position: start as i64,
                        value: num_str,
                    });
                }
            }
        }

        match num_str.parse::<f64>() {
            Ok(n) => Ok(JsonValue::Number(n)),
            Err(_) => Err(ParseError::InvalidNumber {
                position: start as i64,
                value: num_str,
            }),
        }
    }

    fn parse_array(self: &mut JsonParser) -> Result<JsonValue, ParseError> {
        self.depth = self.depth + 1;
        if self.depth > self.max_depth {
            return Err(ParseError::NestingTooDeep {
                depth: self.depth as i64,
                max_depth: self.max_depth as i64,
            });
        }

        self.expect('[')?;
        self.skip_whitespace();

        var items: Vec<JsonValue> = Vec::new();

        if self.peek() == Some(']') {
            self.advance();
            self.depth = self.depth - 1;
            return Ok(JsonValue::Array(items));
        }

        loop {
            let value = self.parse_value()?;
            items.push(value);

            self.skip_whitespace();
            match self.peek() {
                Some(',') => {
                    self.advance();
                    self.skip_whitespace();
                },
                Some(']') => {
                    self.advance();
                    break;
                },
                Some(c) => return Err(ParseError::UnexpectedChar {
                    position: self.pos as i64,
                    char: c,
                    expected: ", or ]".to_string(),
                }),
                None => return Err(ParseError::UnexpectedEof {
                    expected: "]".to_string(),
                }),
            }
        }

        self.depth = self.depth - 1;
        Ok(JsonValue::Array(items))
    }

    fn parse_object(self: &mut JsonParser) -> Result<JsonValue, ParseError> {
        self.depth = self.depth + 1;
        if self.depth > self.max_depth {
            return Err(ParseError::NestingTooDeep {
                depth: self.depth as i64,
                max_depth: self.max_depth as i64,
            });
        }

        self.expect('{')?;
        self.skip_whitespace();

        var items: Map<String, JsonValue> = Map::new();

        if self.peek() == Some('}') {
            self.advance();
            self.depth = self.depth - 1;
            return Ok(JsonValue::Object(items));
        }

        loop {
            self.skip_whitespace();

            // Parse key
            if self.peek() != Some('"') {
                return Err(ParseError::UnexpectedChar {
                    position: self.pos as i64,
                    char: self.peek().unwrap_or('\0'),
                    expected: "\"".to_string(),
                });
            }
            let key_value = self.parse_string()?;
            let key = match key_value {
                JsonValue::String(s) => s,
                _ => return Err(ParseError::Other {
                    message: "Internal error: expected string".to_string(),
                }),
            };

            self.skip_whitespace();
            self.expect(':')?;
            self.skip_whitespace();

            // Parse value
            let value = self.parse_value()?;
            items.insert(key, value);

            self.skip_whitespace();
            match self.peek() {
                Some(',') => {
                    self.advance();
                },
                Some('}') => {
                    self.advance();
                    break;
                },
                Some(c) => return Err(ParseError::UnexpectedChar {
                    position: self.pos as i64,
                    char: c,
                    expected: ", or }".to_string(),
                }),
                None => return Err(ParseError::UnexpectedEof {
                    expected: "}".to_string(),
                }),
            }
        }

        self.depth = self.depth - 1;
        Ok(JsonValue::Object(items))
    }
}

// =============================================================================
// Serialization
// =============================================================================

impl JsonValue {
    /// Serialize to JSON string
    ///
    /// # Example
    /// ```d
    /// let json = JsonValue::object();
    /// json.set("name", JsonValue::string("test"));
    /// let s = json.to_json_string();
    /// // s = r#"{"name":"test"}"#
    /// ```
    pub fn to_json_string(self: &JsonValue) -> String {
        var result = String::new();
        self.write_json(&mut result);
        result
    }

    /// Serialize to JSON string with indentation
    pub fn to_json_string_pretty(self: &JsonValue) -> String {
        var result = String::new();
        self.write_json_pretty(&mut result, 0);
        result
    }

    fn write_json(self: &JsonValue, out: &mut String) {
        match self {
            JsonValue::Null => out.push_str("null"),
            JsonValue::Bool(true) => out.push_str("true"),
            JsonValue::Bool(false) => out.push_str("false"),
            JsonValue::Number(n) => out.push_str(&n.to_string()),
            JsonValue::String(s) => {
                out.push('"');
                for c in s.chars() {
                    match c {
                        '"' => out.push_str("\\\""),
                        '\\' => out.push_str("\\\\"),
                        '\n' => out.push_str("\\n"),
                        '\r' => out.push_str("\\r"),
                        '\t' => out.push_str("\\t"),
                        c if c < ' ' => {
                            out.push_str("\\u");
                            out.push_str(&format!("{:04x}", c as u32));
                        },
                        _ => out.push(c),
                    }
                }
                out.push('"');
            },
            JsonValue::Array(arr) => {
                out.push('[');
                for (i, item) in arr.iter().enumerate() {
                    if i > 0 {
                        out.push(',');
                    }
                    item.write_json(out);
                }
                out.push(']');
            },
            JsonValue::Object(obj) => {
                out.push('{');
                var first = true;
                for (key, value) in obj.iter() {
                    if !first {
                        out.push(',');
                    }
                    first = false;
                    out.push('"');
                    out.push_str(key);
                    out.push_str("\":");
                    value.write_json(out);
                }
                out.push('}');
            },
        }
    }

    fn write_json_pretty(self: &JsonValue, out: &mut String, indent: i32) {
        let indent_str = "  ".repeat(indent as usize);
        let next_indent = "  ".repeat((indent + 1) as usize);

        match self {
            JsonValue::Null => out.push_str("null"),
            JsonValue::Bool(true) => out.push_str("true"),
            JsonValue::Bool(false) => out.push_str("false"),
            JsonValue::Number(n) => out.push_str(&n.to_string()),
            JsonValue::String(s) => {
                out.push('"');
                for c in s.chars() {
                    match c {
                        '"' => out.push_str("\\\""),
                        '\\' => out.push_str("\\\\"),
                        '\n' => out.push_str("\\n"),
                        '\r' => out.push_str("\\r"),
                        '\t' => out.push_str("\\t"),
                        c if c < ' ' => {
                            out.push_str("\\u");
                            out.push_str(&format!("{:04x}", c as u32));
                        },
                        _ => out.push(c),
                    }
                }
                out.push('"');
            },
            JsonValue::Array(arr) => {
                if arr.is_empty() {
                    out.push_str("[]");
                } else {
                    out.push_str("[\n");
                    for (i, item) in arr.iter().enumerate() {
                        out.push_str(&next_indent);
                        item.write_json_pretty(out, indent + 1);
                        if i < arr.len() - 1 {
                            out.push(',');
                        }
                        out.push('\n');
                    }
                    out.push_str(&indent_str);
                    out.push(']');
                }
            },
            JsonValue::Object(obj) => {
                if obj.is_empty() {
                    out.push_str("{}");
                } else {
                    out.push_str("{\n");
                    let keys: Vec<&String> = obj.keys().collect();
                    for (i, key) in keys.iter().enumerate() {
                        out.push_str(&next_indent);
                        out.push('"');
                        out.push_str(key);
                        out.push_str("\": ");
                        obj.get(*key).unwrap().write_json_pretty(out, indent + 1);
                        if i < keys.len() - 1 {
                            out.push(',');
                        }
                        out.push('\n');
                    }
                    out.push_str(&indent_str);
                    out.push('}');
                }
            },
        }
    }
}

// =============================================================================
// Utility Functions
// =============================================================================

/// Parse JSON Lines format (one JSON object per line)
///
/// # Arguments
/// * `input` - String containing JSON Lines data
///
/// # Returns
/// * Vector of parsed JSON values (skipping blank lines)
pub fn parse_jsonl(input: &str) -> Result<Vec<JsonValue>, ParseError> {
    var results: Vec<JsonValue> = Vec::new();

    for line in input.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }
        let value = parse_json(trimmed)?;
        results.push(value);
    }

    Ok(results)
}

// =============================================================================
// Tests
// =============================================================================

fn test_parse_null() {
    let result = parse_json("null");
    assert(result.is_ok());
    assert(result.unwrap().is_null());
}

fn test_parse_bool() {
    let true_result = parse_json("true");
    assert(true_result.is_ok());
    assert(true_result.unwrap().as_bool() == Some(true));

    let false_result = parse_json("false");
    assert(false_result.is_ok());
    assert(false_result.unwrap().as_bool() == Some(false));
}

fn test_parse_number() {
    let int_result = parse_json("42");
    assert(int_result.is_ok());
    assert(int_result.unwrap().as_i64() == Some(42));

    let float_result = parse_json("3.14");
    assert(float_result.is_ok());
    let val = float_result.unwrap().as_f64().unwrap();
    assert(val > 3.13 && val < 3.15);

    let neg_result = parse_json("-100");
    assert(neg_result.is_ok());
    assert(neg_result.unwrap().as_i64() == Some(-100));
}

fn test_parse_string() {
    let simple = parse_json(r#""hello""#);
    assert(simple.is_ok());
    assert(simple.unwrap().as_str() == Some("hello"));

    let escaped = parse_json(r#""hello\nworld""#);
    assert(escaped.is_ok());
    assert(escaped.unwrap().as_str() == Some("hello\nworld"));
}

fn test_parse_array() {
    let arr = parse_json("[1, 2, 3]");
    assert(arr.is_ok());
    let val = arr.unwrap();
    assert(val.is_array());
    assert(val.len() == 3);
    assert(val[0].as_i64() == Some(1));
    assert(val[1].as_i64() == Some(2));
    assert(val[2].as_i64() == Some(3));
}

fn test_parse_object() {
    let obj = parse_json(r#"{"name": "test", "value": 42}"#);
    assert(obj.is_ok());
    let val = obj.unwrap();
    assert(val.is_object());
    assert(val.has("name"));
    assert(val.has("value"));
    assert(val["name"].as_str() == Some("test"));
    assert(val["value"].as_i64() == Some(42));
}

fn test_nested() {
    let nested = parse_json(r#"{"users": [{"name": "Alice"}, {"name": "Bob"}]}"#);
    assert(nested.is_ok());
    let val = nested.unwrap();
    assert(val["users"].is_array());
    assert(val["users"].len() == 2);
    assert(val["users"][0]["name"].as_str() == Some("Alice"));
    assert(val["users"][1]["name"].as_str() == Some("Bob"));
}
