//@ run-pass
// test_scientific_computing.sio - Integration tests for scientific computing features
//
// Tests:
// 1. ODE solvers (RK4, RK45)
// 2. Automatic differentiation (gradients, Jacobians)
// 3. Probabilistic programming (sampling, inference)

// ============================================================================
// MATH HELPERS
// ============================================================================

fn abs_f64(x: f64) -> f64 {
    if x < 0.0 { return 0.0 - x }
    return x
}

fn sqrt_f64(x: f64) -> f64 {
    if x <= 0.0 { return 0.0 }
    let mut y = x
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    y = 0.5 * (y + x / y)
    return y
}

fn exp_f64(x: f64) -> f64 {
    if x > 20.0 { return exp_f64(x / 2.0) * exp_f64(x / 2.0) }
    if x < 0.0 - 20.0 { return 1.0 / exp_f64(0.0 - x) }

    let mut sum = 1.0
    let mut term = 1.0
    term = term * x / 1.0; sum = sum + term
    term = term * x / 2.0; sum = sum + term
    term = term * x / 3.0; sum = sum + term
    term = term * x / 4.0; sum = sum + term
    term = term * x / 5.0; sum = sum + term
    term = term * x / 6.0; sum = sum + term
    term = term * x / 7.0; sum = sum + term
    term = term * x / 8.0; sum = sum + term
    term = term * x / 9.0; sum = sum + term
    term = term * x / 10.0; sum = sum + term
    return sum
}

fn cos_f64(x: f64) -> f64 {
    let pi = 3.141592653589793
    let mut y = x
    while y > pi { y = y - 2.0 * pi }
    while y < 0.0 - pi { y = y + 2.0 * pi }
    let x2 = y * y
    let mut sum = 1.0
    let mut term = 1.0
    term = term * (0.0 - x2) / (1.0 * 2.0); sum = sum + term
    term = term * (0.0 - x2) / (3.0 * 4.0); sum = sum + term
    term = term * (0.0 - x2) / (5.0 * 6.0); sum = sum + term
    term = term * (0.0 - x2) / (7.0 * 8.0); sum = sum + term
    return sum
}

// ============================================================================
// TEST 1: ODE SOLVER (RK4)
// ============================================================================

fn ode_exp_decay(u: f64, t: f64) -> f64 {
    let k = 0.1
    return 0.0 - k * u
}

fn rk4_step(u: f64, t: f64, dt: f64) -> f64 {
    let k1 = ode_exp_decay(u, t)
    let k2 = ode_exp_decay(u + 0.5 * dt * k1, t + 0.5 * dt)
    let k3 = ode_exp_decay(u + 0.5 * dt * k2, t + 0.5 * dt)
    let k4 = ode_exp_decay(u + dt * k3, t + dt)
    return u + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)
}

fn test_rk4_solver() -> bool {
    let u0 = 100.0
    let t_end = 10.0
    let n_steps: i64 = 100
    let dt = t_end / (n_steps as f64)

    let mut u = u0
    let mut t = 0.0
    let mut i: i64 = 0

    while i < n_steps {
        u = rk4_step(u, t, dt)
        t = t + dt
        i = i + 1
    }

    // Analytical solution: u(t) = u0 * exp(-k*t) = 100 * exp(-1) ~ 36.79
    let analytical = u0 * exp_f64(0.0 - 0.1 * t_end)
    let rel_err = abs_f64(u - analytical) / analytical

    return rel_err < 0.0001
}

// ============================================================================
// TEST 2: DUAL NUMBERS (Forward-mode AD)
// ============================================================================

struct Dual {
    val: f64,
    dot: f64
}

fn dual_var(val: f64) -> Dual {
    return Dual { val: val, dot: 1.0 }
}

fn dual_const(val: f64) -> Dual {
    return Dual { val: val, dot: 0.0 }
}

fn dual_mul(a: Dual, b: Dual) -> Dual {
    return Dual {
        val: a.val * b.val,
        dot: a.dot * b.val + a.val * b.dot
    }
}

fn dual_add(a: Dual, b: Dual) -> Dual {
    return Dual { val: a.val + b.val, dot: a.dot + b.dot }
}

fn dual_sub(a: Dual, b: Dual) -> Dual {
    return Dual { val: a.val - b.val, dot: a.dot - b.dot }
}

fn test_autodiff_simple() -> bool {
    // Test d/dx(x^2) at x=3
    let x = dual_var(3.0)
    let y = dual_mul(x, x)

    // f(3) = 9, f'(3) = 6
    let val_err = abs_f64(y.val - 9.0)
    let dot_err = abs_f64(y.dot - 6.0)

    return val_err < 0.0001 && dot_err < 0.0001
}

fn test_autodiff_chain() -> bool {
    // Test d/dx((x-1)^2) at x=3
    // f(x) = (x-1)^2, f'(x) = 2*(x-1)
    // f(3) = 4, f'(3) = 4
    let x = dual_var(3.0)
    let one = dual_const(1.0)
    let diff = dual_sub(x, one)
    let y = dual_mul(diff, diff)

    let val_err = abs_f64(y.val - 4.0)
    let dot_err = abs_f64(y.dot - 4.0)

    return val_err < 0.0001 && dot_err < 0.0001
}

// ============================================================================
// TEST 3: RANDOM NUMBER GENERATION
// ============================================================================

struct RNG {
    seed: i64
}

struct RNGResult {
    rng: RNG,
    value: f64
}

fn rng_uniform(rng: RNG) -> RNGResult {
    let a: i64 = 1103515245
    let c: i64 = 12345
    let m: i64 = 2147483648
    let new_seed = (a * rng.seed + c) % m
    let u = (new_seed as f64) / (m as f64)
    return RNGResult { rng: RNG { seed: new_seed }, value: u }
}

fn test_rng_uniform() -> bool {
    let mut rng = RNG { seed: 12345 }
    let mut sum = 0.0
    let n: i64 = 1000
    let mut i: i64 = 0

    while i < n {
        let r = rng_uniform(rng)
        rng = r.rng
        sum = sum + r.value
        i = i + 1
    }

    let mean = sum / (n as f64)
    // Mean of Uniform(0,1) should be ~0.5
    return abs_f64(mean - 0.5) < 0.1
}

// ============================================================================
// TEST 4: BETA DISTRIBUTION MOMENTS
// ============================================================================

fn test_beta_moments() -> bool {
    // For Beta(2, 5):
    // Mean = alpha / (alpha + beta) = 2/7 = 0.286
    // Variance = (alpha*beta) / ((alpha+beta)^2 * (alpha+beta+1))
    //          = 10 / (49 * 8) = 0.0255
    let alpha = 2.0
    let b = 5.0

    let mean = alpha / (alpha + b)
    let variance = (alpha * b) / ((alpha + b) * (alpha + b) * (alpha + b + 1.0))

    let mean_expected = 2.0 / 7.0
    let var_expected = 10.0 / 392.0

    let mean_err = abs_f64(mean - mean_expected)
    let var_err = abs_f64(variance - var_expected)

    return mean_err < 0.0001 && var_err < 0.0001
}

// ============================================================================
// TEST 5: GRADIENT OF ROSENBROCK
// ============================================================================

fn dual_pow(a: Dual, n: f64) -> Dual {
    // Simple case for n=2
    if abs_f64(n - 2.0) < 0.001 {
        return dual_mul(a, a)
    }
    // For other powers, use approximation
    return Dual { val: 0.0, dot: 0.0 }
}

fn rosenbrock_dual(x: Dual, y: Dual) -> Dual {
    // f(x,y) = (1-x)^2 + 100*(y-x^2)^2
    let one = dual_const(1.0)
    let hundred = dual_const(100.0)
    let term1 = dual_sub(one, x)
    let term1_sq = dual_mul(term1, term1)
    let x_sq = dual_mul(x, x)
    let term2 = dual_sub(y, x_sq)
    let term2_sq = dual_mul(term2, term2)
    return dual_add(term1_sq, dual_mul(hundred, term2_sq))
}

fn test_rosenbrock_gradient() -> bool {
    // At minimum (1, 1), gradient should be (0, 0)
    let fx_dx = rosenbrock_dual(dual_var(1.0), dual_const(1.0))
    let fx_dy = rosenbrock_dual(dual_const(1.0), dual_var(1.0))

    let val_err = abs_f64(fx_dx.val)  // f(1,1) = 0
    let dx_err = abs_f64(fx_dx.dot)   // df/dx(1,1) = 0
    let dy_err = abs_f64(fx_dy.dot)   // df/dy(1,1) = 0

    return val_err < 0.0001 && dx_err < 0.0001 && dy_err < 0.0001
}

// ============================================================================
// TEST 6: NORMAL-NORMAL CONJUGATE POSTERIOR
// ============================================================================

fn test_normal_normal_posterior() -> bool {
    // Prior: mu ~ N(0, 10^2)
    // Likelihood: x_i ~ N(mu, 1^2), with data mean = 5, n = 10
    // Posterior: mu | data ~ N(mu_post, sigma_post^2)
    // mu_post = (prior_prec * prior_mean + lik_prec * data_mean) / (prior_prec + lik_prec)

    let prior_mean = 0.0
    let prior_var = 100.0
    let data_mean = 5.0
    let data_var = 1.0
    let n: i64 = 10

    let prior_prec = 1.0 / prior_var
    let lik_prec = (n as f64) / data_var

    let post_prec = prior_prec + lik_prec
    let post_var = 1.0 / post_prec
    let post_mean = post_var * (prior_prec * prior_mean + lik_prec * data_mean)

    // Expected: post_prec = 0.01 + 10 = 10.01
    // post_mean = (0.01 * 0 + 10 * 5) / 10.01 = 50 / 10.01 = 4.995
    let expected_mean = 50.0 / 10.01

    let err = abs_f64(post_mean - expected_mean)
    return err < 0.001
}

// ============================================================================
// MAIN TEST RUNNER
// ============================================================================

fn main() -> i32 {
    println("=== Scientific Computing Integration Tests ===")
    println("")

    var all_passed = true

    // Test 1: RK4 ODE Solver
    print("Test 1: RK4 ODE Solver... ")
    if test_rk4_solver() {
        println("PASS")
    } else {
        println("FAIL")
        all_passed = false
    }

    // Test 2: Autodiff simple
    print("Test 2: Autodiff d/dx(x^2)... ")
    if test_autodiff_simple() {
        println("PASS")
    } else {
        println("FAIL")
        all_passed = false
    }

    // Test 3: Autodiff chain rule
    print("Test 3: Autodiff chain rule... ")
    if test_autodiff_chain() {
        println("PASS")
    } else {
        println("FAIL")
        all_passed = false
    }

    // Test 4: RNG uniform
    print("Test 4: RNG uniform mean... ")
    if test_rng_uniform() {
        println("PASS")
    } else {
        println("FAIL")
        all_passed = false
    }

    // Test 5: Beta moments
    print("Test 5: Beta distribution moments... ")
    if test_beta_moments() {
        println("PASS")
    } else {
        println("FAIL")
        all_passed = false
    }

    // Test 6: Rosenbrock gradient
    print("Test 6: Rosenbrock gradient at minimum... ")
    if test_rosenbrock_gradient() {
        println("PASS")
    } else {
        println("FAIL")
        all_passed = false
    }

    // Test 7: Normal-Normal posterior
    print("Test 7: Normal-Normal conjugate posterior... ")
    if test_normal_normal_posterior() {
        println("PASS")
    } else {
        println("FAIL")
        all_passed = false
    }

    println("")
    if all_passed {
        println("ALL TESTS PASSED")
        return 0
    } else {
        println("SOME TESTS FAILED")
        return 1
    }
}
