// Darwin PBPK 14-Compartment Model in Sounio
// ==============================================
// 
// This is the DEFINITIVE implementation of a physiologically-based
// pharmacokinetic model in Sounio - demonstrating what NO OTHER
// language can achieve:
//
// 1. COMPILE-TIME UNIT VERIFICATION
//    - mg, L, h, mL/min are checked at compile time
//    - Impossible to mix units incorrectly
//
// 2. EPISTEMIC TYPES
//    - Knowledge[T, epsilon >= bound] tracks confidence
//    - Confidence propagates through all computations
//    - FDA requires epsilon >= 0.80 for submission
//
// 3. REFINEMENT TYPES
//    - { vd: L | vd > 0 && vd < 2000 } catches impossible values
//    - No more VD = 50,000 L errors!
//
// 4. PROVENANCE TRACKING
//    - Every value knows its source
//    - Full audit trail for regulatory compliance
//
// Author: Demetrios Chiuratto Agourakis
// Inspired by: Darwin PBPK Platform (darwin-pbpk-platform)
// Version: 1.0.0

module darwin_pbpk_14comp

// =============================================================================
// UNIT DEFINITIONS
// =============================================================================

// Base units
unit mg      // milligram (mass)
unit L       // liter (volume)
unit h       // hour (time)
unit kg      // kilogram (body weight)

// Derived units
unit mg_per_L   = mg / L           // concentration
unit L_per_h    = L / h            // flow/clearance
unit mL_per_min = L / h * 0.06     // common clinical unit
unit per_h      = 1 / h            // rate constant

// =============================================================================
// REFINEMENT TYPES FOR PHYSIOLOGICAL CONSTRAINTS
// =============================================================================

// Volume of distribution must be physiologically plausible
type PhysioVd = { vd: L | vd > 0.0 && vd < 2000.0 }

// Clearance must be positive and reasonable
type PhysioCL = { cl: L_per_h | cl > 0.0 && cl < 5000.0 }

// Partition coefficients typically 0.01 to 100
type Kp = { kp: f64 | kp > 0.01 && kp < 100.0 }

// Bioavailability is 0-1
type Bioavailability = { f: f64 | f >= 0.0 && f <= 1.0 }

// Fraction unbound is 0-1
type FractionUnbound = { fu: f64 | fu > 0.0 && fu <= 1.0 }

// =============================================================================
// CORE TYPES
// =============================================================================

/// Drug entity with full epistemic qualification
pub struct Drug {
    /// Drug name
    pub name: string,
    
    /// Molecular weight
    pub mw: Knowledge[f64, epsilon >= 0.99],
    
    /// LogP (octanol-water partition coefficient)
    pub logp: Knowledge[f64, epsilon >= 0.90],
    
    /// Topological polar surface area
    pub tpsa: Knowledge[f64, epsilon >= 0.95],
    
    /// pKa for acidic groups (if any)
    pub pka_acidic: Option[Knowledge[f64, epsilon >= 0.80]],
    
    /// pKa for basic groups (if any)  
    pub pka_basic: Option[Knowledge[f64, epsilon >= 0.80]],
    
    /// Fraction unbound in plasma
    pub fu: Knowledge[FractionUnbound, epsilon >= 0.85],
    
    /// Blood:plasma ratio
    pub bp_ratio: Knowledge[f64, epsilon >= 0.80],
}

/// Patient profile for individualized PBPK
pub struct Patient {
    /// Patient identifier
    pub id: string,
    
    /// Body weight
    pub weight: kg,
    
    /// Age in years
    pub age: f64,
    
    /// Biological sex
    pub sex: Sex,
    
    /// Kidney function (eGFR)
    pub egfr: mL_per_min,
    
    /// Liver function (Child-Pugh score for impairment)
    pub liver_function: LiverFunction,
}

pub enum Sex { Male, Female }

pub enum LiverFunction {
    Normal,
    MildImpairment,     // Child-Pugh A
    ModerateImpairment, // Child-Pugh B  
    SevereImpairment,   // Child-Pugh C
}

/// 14-Compartment PBPK Model Parameters
pub struct PBPK14Params {
    // Clearance parameters
    pub cl_hepatic: Knowledge[PhysioCL, epsilon >= 0.75],
    pub cl_renal: Knowledge[PhysioCL, epsilon >= 0.75],
    
    // Volume of distribution
    pub vd: Knowledge[PhysioVd, epsilon >= 0.80],
    
    // Absorption
    pub ka: Knowledge[per_h, epsilon >= 0.70],
    pub f_oral: Knowledge[Bioavailability, epsilon >= 0.75],
    
    // Partition coefficients (14 organs)
    pub kp: [Knowledge[Kp, epsilon >= 0.60]; 14],
}

// =============================================================================
// PHYSIOLOGICAL CONSTANTS (Reference: 70kg Adult)
// =============================================================================

/// Organ names for the 14-compartment model
pub const ORGANS: [string; 14] = [
    "blood",     // 0 - Central compartment
    "liver",     // 1 - Metabolism
    "kidney",    // 2 - Excretion
    "brain",     // 3 - BBB-protected
    "heart",     // 4
    "lung",      // 5 - First-pass pulmonary
    "muscle",    // 6 - Large volume
    "adipose",   // 7 - Lipophilic depot
    "gut",       // 8 - Absorption site
    "skin",      // 9
    "bone",      // 10
    "spleen",    // 11
    "pancreas",  // 12
    "rest",      // 13 - Remaining tissues
];

/// Reference organ volumes for 70kg adult (L)
pub const REF_VOLUMES: [L; 14] = [
    5.0,    // blood
    1.8,    // liver
    0.31,   // kidney
    1.4,    // brain
    0.33,   // heart
    0.5,    // lung
    28.0,   // muscle
    18.0,   // adipose
    1.1,    // gut
    3.3,    // skin
    10.0,   // bone
    0.18,   // spleen
    0.1,    // pancreas
    3.5,    // rest
];

/// Reference blood flows for 70kg adult (L/h)
/// Cardiac output ≈ 348 L/h (5.8 L/min)
pub const REF_FLOWS: [L_per_h; 14] = [
    348.0,  // blood (cardiac output)
    90.0,   // liver (hepatic artery + portal)
    72.0,   // kidney
    42.0,   // brain
    12.0,   // heart
    348.0,  // lung (full CO)
    54.0,   // muscle
    17.0,   // adipose
    58.0,   // gut
    17.0,   // skin
    17.0,   // bone
    10.0,   // spleen
    3.0,    // pancreas
    10.0,   // rest
];

// =============================================================================
// PARTITION COEFFICIENT CALCULATION (Rodgers-Rowland)
// =============================================================================

/// Calculate tissue:plasma partition coefficient using Rodgers-Rowland method
/// 
/// This is the MECHANISTIC approach - uses physicochemical properties
/// to predict drug distribution.
///
/// For ACIDS (pKa < 7):
///   Kp = fu_p / fu_t * (1 + 10^(pH_t - pKa)) / (1 + 10^(7.4 - pKa))
///
/// For BASES (pKa > 7):
///   Kp includes lysosomal trapping term
///
pub fn calculate_kp_rodgers_rowland(
    drug: &Drug,
    tissue: usize,
) -> Knowledge[Kp, epsilon >= 0.60] with Prob {
    let logp = drug.logp.value;
    let fu = drug.fu.value;
    
    // Tissue composition (simplified)
    let tissue_data = get_tissue_composition(tissue);
    
    // Neutral lipophilic partitioning
    let kp_neutral = 1.0 + logp * tissue_data.lipid_fraction;
    
    // Ionization adjustment
    let kp_ionized = match (drug.pka_acidic, drug.pka_basic) {
        (Some(pka_a), None) => {
            // Acid: less tissue binding
            kp_neutral * 0.8
        }
        (None, Some(pka_b)) if pka_b.value > 7.0 => {
            // Basic: lysosomal trapping
            let trap_factor = 1.0 + 0.5 * (pka_b.value - 7.0);
            kp_neutral * trap_factor
        }
        _ => kp_neutral
    };
    
    // Apply fraction unbound correction
    let kp_final = kp_ionized / fu;
    
    // Clamp to physiological range
    let kp_clamped = kp_final.clamp(0.1, 50.0);
    
    // Propagate confidence
    let confidence = drug.logp.confidence
        .min(drug.fu.confidence)
        * 0.85;  // Model uncertainty
    
    Knowledge::new(
        value: kp_clamped,
        confidence: confidence,
        provenance: Provenance::derived("rodgers_rowland_kp"),
    )
}

/// Tissue composition data for Kp calculation
struct TissueComposition {
    lipid_fraction: f64,
    water_fraction: f64,
    protein_fraction: f64,
    ph: f64,
}

fn get_tissue_composition(tissue: usize) -> TissueComposition {
    match tissue {
        0 => TissueComposition { lipid_fraction: 0.0, water_fraction: 0.83, protein_fraction: 0.17, ph: 7.4 },  // blood
        1 => TissueComposition { lipid_fraction: 0.05, water_fraction: 0.70, protein_fraction: 0.25, ph: 7.0 }, // liver
        2 => TissueComposition { lipid_fraction: 0.03, water_fraction: 0.79, protein_fraction: 0.18, ph: 7.0 }, // kidney
        3 => TissueComposition { lipid_fraction: 0.12, water_fraction: 0.77, protein_fraction: 0.11, ph: 7.0 }, // brain
        7 => TissueComposition { lipid_fraction: 0.85, water_fraction: 0.12, protein_fraction: 0.03, ph: 7.0 }, // adipose
        _ => TissueComposition { lipid_fraction: 0.02, water_fraction: 0.75, protein_fraction: 0.23, ph: 7.0 }, // default
    }
}

// =============================================================================
// ODE SYSTEM
// =============================================================================

/// State vector for 14-compartment model + gut lumen
pub struct PBPKState {
    /// Amount in each compartment (mg)
    pub amounts: [mg; 15],  // 14 organs + gut lumen
    
    /// Current time
    pub time: h,
}

/// PBPK ODE right-hand side
///
/// dA_blood/dt = Σ(Q_i * (C_i/Kp_i - C_blood)) - CL_total * C_blood + ka * A_gut_lumen * F
/// dA_tissue/dt = Q_i * (C_blood - C_i/Kp_i)
/// dA_gut_lumen/dt = -ka * A_gut_lumen
///
pub fn pbpk_ode(
    state: &PBPKState,
    params: &PBPK14Params,
    volumes: &[L; 14],
    flows: &[L_per_h; 14],
) -> [mg_per_h; 15] with Alloc {
    let mut derivatives: [mg_per_h; 15] = [0.0; 15];
    
    // Blood concentration
    let c_blood = state.amounts[0] / volumes[0];
    
    // Tissue exchange
    for i in 1..14 {
        let c_tissue = state.amounts[i] / volumes[i];
        let kp = params.kp[i].value;
        
        // Rate = Q * (C_blood - C_tissue/Kp)
        let rate = flows[i] * (c_blood - c_tissue / kp);
        
        derivatives[i] = rate;           // Tissue gains
        derivatives[0] -= rate;          // Blood loses
    }
    
    // Hepatic elimination
    let cl_h = params.cl_hepatic.value;
    derivatives[0] -= cl_h * c_blood;
    
    // Renal elimination  
    let cl_r = params.cl_renal.value;
    derivatives[0] -= cl_r * c_blood;
    
    // Oral absorption
    let ka = params.ka.value;
    let f = params.f_oral.value;
    let absorption_rate = ka * state.amounts[14];
    
    derivatives[14] = -absorption_rate;           // Gut lumen depletes
    derivatives[0] += absorption_rate * f;        // Blood gains (with F)
    
    derivatives
}

// =============================================================================
// SIMULATION WITH EPISTEMIC TRACKING
// =============================================================================

/// Simulation result with full epistemic tracking
pub struct SimulationResult {
    /// Time points
    pub times: Vec<h>,
    
    /// Plasma concentrations with confidence
    pub plasma_conc: Vec<Knowledge[mg_per_L, epsilon >= 0.50]>,
    
    /// Overall simulation confidence
    pub confidence: f64,
    
    /// Full provenance chain
    pub provenance: Provenance,
    
    /// PK metrics
    pub metrics: PKMetrics,
}

/// Pharmacokinetic metrics
pub struct PKMetrics {
    pub cmax: Knowledge[mg_per_L, epsilon >= 0.60],
    pub tmax: h,
    pub auc_0_inf: Knowledge[mg_per_L * h, epsilon >= 0.60],
    pub half_life: Knowledge[h, epsilon >= 0.60],
}

/// Run PBPK simulation
pub fn simulate(
    drug: &Drug,
    params: &PBPK14Params,
    patient: &Patient,
    dose: mg,
    duration: h,
    dt: h,
) -> SimulationResult with Alloc, Prob {
    // Scale physiology to patient
    let volumes = scale_volumes(&REF_VOLUMES, patient);
    let flows = scale_flows(&REF_FLOWS, patient);
    
    // Initialize state
    let mut state = PBPKState {
        amounts: [0.0; 15],
        time: 0.0 : h,
    };
    state.amounts[14] = dose;  // Dose in gut lumen
    
    // Collect results
    let mut times: Vec<h> = vec![];
    let mut plasma_conc: Vec<Knowledge[mg_per_L, epsilon >= 0.50]> = vec![];
    
    // Base confidence from parameters
    let base_conf = params.cl_hepatic.confidence
        .min(params.vd.confidence)
        .min(params.ka.confidence);
    
    // Integration loop (simple Euler - would use RK4 in production)
    while state.time <= duration {
        // Record current state
        times.push(state.time);
        
        let c_plasma = state.amounts[0] / volumes[0] / drug.bp_ratio.value;
        plasma_conc.push(Knowledge::new(
            value: c_plasma,
            confidence: base_conf * 0.95,
            provenance: Provenance::derived("ode_simulation"),
        ));
        
        // Compute derivatives
        let derivs = pbpk_ode(&state, params, &volumes, &flows);
        
        // Update state
        for i in 0..15 {
            state.amounts[i] += derivs[i] * dt;
            state.amounts[i] = state.amounts[i].max(0.0);  // No negative amounts
        }
        state.time += dt;
    }
    
    // Calculate PK metrics
    let metrics = calculate_pk_metrics(&times, &plasma_conc);
    
    SimulationResult {
        times,
        plasma_conc,
        confidence: base_conf * 0.90,
        provenance: Provenance::merged([
            drug.provenance(),
            params.provenance(),
            Provenance::source("darwin_pbpk_solver_v1"),
        ]),
        metrics,
    }
}

fn calculate_pk_metrics(
    times: &[h],
    conc: &[Knowledge[mg_per_L, epsilon >= 0.50]],
) -> PKMetrics {
    // Cmax and Tmax
    let (cmax_idx, cmax_val) = conc.iter()
        .enumerate()
        .max_by(|a, b| a.1.value.partial_cmp(&b.1.value).unwrap())
        .unwrap();
    
    let cmax = Knowledge::new(
        value: cmax_val.value,
        confidence: cmax_val.confidence,
        provenance: Provenance::derived("cmax"),
    );
    let tmax = times[cmax_idx];
    
    // AUC by trapezoidal rule
    let mut auc = 0.0 : mg_per_L * h;
    let mut min_conf = 1.0;
    for i in 1..times.len() {
        let dt = times[i] - times[i-1];
        let avg = (conc[i].value + conc[i-1].value) / 2.0;
        auc += avg * dt;
        min_conf = min_conf.min(conc[i].confidence);
    }
    
    let auc_knowledge = Knowledge::new(
        value: auc,
        confidence: min_conf * 0.98,
        provenance: Provenance::derived("trapezoidal_auc"),
    );
    
    // Half-life (simplified)
    let half_life = Knowledge::new(
        value: 0.693 * (auc / cmax.value) : h,
        confidence: min_conf * 0.90,
        provenance: Provenance::derived("half_life_estimate"),
    );
    
    PKMetrics { cmax, tmax, auc_0_inf: auc_knowledge, half_life }
}

// =============================================================================
// ALLOMETRIC SCALING
// =============================================================================

fn scale_volumes(ref_vols: &[L; 14], patient: &Patient) -> [L; 14] {
    let bw_ratio = patient.weight / 70.0_kg;
    ref_vols.map(|v| v * bw_ratio)
}

fn scale_flows(ref_flows: &[L_per_h; 14], patient: &Patient) -> [L_per_h; 14] {
    let bw_ratio = patient.weight / 70.0_kg;
    // Flows scale with BW^0.75
    ref_flows.map(|q| q * bw_ratio.pow(0.75))
}

// =============================================================================
// FDA VALIDATION
// =============================================================================

/// Validation metrics for regulatory submission
pub struct ValidationMetrics {
    /// Geometric Mean Fold Error
    pub gmfe: f64,
    
    /// Average Fold Error
    pub afe: f64,
    
    /// Absolute Average Fold Error
    pub aafe: f64,
    
    /// Percentage within 2-fold
    pub within_2fold: f64,
    
    /// R-squared
    pub r_squared: f64,
}

/// Validate predictions against observations
/// REQUIRES: All predictions have epsilon >= 0.80
pub fn validate(
    predictions: &[Knowledge[mg_per_L, epsilon >= 0.80]],
    observations: &[mg_per_L],
) -> Result[ValidationMetrics, ValidationError] {
    assert_eq!(predictions.len(), observations.len());
    
    let n = predictions.len() as f64;
    
    // Check confidence requirements
    for (i, pred) in predictions.iter().enumerate() {
        if pred.confidence < 0.80 {
            return Err(ValidationError::InsufficientConfidence {
                index: i,
                required: 0.80,
                actual: pred.confidence,
            });
        }
    }
    
    // Calculate fold errors
    let fold_errors: Vec<f64> = predictions.iter()
        .zip(observations)
        .map(|(p, o)| p.value / o)
        .collect();
    
    // GMFE = exp(mean(|log(pred/obs)|))
    let gmfe = fold_errors.iter()
        .map(|fe| fe.ln().abs())
        .sum::<f64>()
        .div(n)
        .exp();
    
    // AFE = 10^(mean(log10(pred/obs)))
    let afe = fold_errors.iter()
        .map(|fe| fe.log10())
        .sum::<f64>()
        .div(n)
        .pow(10.0);
    
    // AAFE = 10^(mean(|log10(pred/obs)|))
    let aafe = fold_errors.iter()
        .map(|fe| fe.log10().abs())
        .sum::<f64>()
        .div(n)
        .pow(10.0);
    
    // Within 2-fold
    let within_2fold = fold_errors.iter()
        .filter(|fe| **fe >= 0.5 && **fe <= 2.0)
        .count() as f64 / n * 100.0;
    
    // R-squared
    let mean_obs = observations.iter().sum::<mg_per_L>() / n;
    let ss_tot: f64 = observations.iter()
        .map(|o| (o - mean_obs).powi(2))
        .sum();
    let ss_res: f64 = predictions.iter()
        .zip(observations)
        .map(|(p, o)| (p.value - o).powi(2))
        .sum();
    let r_squared = 1.0 - ss_res / ss_tot;
    
    Ok(ValidationMetrics { gmfe, afe, aafe, within_2fold, r_squared })
}

pub enum ValidationError {
    InsufficientConfidence {
        index: usize,
        required: f64,
        actual: f64,
    },
}

// =============================================================================
// MAIN EXAMPLE
// =============================================================================

pub fn main() with IO, Alloc {
    println("=== Darwin PBPK 14-Compartment Model in Sounio ===")
    println("Demonstrating compile-time unit safety and epistemic computing")
    println("")
    
    // Define drug (Midazolam as example)
    let drug = Drug {
        name: "Midazolam",
        mw: Knowledge::new(325.77, 0.99, Provenance::source("PubChem")),
        logp: Knowledge::new(2.5, 0.95, Provenance::source("PubChem")),
        tpsa: Knowledge::new(30.2, 0.98, Provenance::source("PubChem")),
        pka_acidic: None,
        pka_basic: Some(Knowledge::new(5.2, 0.85, Provenance::source("ChemAxon"))),
        fu: Knowledge::new(0.04, 0.90, Provenance::source("DrugBank")),
        bp_ratio: Knowledge::new(0.66, 0.85, Provenance::source("Simcyp")),
    };
    
    // Define patient
    let patient = Patient {
        id: "SUBJ001",
        weight: 70.0 : kg,
        age: 35.0,
        sex: Sex::Male,
        egfr: 100.0 : mL_per_min,
        liver_function: LiverFunction::Normal,
    };
    
    // Define PBPK parameters
    let params = PBPK14Params {
        cl_hepatic: Knowledge::new(27.0 : L_per_h, 0.85, Provenance::source("Simcyp")),
        cl_renal: Knowledge::new(0.5 : L_per_h, 0.90, Provenance::source("Literature")),
        vd: Knowledge::new(77.0 : L, 0.88, Provenance::source("Population_PK")),
        ka: Knowledge::new(4.0 : per_h, 0.75, Provenance::source("Deconvolution")),
        f_oral: Knowledge::new(0.44, 0.80, Provenance::source("Clinical_Trial")),
        kp: calculate_all_kps(&drug),
    };
    
    // Run simulation
    let dose = 7.5 : mg;
    let result = simulate(&drug, &params, &patient, dose, 24.0 : h, 0.1 : h);
    
    // Display results
    println("Drug: {}", drug.name)
    println("Dose: {} mg oral", dose)
    println("")
    println("PK Metrics:")
    println("  Cmax: {:.2} ng/mL (epsilon={:.2})", result.metrics.cmax.value * 1000.0, result.metrics.cmax.confidence)
    println("  Tmax: {:.1} h", result.metrics.tmax)
    println("  AUC: {:.1} ng·h/mL (epsilon={:.2})", result.metrics.auc_0_inf.value * 1000.0, result.metrics.auc_0_inf.confidence)
    println("  t½: {:.1} h (epsilon={:.2})", result.metrics.half_life.value, result.metrics.half_life.confidence)
    println("")
    println("Overall simulation confidence: {:.2}", result.confidence)
    println("")
    println("=== Simulation Complete ===")
}

fn calculate_all_kps(drug: &Drug) -> [Knowledge[Kp, epsilon >= 0.60]; 14] {
    let mut kps: [Knowledge[Kp, epsilon >= 0.60]; 14] = default();
    for i in 0..14 {
        kps[i] = calculate_kp_rodgers_rowland(drug, i);
    }
    kps
}
