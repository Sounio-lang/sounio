// Day 21: Build System Demo
//
// This example demonstrates the incremental build system by
// creating a multi-module project structure.
//
// To build this project:
//   dc build --incremental
//
// To see what would be rebuilt:
//   dc build --dry-run
//
// To clean and rebuild:
//   dc clean && dc build

// Module A: Core utilities
module core;

fn add(x: i64, y: i64) -> i64 {
    x + y
}

fn multiply(x: i64, y: i64) -> i64 {
    x * y
}

// Module B: Math functions (depends on core)
module math;

import core;

fn square(x: i64) -> i64 {
    core.multiply(x, x)
}

fn cube(x: i64) -> i64 {
    core.multiply(core.multiply(x, x), x)
}

fn sum_of_squares(a: i64, b: i64) -> i64 {
    core.add(square(a), square(b))
}

// Module C: Application (depends on math, core)
module app;

import core;
import math;

fn compute_distance(x: i64, y: i64) -> i64 {
    // Euclidean distance squared (avoiding sqrt for integer math)
    math.sum_of_squares(x, y)
}

fn main() with IO {
    let x = 3;
    let y = 4;

    // Using core functions
    let sum = core.add(x, y);
    let product = core.multiply(x, y);

    // Using math functions
    let x_squared = math.square(x);
    let distance_sq = compute_distance(x, y);

    print("Sum: ");
    print_int(sum);
    print("\n");

    print("Product: ");
    print_int(product);
    print("\n");

    print("Square: ");
    print_int(x_squared);
    print("\n");

    print("Distance squared: ");
    print_int(distance_sq);
    print("\n");
}

// Build system notes:
//
// Dependency graph:
//   app -> math -> core
//       \-------->
//
// If core.d changes:
//   - core is recompiled
//   - math is recompiled (depends on core)
//   - app is recompiled (depends on core and math)
//
// If math.d changes:
//   - math is recompiled
//   - app is recompiled (depends on math)
//   - core is NOT recompiled (no dependency)
//
// If app.d changes:
//   - app is recompiled
//   - math and core are NOT recompiled
//
// Cache behavior:
//   - Each compilation unit has a content hash
//   - Artifacts are stored by hash in .sounio/cache/
//   - On rebuild, unchanged units hit cache
//
// Parallel execution:
//   - core can compile immediately (no deps)
//   - math waits for core
//   - app waits for math and core
//   - With --jobs=N, independent units compile in parallel
