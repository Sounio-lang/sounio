//! Comprehensive macro system demonstration
//!
//! Showcases:
//! - Declarative macros with pattern matching
//! - Procedural macros (derive, attribute)
//! - Compile-time function execution
//! - Scientific domain-specific macros

// ============================================================================
// Part 1: Declarative Macros
// ============================================================================

/// Simple assert macro
macro_rules! assert {
    ($cond:expr) => {
        if !$cond {
            panic!("assertion failed");
        }
    };
    ($cond:expr, $msg:expr) => {
        if !$cond {
            panic!("assertion failed: {}", $msg);
        }
    };
}

/// Vector construction macro
macro_rules! vec {
    () => { Vec::new() };
    ($($x:expr),*) => {
        {
            let mut v = Vec::new();
            $(v.push($x);)*
            v
        }
    };
    ($x:expr; $n:expr) => {
        {
            let mut v = Vec::new();
            for _ in 0..$n {
                v.push($x);
            }
            v
        }
    };
}

/// Matrix construction macro
macro_rules! matrix {
    ($($($x:expr),*);*) => {
        {
            let mut m = Vec::new();
            $(
                let mut row = Vec::new();
                $(row.push($x);)*
                m.push(row);
            )*
            m
        }
    };
}

/// Repeat macro with separator
macro_rules! repeat {
    ($($x:expr),*) => {
        vec![$($x),*]
    };
}

// ============================================================================
// Part 2: Procedural Macros (Derive)
// ============================================================================

/// Derive Debug trait
#[derive(Debug)]
struct Point {
    x: f64,
    y: f64,
}

/// Derive Clone trait
#[derive(Clone)]
struct Vector {
    components: Vec<f64>,
}

/// Derive Serialize trait
#[derive(Serialize)]
struct Data {
    name: String,
    value: i32,
}

// ============================================================================
// Part 3: Compile-Time Evaluation
// ============================================================================

/// Compile-time factorial
const fn factorial(n: i32) -> i32 {
    if n <= 1 { 1 } else { n * factorial(n - 1) }
}

/// Compile-time Fibonacci
const fn fibonacci(n: i32) -> i32 {
    if n <= 1 { n } else { fibonacci(n - 1) + fibonacci(n - 2) }
}

/// Compile-time array length
const fn array_len<T, const N: usize>(_: &[T; N]) -> usize {
    N
}

/// Compile-time constants
const FACT_5: i32 = factorial(5);      // 120
const FIB_10: i32 = fibonacci(10);     // 55
const ARRAY_SIZE: usize = array_len(&[1, 2, 3, 4, 5]);  // 5

// ============================================================================
// Part 4: Scientific Macros - Dimensional Analysis
// ============================================================================

use units::*;

/// Pharmacokinetic calculation with unit checking
fn calculate_concentration() {
    // Dose in milligrams
    let dose: mg = 500.0;
    
    // Volume in milliliters
    let volume: mL = 10.0;
    
    // Concentration in mg/mL (type-checked at compile time)
    let concentration: mg/mL = dose / volume;
    
    println!("Dose: {} mg", dose);
    println!("Volume: {} mL", volume);
    println!("Concentration: {} mg/mL", concentration);
    
    // Clearance in L/h
    let clearance: L/h = 0.5;
    
    // Half-life in hours
    let half_life: h = 4.0;
    
    println!("Clearance: {} L/h", clearance);
    println!("Half-life: {} h", half_life);
}

/// Dimensional analysis prevents unit errors
fn unit_safety_demo() {
    let mass: kg = 70.0;
    let acceleration: m/s2 = 9.81;
    
    // Force = mass Ã— acceleration (type-checked)
    let force: N = mass * acceleration;
    
    println!("Force: {} N", force);
    
    // This would be a compile-time error:
    // let invalid: kg = 10.0: m;  // ERROR: dimension mismatch
}

// ============================================================================
// Part 5: Scientific Macros - Automatic Differentiation
// ============================================================================

use autodiff::*;

/// Compute gradient at compile time
fn gradient_demo() {
    // Define function: f(x) = xÂ² + 2x + 1
    let f = |x: f64| x * x + 2.0 * x + 1.0;
    
    // Compute derivative: f'(x) = 2x + 2
    let grad_at_3 = gradient(f, 3.0);  // Should be 8.0
    
    println!("f(x) = xÂ² + 2x + 1");
    println!("f'(3) = {}", grad_at_3);
    
    // Multivariate function
    let g = |x: f64, y: f64| x * x + y * y;
    
    // Compute partial derivatives
    let grad_x = gradient(|x| g(x, 2.0), 1.0);
    let grad_y = gradient(|y| g(1.0, y), 2.0);
    
    println!("g(x,y) = xÂ² + yÂ²");
    println!("âˆ‚g/âˆ‚x(1,2) = {}", grad_x);
    println!("âˆ‚g/âˆ‚y(1,2) = {}", grad_y);
}

// ============================================================================
// Part 6: Attribute Macros
// ============================================================================

/// Effect annotation macro
#[effect(IO, Prob)]
fn simulate_with_effects() {
    println!("This function has IO and Prob effects");
}

/// Optimization hint macro
#[inline]
fn hot_path() {
    // Compiler will inline this function
}

// ============================================================================
// Part 7: Static Assertions
// ============================================================================

/// Compile-time assertions
fn static_checks() {
    // Check size of types
    static_assert!(std::mem::size_of::<u64>() == 8, "u64 must be 8 bytes");
    static_assert!(std::mem::size_of::<f64>() == 8, "f64 must be 8 bytes");
    
    // Check array bounds
    const ARRAY: [i32; 5] = [1, 2, 3, 4, 5];
    static_assert!(array_len(&ARRAY) == 5, "array must have 5 elements");
}

// ============================================================================
// Main Demo
// ============================================================================

fn main() with IO {
    println!("ðŸ”§ Sounio Macro System Demo");
    println!("==============================\n");
    
    // Declarative macros
    println!("1. Declarative Macros:");
    let v = vec![1, 2, 3, 4, 5];
    println!("   vec![1,2,3,4,5] = {:?}", v);
    
    let m = matrix![[1, 2], [3, 4]];
    println!("   matrix![[1,2],[3,4]] = {:?}", m);
    
    // Compile-time evaluation
    println!("\n2. Compile-Time Evaluation:");
    println!("   factorial(5) = {}", FACT_5);
    println!("   fibonacci(10) = {}", FIB_10);
    println!("   array_len([1,2,3,4,5]) = {}", ARRAY_SIZE);
    
    // Dimensional analysis
    println!("\n3. Dimensional Analysis:");
    calculate_concentration();
    unit_safety_demo();
    
    // Automatic differentiation
    println!("\n4. Automatic Differentiation:");
    gradient_demo();
    
    // Assertions
    println!("\n5. Static Assertions:");
    static_checks();
    println!("   All static assertions passed âœ“");
    
    println!("\nâœ… Macro system demo completed!");
}
