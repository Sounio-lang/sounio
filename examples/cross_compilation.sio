// Cross-Compilation Example for Sounio
// Demonstrates platform-specific code using cfg attributes

// Platform-specific constants
#[cfg(target_pointer_width = "64")]
const POINTER_SIZE: i32 = 8;

#[cfg(target_pointer_width = "32")]
const POINTER_SIZE: i32 = 4;

// Architecture-specific optimizations
#[cfg(target_arch = "x86_64")]
fn fast_hash(data: &[u8]) -> u64 with Pure {
    // Use SSE4.2 CRC32 on x86_64
    var hash: u64 = 0;
    for byte in data {
        hash = hash * 31 + byte as u64;
    }
    hash
}

#[cfg(target_arch = "aarch64")]
fn fast_hash(data: &[u8]) -> u64 with Pure {
    // Use CRC32 instructions on ARM64
    var hash: u64 = 0;
    for byte in data {
        hash = hash * 33 + byte as u64;
    }
    hash
}

#[cfg(not(any(target_arch = "x86_64", target_arch = "aarch64")))]
fn fast_hash(data: &[u8]) -> u64 with Pure {
    // Generic fallback implementation
    var hash: u64 = 5381;
    for byte in data {
        hash = ((hash << 5) + hash) + byte as u64;
    }
    hash
}

// OS-specific functionality
#[cfg(target_os = "linux")]
fn get_page_size() -> i32 with IO {
    // Linux: use sysconf
    4096  // Simplified for example
}

#[cfg(target_os = "windows")]
fn get_page_size() -> i32 with IO {
    // Windows: use GetSystemInfo
    4096  // Simplified for example
}

#[cfg(target_os = "macos")]
fn get_page_size() -> i32 with IO {
    // macOS: use vm_page_size
    16384  // Apple Silicon uses 16KB pages
}

#[cfg(target_os = "none")]
fn get_page_size() -> i32 with Pure {
    // Bare metal: fixed page size
    4096
}

// Environment-specific code
#[cfg(target_env = "gnu")]
fn c_runtime_name() -> string with Pure {
    "glibc"
}

#[cfg(target_env = "musl")]
fn c_runtime_name() -> string with Pure {
    "musl"
}

#[cfg(target_env = "msvc")]
fn c_runtime_name() -> string with Pure {
    "msvcrt"
}

// Feature-gated optimizations
#[cfg(target_feature = "sse4.2")]
fn crc32_accelerated(data: &[u8]) -> u32 with Pure {
    // Use hardware CRC32
    0  // Placeholder
}

#[cfg(target_feature = "neon")]
fn simd_add(a: &[f32], b: &[f32], out: &![f32]) with Pure {
    // Use ARM NEON SIMD
    for i in 0..a.len() {
        out[i] = a[i] + b[i];
    }
}

// Family-based code organization
#[cfg(target_family = "unix")]
fn path_separator() -> char with Pure {
    '/'
}

#[cfg(target_family = "windows")]
fn path_separator() -> char with Pure {
    '\\'
}

// WebAssembly-specific code
#[cfg(target_arch = "wasm32")]
fn wasm_memory_grow(pages: i32) -> i32 with IO {
    // WebAssembly memory.grow instruction
    0  // Placeholder
}

#[cfg(all(target_arch = "wasm32", target_os = "wasi"))]
fn wasi_fd_write(fd: i32, data: &[u8]) -> i32 with IO {
    // WASI file descriptor write
    data.len() as i32
}

// Embedded/bare-metal specific
#[cfg(all(target_arch = "arm", target_os = "none"))]
fn cortex_m_enable_interrupts() with IO {
    // Enable interrupts on Cortex-M
    // __asm__("cpsie i");
}

#[cfg(all(target_arch = "arm", target_os = "none"))]
fn cortex_m_disable_interrupts() with IO {
    // Disable interrupts on Cortex-M
    // __asm__("cpsid i");
}

// Endianness-specific code
#[cfg(target_endian = "little")]
fn to_network_order(value: u32) -> u32 with Pure {
    // Swap bytes for network order (big endian)
    ((value & 0xFF) << 24) |
    ((value & 0xFF00) << 8) |
    ((value & 0xFF0000) >> 8) |
    ((value & 0xFF000000) >> 24)
}

#[cfg(target_endian = "big")]
fn to_network_order(value: u32) -> u32 with Pure {
    // Already in network order
    value
}

// Combined conditions
#[cfg(all(target_os = "linux", target_arch = "x86_64", target_env = "gnu"))]
fn linux_x64_gnu_specific() with IO {
    // Code specific to x86_64 Linux with glibc
    print("Running on x86_64 Linux with glibc");
}

#[cfg(any(
    all(target_os = "macos", target_arch = "aarch64"),
    all(target_os = "ios", target_arch = "aarch64")
))]
fn apple_silicon_specific() with IO {
    // Code for Apple Silicon (M1/M2/M3)
    print("Running on Apple Silicon");
}

// Main function with conditional compilation
fn main() with IO {
    print("Cross-Compilation Demo");
    print("======================");

    #[cfg(target_os = "linux")]
    print("Platform: Linux");

    #[cfg(target_os = "windows")]
    print("Platform: Windows");

    #[cfg(target_os = "macos")]
    print("Platform: macOS");

    #[cfg(target_os = "none")]
    print("Platform: Bare Metal");

    #[cfg(target_arch = "wasm32")]
    print("Platform: WebAssembly");

    print("");
    print("Pointer size: {} bytes", POINTER_SIZE);
    print("Path separator: '{}'", path_separator());

    #[cfg(not(target_os = "none"))]
    {
        print("C runtime: {}", c_runtime_name());
        print("Page size: {} bytes", get_page_size());
    }

    let test_data = [1u8, 2, 3, 4, 5];
    print("Hash of test data: {}", fast_hash(&test_data));

    let value: u32 = 0x12345678;
    print("Network order of 0x{:08X}: 0x{:08X}", value, to_network_order(value));
}
