//! Linear Algebra Demo
//!
//! Demonstrates the comprehensive linear algebra capabilities of Sounio:
//! - Fixed-size vectors and matrices (stack-allocated, SIMD-optimized)
//! - Dynamic dense vectors and matrices (heap-allocated, BLAS-accelerated)
//! - BLAS operations (Level 1, 2, 3)
//! - LAPACK decompositions (LU, QR, SVD, eigenvalues)
//!
//! Run with: dc run examples/linalg_demo.d

use linalg::*

fn main() -> i32 {
    println("=== Sounio Linear Algebra Demo ===")
    println("")

    // ========================================================================
    // PART 1: Fixed-Size Vectors (Stack-Allocated)
    // ========================================================================
    println("--- Part 1: Fixed-Size Vectors ---")
    println("")

    // Vec3 operations
    let v1 = vec3_new(1.0, 2.0, 3.0)
    let v2 = vec3_new(4.0, 5.0, 6.0)

    let v_add = vec3_add(v1, v2)
    println("v1 = (1, 2, 3)")
    println("v2 = (4, 5, 6)")
    println("v1 + v2 = ({}, {}, {})", v_add.x, v_add.y, v_add.z)

    let dot = vec3_dot(v1, v2)
    println("v1 . v2 = {}", dot)  // Expected: 32

    let norm = vec3_norm(v1)
    println("|v1| = {}", norm)  // Expected: sqrt(14) ≈ 3.742

    let cross = vec3_cross(v1, v2)
    println("v1 x v2 = ({}, {}, {})", cross.x, cross.y, cross.z)  // Expected: (-3, 6, -3)
    println("")

    // Vec14 for PBPK (14-compartment pharmacokinetic model)
    println("Vec14 (PBPK compartments):")
    let compartments = vec14_new(
        100.0, 50.0, 25.0, 12.5, 6.25, 3.125, 1.5625,
        0.78125, 0.390625, 0.195, 0.0975, 0.04875, 0.024375, 0.0121875
    )
    let total_mass = vec14_sum(compartments)
    println("Total drug mass in 14 compartments = {}", total_mass)
    println("")

    // ========================================================================
    // PART 2: Fixed-Size Matrices (Stack-Allocated)
    // ========================================================================
    println("--- Part 2: Fixed-Size Matrices ---")
    println("")

    // Mat3 operations
    let m1 = mat3_new(
        1.0, 2.0, 3.0,
        0.0, 1.0, 4.0,
        5.0, 6.0, 0.0
    )

    println("M = [[1, 2, 3], [0, 1, 4], [5, 6, 0]]")

    let det = mat3_det(m1)
    println("det(M) = {}", det)  // Expected: 1

    let trace = mat3_trace(m1)
    println("trace(M) = {}", trace)  // Expected: 2

    let m_inv = mat3_inverse(m1)
    let m_check = mat3_mul(m1, m_inv)
    println("M * M^(-1) trace = {}", mat3_trace(m_check))  // Expected: 3 (identity trace)

    // Matrix-vector multiply
    let v = Vec3 { x: 1.0, y: 2.0, z: 3.0 }
    let result = mat3_vec_mul(m1, v)
    println("M * v = ({}, {}, {})", result.x, result.y, result.z)  // Expected: (14, 14, 17)
    println("")

    // Mat4 for transformations
    println("Mat4 (4x4 transformation matrix):")
    let m4 = mat4_identity()
    let m4_scaled = mat4_scale(m4, 2.0)
    println("2*I trace = {}", mat4_trace(m4_scaled))  // Expected: 8
    println("")

    // ========================================================================
    // PART 3: Dynamic Vectors (BLAS-Accelerated)
    // ========================================================================
    println("--- Part 3: Dynamic Dense Vectors ---")
    println("")

    // Create vectors
    let dv1 = DenseVector::from_slice(&[1.0, 2.0, 3.0, 4.0, 5.0])
    let dv2 = DenseVector::from_slice(&[5.0, 4.0, 3.0, 2.0, 1.0])

    println("dv1 = [1, 2, 3, 4, 5]")
    println("dv2 = [5, 4, 3, 2, 1]")

    // Dot product (BLAS ddot)
    let ddot_result = dv1.dot(&dv2)
    println("dv1 . dv2 = {}", ddot_result)  // Expected: 35

    // Norms (BLAS dnrm2, dasum)
    let l2_norm = dv1.norm2()
    let l1_norm = dv1.norm1()
    println("|dv1|_2 = {}", l2_norm)  // Expected: sqrt(55) ≈ 7.416
    println("|dv1|_1 = {}", l1_norm)  // Expected: 15

    // Vector operations
    let dv_add = dv1.add(&dv2)
    println("dv1 + dv2 = [{}, {}, {}, {}, {}]",
        dv_add.get(0), dv_add.get(1), dv_add.get(2), dv_add.get(3), dv_add.get(4))

    let dv_scaled = dv1.normalized()
    println("|normalized(dv1)|_2 = {}", dv_scaled.norm2())  // Expected: 1.0
    println("")

    // ========================================================================
    // PART 4: Dynamic Matrices (BLAS-Accelerated)
    // ========================================================================
    println("--- Part 4: Dynamic Dense Matrices ---")
    println("")

    // Create matrices
    let eye3 = DenseMatrix::eye(3)
    println("I_3 = 3x3 identity matrix")
    println("trace(I_3) = {}", eye3.trace())  // Expected: 3

    // Create a 2x3 matrix
    let mut dm = DenseMatrix::zeros(2, 3)
    dm.set(0, 0, 1.0)
    dm.set(0, 1, 2.0)
    dm.set(0, 2, 3.0)
    dm.set(1, 0, 4.0)
    dm.set(1, 1, 5.0)
    dm.set(1, 2, 6.0)

    println("A = [[1, 2, 3], [4, 5, 6]]")
    println("||A||_F = {}", dm.frobenius_norm())  // Expected: sqrt(91) ≈ 9.539

    // Matrix-vector multiply (BLAS dgemv)
    let x = DenseVector::ones(3)
    let y = dm.mul_vec(&x)
    println("A * [1,1,1] = [{}, {}]", y.get(0), y.get(1))  // Expected: [6, 15]

    // Matrix-matrix multiply (BLAS dgemm)
    let a = DenseMatrix::eye(3)
    let b = DenseMatrix::eye(3)
    let c = a.mul(&b)
    println("I * I = I, trace = {}", c.trace())  // Expected: 3

    // Transpose
    let at = dm.transpose()
    println("A^T is {}x{}", at.rows(), at.cols())  // Expected: 3x2
    println("")

    // ========================================================================
    // PART 5: Linear Algebra Operations (LAPACK)
    // ========================================================================
    println("--- Part 5: LAPACK Operations ---")
    println("")

    // Create a 3x3 test matrix
    let mut test_mat = DenseMatrix::zeros(3, 3)
    test_mat.set(0, 0, 4.0)
    test_mat.set(0, 1, 2.0)
    test_mat.set(0, 2, 0.0)
    test_mat.set(1, 0, 2.0)
    test_mat.set(1, 1, 5.0)
    test_mat.set(1, 2, 3.0)
    test_mat.set(2, 0, 0.0)
    test_mat.set(2, 1, 3.0)
    test_mat.set(2, 2, 6.0)

    println("Test matrix (symmetric positive definite):")
    println("[[4, 2, 0], [2, 5, 3], [0, 3, 6]]")

    // Determinant
    match test_mat.determinant() {
        Ok(det) => println("det(A) = {}", det),
        Err(e) => println("Error computing det: {}", e)
    }

    // Inverse
    match test_mat.inverse() {
        Ok(inv) => {
            let product = test_mat.mul(&inv)
            println("trace(A * A^(-1)) = {} (should be 3)", product.trace())
        },
        Err(e) => println("Error computing inverse: {}", e)
    }

    // Solve linear system
    let b = DenseVector::from_slice(&[1.0, 2.0, 3.0])
    match test_mat.solve(&b) {
        Ok(solution) => {
            println("Solved Ax = b")
            let residual = test_mat.mul_vec(&solution).sub(&b).norm2()
            println("Residual ||Ax - b|| = {}", residual)
        },
        Err(e) => println("Error solving system: {}", e)
    }

    // Cholesky factorization (for SPD matrix)
    match test_mat.cholesky() {
        Ok(l) => println("Cholesky factorization succeeded"),
        Err(e) => println("Cholesky failed: {}", e)
    }

    // Eigenvalues (symmetric)
    match test_mat.eigh() {
        Ok(eig) => {
            println("Eigenvalues: [{}, {}, {}]",
                eig.eigenvalues.get(0),
                eig.eigenvalues.get(1),
                eig.eigenvalues.get(2))
        },
        Err(e) => println("Eigenvalue computation failed: {}", e)
    }
    println("")

    // ========================================================================
    // PART 6: Practical Example - Least Squares Fitting
    // ========================================================================
    println("--- Part 6: Practical Example - Least Squares ---")
    println("")

    // Fit a line y = mx + c to data points
    // Data: (0, 1), (1, 3), (2, 4), (3, 6)
    // Design matrix A = [[1, 0], [1, 1], [1, 2], [1, 3]]
    // Observations y = [1, 3, 4, 6]
    // Normal equations: A^T A x = A^T y

    let mut design = DenseMatrix::zeros(4, 2)
    design.set(0, 0, 1.0); design.set(0, 1, 0.0)
    design.set(1, 0, 1.0); design.set(1, 1, 1.0)
    design.set(2, 0, 1.0); design.set(2, 1, 2.0)
    design.set(3, 0, 1.0); design.set(3, 1, 3.0)

    let observations = DenseVector::from_slice(&[1.0, 3.0, 4.0, 6.0])

    // Compute A^T * A
    let at = design.transpose()
    let ata = at.mul(&design)

    // Compute A^T * y
    let aty = at.mul_vec(&observations)

    // Solve normal equations
    match ata.solve(&aty) {
        Ok(coeffs) => {
            println("Linear fit: y = {} + {}*x",
                coeffs.get(0), coeffs.get(1))
            // Expected: y ≈ 1.0 + 1.6*x
        },
        Err(e) => println("Least squares failed: {}", e)
    }
    println("")

    // ========================================================================
    // SUMMARY
    // ========================================================================
    println("=== Demo Complete ===")
    println("")
    println("Features demonstrated:")
    println("  - Fixed-size vectors (Vec2, Vec3, Vec4, Vec14)")
    println("  - Fixed-size matrices (Mat2, Mat3, Mat4)")
    println("  - Dynamic dense vectors with BLAS (DenseVector)")
    println("  - Dynamic dense matrices with BLAS (DenseMatrix)")
    println("  - BLAS Level 1: dot, nrm2, axpy, scal")
    println("  - BLAS Level 2: gemv (matrix-vector multiply)")
    println("  - BLAS Level 3: gemm (matrix-matrix multiply)")
    println("  - LAPACK: det, inv, solve, cholesky, eigh")
    println("")

    return 0
}

// ============================================================================
// Unit Tests
// ============================================================================

#[test]
fn test_fixed_vec3_operations() {
    let v1 = vec3_new(1.0, 2.0, 3.0)
    let v2 = vec3_new(4.0, 5.0, 6.0)

    // Test dot product
    let dot = vec3_dot(v1, v2)
    assert_approx(dot, 32.0)

    // Test norm
    let norm = vec3_norm(v1)
    assert_approx(norm, 3.7416573867739413)

    // Test cross product
    let cross = vec3_cross(v1, v2)
    assert_approx(cross.x, -3.0)
    assert_approx(cross.y, 6.0)
    assert_approx(cross.z, -3.0)
}

#[test]
fn test_fixed_mat3_operations() {
    let m = mat3_new(
        1.0, 2.0, 3.0,
        0.0, 1.0, 4.0,
        5.0, 6.0, 0.0
    )

    // Test determinant
    let det = mat3_det(m)
    assert_approx(det, 1.0)

    // Test trace
    let trace = mat3_trace(m)
    assert_approx(trace, 2.0)

    // Test inverse (M * M^-1 = I)
    let m_inv = mat3_inverse(m)
    let product = mat3_mul(m, m_inv)
    assert_approx(mat3_trace(product), 3.0)
}

#[test]
fn test_dense_vector_operations() {
    let v1 = DenseVector::from_slice(&[1.0, 2.0, 3.0])
    let v2 = DenseVector::from_slice(&[4.0, 5.0, 6.0])

    // Test dot product
    assert_approx(v1.dot(&v2), 32.0)

    // Test L2 norm
    assert_approx(v1.norm2(), 3.7416573867739413)

    // Test L1 norm
    assert_approx(v1.norm1(), 6.0)
}

#[test]
fn test_dense_matrix_operations() {
    let eye = DenseMatrix::eye(3)

    // Test dimensions
    assert_eq(eye.rows(), 3)
    assert_eq(eye.cols(), 3)

    // Test trace
    assert_approx(eye.trace(), 3.0)

    // Test I * I = I
    let product = eye.mul(&eye)
    assert_approx(product.trace(), 3.0)
}

#[test]
fn test_matrix_vector_multiply() {
    // A = [[1, 2], [3, 4]]
    let mut a = DenseMatrix::zeros(2, 2)
    a.set(0, 0, 1.0)
    a.set(0, 1, 2.0)
    a.set(1, 0, 3.0)
    a.set(1, 1, 4.0)

    // x = [1, 1]
    let x = DenseVector::ones(2)

    // A * x = [3, 7]
    let y = a.mul_vec(&x)
    assert_approx(y.get(0), 3.0)
    assert_approx(y.get(1), 7.0)
}

#[test]
fn test_matrix_solve() {
    // Simple 2x2 system: [[2, 0], [0, 3]] * x = [4, 9]
    // Solution: x = [2, 3]
    let mut a = DenseMatrix::zeros(2, 2)
    a.set(0, 0, 2.0)
    a.set(1, 1, 3.0)

    let b = DenseVector::from_slice(&[4.0, 9.0])

    match a.solve(&b) {
        Ok(x) => {
            assert_approx(x.get(0), 2.0)
            assert_approx(x.get(1), 3.0)
        },
        Err(_) => panic("solve failed")
    }
}
