/// Quaternion Lift and Dicyclic Groups
///
/// Implementation of the double cover Dic_n → D_n
/// for verifying algebraic structure of genomic symmetries.

module quaternion

// Math constants and functions (no stdlib math module yet)
let PI: f64 = 3.14159265358979323846

/// Sine approximation using Taylor series
fn sin_approx(x: f64) -> f64 {
    // Normalize to [-PI, PI]
    var angle = x
    while angle > PI { angle = angle - 2.0 * PI }
    while angle < -PI { angle = angle + 2.0 * PI }

    // Taylor series: sin(x) = x - x³/3! + x⁵/5! - x⁷/7! + ...
    let x2 = angle * angle
    let x3 = angle * x2
    let x5 = x3 * x2
    let x7 = x5 * x2
    angle - x3 / 6.0 + x5 / 120.0 - x7 / 5040.0
}

/// Cosine approximation using Taylor series
fn cos_approx(x: f64) -> f64 {
    // Normalize to [-PI, PI]
    var angle = x
    while angle > PI { angle = angle - 2.0 * PI }
    while angle < -PI { angle = angle + 2.0 * PI }

    // Taylor series: cos(x) = 1 - x²/2! + x⁴/4! - x⁶/6! + ...
    let x2 = angle * angle
    let x4 = x2 * x2
    let x6 = x4 * x2
    1.0 - x2 / 2.0 + x4 / 24.0 - x6 / 720.0
}

/// Quaternion representation: q = w + xi + yj + zk
pub struct Quaternion {
    pub w: f64,  // Scalar part
    pub x: f64,  // i component
    pub y: f64,  // j component
    pub z: f64,  // k component
}

impl Quaternion {
    pub fn new(w: f64, x: f64, y: f64, z: f64) -> Quaternion {
        Quaternion { w, x, y, z }
    }

    pub fn identity() -> Quaternion {
        Quaternion::new(1.0, 0.0, 0.0, 0.0)
    }

    pub fn neg_identity() -> Quaternion {
        Quaternion::new(-1.0, 0.0, 0.0, 0.0)
    }

    /// Quaternion multiplication (Hamilton product)
    pub fn mul(&self, other: &Quaternion) -> Quaternion {
        Quaternion::new(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )
    }

    /// Negation: -q
    pub fn neg(&self) -> Quaternion {
        Quaternion::new(-self.w, -self.x, -self.y, -self.z)
    }

    /// Check approximate equality
    pub fn approx_eq(&self, other: &Quaternion, tol: f64) -> bool {
        abs_f64(self.w - other.w) < tol &&
        abs_f64(self.x - other.x) < tol &&
        abs_f64(self.y - other.y) < tol &&
        abs_f64(self.z - other.z) < tol
    }
}

/// Helper: absolute value
fn abs_f64(x: f64) -> f64 {
    if x < 0.0 { -x } else { x }
}

/// Dicyclic group Dic_n
/// Generated by a, b with relations:
/// - a^{2n} = 1
/// - b^2 = a^n
/// - b^{-1}ab = a^{-1}
pub struct DicyclicGroup {
    pub n: usize,
}

impl DicyclicGroup {
    pub fn new(n: usize) -> DicyclicGroup {
        // Dicyclic group requires n >= 2
        DicyclicGroup { n }
    }

    /// Order of the group: |Dic_n| = 4n
    pub fn order(&self) -> usize {
        4 * self.n
    }
}

/// Element of Dic_n represented as a^k or a^k * b
pub struct DicyclicElement {
    pub q: Quaternion,
}

/// Generate dicyclic group element
/// k: power of generator a
/// is_reflection: whether to multiply by b
pub fn dicyclic_element(g: &DicyclicGroup, k: usize, is_reflection: bool) -> DicyclicElement {
    let n = g.n
    let theta = PI * (k as f64) / (n as f64)

    // a = exp(πi/n) as unit quaternion
    let a_k = Quaternion::new(cos_approx(theta), sin_approx(theta), 0.0, 0.0)

    if is_reflection {
        // b = j in quaternion representation
        let b = Quaternion::new(0.0, 0.0, 1.0, 0.0)
        DicyclicElement { q: a_k.mul(&b) }
    } else {
        DicyclicElement { q: a_k }
    }
}

/// Project quaternion to dihedral group element
/// Returns (rotation_index, is_reflection)
pub fn project_to_dihedral(elem: &DicyclicElement, g: &DicyclicGroup) -> (usize, bool) {
    let q = &elem.q
    let n = g.n

    // Check if rotation (z=0) or reflection (y≠0 or z≠0)
    let is_reflection = abs_f64(q.y) > 1e-10 || abs_f64(q.z) > 1e-10

    // Extract rotation angle from w + xi part
    let angle = atan2(q.x, q.w)
    let k_float = angle * (n as f64) / PI
    // Simple rounding: add 0.5 and truncate
    let k_raw = if k_float >= 0.0 {
        (k_float + 0.5) as i64
    } else {
        (k_float - 0.5) as i64
    }
    let k = ((k_raw % (n as i64)) + (n as i64)) as usize % n

    (k, is_reflection)
}

/// Helper: atan2 approximation
fn atan2(y: f64, x: f64) -> f64 {
    // Simple atan2 implementation
    if x > 0.0 {
        atan(y / x)
    } else if x < 0.0 && y >= 0.0 {
        atan(y / x) + PI
    } else if x < 0.0 && y < 0.0 {
        atan(y / x) - PI
    } else if x == 0.0 && y > 0.0 {
        PI / 2.0
    } else if x == 0.0 && y < 0.0 {
        -PI / 2.0
    } else {
        0.0
    }
}

/// Helper: atan approximation using Taylor series
fn atan(x: f64) -> f64 {
    // Use standard library if available, otherwise Taylor approximation
    // For small x: atan(x) ≈ x - x³/3 + x⁵/5 - ...
    let x2 = x * x
    if abs_f64(x) <= 1.0 {
        x * (1.0 - x2 * (1.0/3.0 - x2 * (1.0/5.0 - x2 * (1.0/7.0))))
    } else {
        let sign = if x > 0.0 { 1.0 } else { -1.0 }
        let inv = 1.0 / x
        let inv2 = inv * inv
        sign * (PI / 2.0 - inv * (1.0 - inv2 * (1.0/3.0 - inv2 * (1.0/5.0))))
    }
}

/// Verify that Dic_n is a double cover of D_n
/// Check: for each g ∈ Dic_n, both g and -g project to same D_n element
pub fn verify_double_cover(g: &DicyclicGroup) -> bool {
    let n = g.n

    var k: usize = 0
    while k < 2 * n {
        // Test both reflection states
        var is_ref_idx: usize = 0
        while is_ref_idx < 2 {
            let is_ref = is_ref_idx == 1
            let elem = dicyclic_element(g, k, is_ref)
            let neg_elem = DicyclicElement { q: elem.q.neg() }

            let proj1 = project_to_dihedral(&elem, g)
            let proj2 = project_to_dihedral(&neg_elem, g)

            if proj1.0 != proj2.0 || proj1.1 != proj2.1 {
                return false
            }
            is_ref_idx = is_ref_idx + 1
        }
        k = k + 1
    }

    true
}

// =============================================================================
// Test Functions
// =============================================================================

pub fn test_quaternion_identity() -> bool {
    let id = Quaternion::identity()
    let q = Quaternion::new(1.0, 2.0, 3.0, 4.0)
    id.mul(&q).approx_eq(&q, 1e-10)
}

pub fn test_dicyclic_order() -> bool {
    let g = DicyclicGroup::new(4)
    g.order() == 16
}

pub fn test_double_cover() -> bool {
    var n: usize = 2
    while n <= 8 {
        let g = DicyclicGroup::new(n)
        if !verify_double_cover(&g) {
            return false
        }
        n = n + 1
    }
    true
}

/// Run all quaternion tests
pub fn run_quaternion_tests() -> bool {
    test_quaternion_identity() && test_dicyclic_order() && test_double_cover()
}
